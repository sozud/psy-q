$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$


TMDVIEW５	GsDOBJ5 型 オブジェクトを使ったTMDビューワー


				1994.12.9
				CopyRight (C) Sony Computer Entertainment

tuto0:	simpleなGsDOBJ５ビューワー

【起動方法】
		make tuto0	コンパイル＆必要なファイルを読み込み(tuto0)

【操作方法】
		普通のTMDビューワーと同じです。

	左十字キー	並行移動
	右十字キー	回転
	ABホタン	拡大縮小

【モデリングデータ】

		モデリングデータは、以下の１６種類が用意されています。
		ファイル名の gは、 グーローシェーディングデータを
			     tは、 半透明データを
			     lは、 光源計算なしデータを表します。

		モデリングの形状は、すべて立方体でそのうち３面には
		テクスチャは張っておらず、残りの３面には、15bit,8bit,4bit
		のテクスチャが張ってあります。

		このプログラムは、モデリングデータを入れ換えるだけで
		ここにある１６種類すべてのデータをビューイングできます。

		cube3.tmd		フラット３角ポリゴン
		cube3g.tmd		グーロー３角ポリゴン
		cube3gl.tmd		グーロー光源計算なし３角ポリゴン
		cube3gt.tmd		グーロー半透明３角ポリゴン
		cube3gtl.tmd		グーロー半透明光源計算なし３角ポリゴン
		cube3l.tmd		フラット光源計算なし３角ポリゴン
		cube3t.tmd		フラット半透明３角ポリゴン
		cube3tl.tmd		フラット半透明光源計算なし３角ポリゴン

		cube4.tmd		フラット３角ポリゴン
		cube4g.tmd		グーロー３角ポリゴン
		cube4gl.tmd		グーロー光源計算なし３角ポリゴン
		cube4gt.tmd		グーロー半透明３角ポリゴン
		cube4gtl.tmd		グーロー半透明光源計算なし３角ポリゴン
		cube4l.tmd		フラット光源計算なし３角ポリゴン
		cube4t.tmd		フラット半透明３角ポリゴン
		cube4tl.tmd		フラット半透明光源計算なし３角ポリゴン

		また 一般的な モデリングデータ shuttle1.tmdも用意しました。


【テクスチャデータ】
		テクスチャデータは、6種類が用意されている。

		pat4.tim		4bitテクスチャデータ
		pat8.tim		8bitテクスチャデータ
		pat16.tim		16bitテクスチャデータ
		pat4t.tim		4bitテクスチャデータ(半透明）
		pat8t.tim		8bitテクスチャデータ（半透明）
		pat16t.tim		16bitテクスチャデータ（半透明）


【説明】

		GsDOBJ5というオブジェクトは、プリセットパケットと呼ばれる
		タイプのデータを扱います。プリセットパケットとは、予め
		TMDで定義されているすべてのポリゴンのパケットをメモリー
		上に作成しておき必要な所だけを書き換えるとうものです。

		こうすることで、処理のネックになるメモリアクセスを軽減し
		高速化を計ります。例えば、光源計算をしないポリゴンについては、
		ポリゴンのRGB値は 書き換えません。

		プリセットパケットのもう一つの利点として、予めポリゴンの
		種類をまとめておき、ポリゴン毎に、種類のデコードを省ける
		という、ものがあります。

		オブジェクト毎にポリゴンの種類をまとめる TMDのフィルタを
		ちかじかリリースする予定です。

		これらの 技術により 従来のGsDOBJ2に比べて 倍近いスピード
		アップを達成しました。


		自動分割機能とは、アトリビュートに自動分割数を設定すると
		実行時にそのオブジェクトの表示されるポリゴンの全てを
		分割するものです。分割されたパケットは プリセットの領域とは
		別にとられるため、GsSetWorkBase()で設定する必要があります。


tuto1:	GsDOBJ５を使った スプリット画面のサンプル

【起動方法】
		make tuto1	コンパイル＆必要なファイルを読み込み(tuto1)

【操作方法】
		tuto0と同じ

【モデリングデータ】

		tuto0と同じ
【説明】
		このプログラムは、画面を２分割して別々の視点から眺められる
		ようにしたものです。

		モデリングデータは、上下の画面とも共用で使っていますが、
		オブジェクトハンドラは、上下の画面で別々に用意しています。

		LIBGPUがキューイングするため、Draw命令は、連続的に
		送っても キューにつまれ すぐにリターンします。


tuto2:	GsDOBJ５を使ったオブジェクトの使い回し 及び 複数オーダリングテーブル

【起動方法】
		make tuto2	コンパイル＆必要なファイルを読み込み(tuto2)

【操作方法】

		右十字キー	オブジェクト０の回転
		右上キー	オブジェクト０のズームイン＆アウト

		左十字キー	オブジェクト１の回転
		左上キー	オブジェクト１のズームイン＆アウト

【モデリングデータ】

		tuto0と同じ

【説明】
		このプログラムは、オブジェクトを使い回し、複数のOTに
		それぞれを割り当てた 複数OTのサンプルです。

		GsClearOt(offset,point,Wot2) で設定される Wot2のpointが
		GsSortOt(Wot2,Wot1)で参照され、Wot1のZテーブルに割り付け
		られます。

		サンプルでWot2のpointは、０でコールしていますので 必ず
		Wot2にソートされたオブジェクト２の方が、手前になります。
		コメントされているpointは、1<<OT_LENGTH-1です。これで
		コールすれば、オブジェクト２の方が必ず奥になります。



tuto3:	GsDOBJ５を使った自動分割のサンプル

【起動方法】
		make tuto3	コンパイル＆必要なファイルを読み込み(tuto3)

【操作方法】

		右十字キー	オブジェクト０の回転
		右上キー	オブジェクト０のズームイン＆アウト

		左十字キー	オブジェクト１の回転
		左上キー	オブジェクト１のズームイン＆アウト

【モデリングデータ】

		tuto0と同じ

【説明】
		このプログラムは、オブジェクトの自動分割を行なったものです。

		自動分割の制御は、attributeにGsDIV1(2x2 4分割）、GsDIV2(4x4
		16分割）、GsDIV3(8x8 64分割)、GsDIV4(16x16 256分割）
		をor書きすることで設定します。

		分割用のパケットエリアは、プリセット領域とは別にとられるため
		GsSetWorkBase()で指定してやる必要があります。


tuto4:	マルチスクリーン座標系

【起動方法】
		psymake tuto4	コンパイル＆必要なファイルを読み込み(tuto4)

【操作方法】

		左十字キー	オブジェクトのXY並行移動
		右十字キー	オブジェクトの回転

		右側面キー奥	オブジェクトZ方向へのズームアウト
		右側面キー手前	オブジェクトZ方向へのズームイン

		左側面キー奥	screen座標 NORMAL SCALING
		左側面キー手前	screen座標 1/8 SCALING

【モデリングデータ】

		tuto0と同じ

【説明】
		このプログラムは SCREEN座標のスケーリングを変える関数
		GsSetScreenScale()を用いたサンプルです。

		スクリーン座標系のスケーリングを変えることによって
		視点とオブジェクトの距離が16bitを超えても クリップする
		ことなく 表示できるようになります。

		例えば このサンプルでは スクリーン座標系を1/8にスケーリング
		しているため オブジェクトと視点がの距離が１６ビットを超えても
		１９ビット以内であれば 表示可能です。

		注意事項として スクリーン座標系をスケーリングすると 
		OTのスケールも変化します。スケールの違うスクリーン座標系
		で計算したオブジェクトは 同じスケールでOTに登録しては
		いけません。

		例えば 1/8スケールのスクリーン座標系で計算したオブジェクト
		を ソートしたOTに ノーマルスケーリングのスクリーン座標で
		計算したオブジェクトをソートするには SortObjectのshift値を
		３余計に増やす必要があります。


tuto5:	tuto0.cをGsSortObject5J()を使って書き換えたサンプル

【起動方法】
		psymake tuto5	コンパイル＆必要なファイルを読み込み(tuto5)

【操作方法】
		tuto0と同じ

【モデリングデータ】

		cube3.tmdに限定

【説明】
		このプログラムは GsSortObject5()をGsSortObject5J()に
		書き換えたものです。GsSortObject5J()を使うことで
		GsSortObject5()で呼んでいる 下位関数のうち 不要なものを
		リンクせず コードを小さくすることができます。

		変更した部分は init_all()中で jt_init()を呼ぶようにしたことと
		GsSortObject5 -> GsSortObject5J に変えた部分だけです。

		jt_init()の中では GsPrstF3L,GsPrstTF3Lのみを登録しているので
		光源計算型のフラット３角形 でかつ 標準の光源計算をする機能
		しかありません。よって 自動分割、FOG計算、光源計算OFFを
		設定することはできません。

		ただし 機能を絞っていることで コードサイズは tuto0に比べて
		48Kbyteも減少しています。

		もし より多くの機能を使う場合は それに応じた関数をテーブルに
		登録すればいいのです。全ての関数をテーブルに登録すると
		GsSortObject5()とコンパチになります。
		GsSortObject5()とコンパチになる jt_init()のひな型が
		libgs.hにコメントとして入っています。jt_init5()

		GsSortObject5() どの下位関数が使われているかを 調べるには
		取り敢えず dmyを先頭につけた関数を登録してみてください。
		（dmyGsPrstF3L,dmyGsPrstTF3Lなど）
		この関数は 最初に呼ばれた時に その関数の タイプをprintf
		します。



tuto6:	tuto0.cをモデルを動かすのではなく 視点を主観的に動かしたサンプル

【起動方法】
		psymake tuto6	コンパイル＆必要なファイルを読み込み(tuto6)

【操作方法】
		右十字キー	視点の回転
		左十字キー	視点の平行移動
		側面左キー	視点のZ軸の平行移動
		側面右キー	視点のZ軸回りの回転

【モデリングデータ】

		tuto0と同じ

【説明】
		このプログラムは 視点を主観的に動かすサンプルです。
		キーにアサインされている 動きは全て視点座標系に従います。
		例えばZ軸の平行移動をすると 視線の方向に進みます。
		回転移動は 視線の方向を変化させます。

		プログラムは 座標系を一つ用意し（DView) その座標系にカメラを
		ぶら下げています。DViewを 主観的に動かしたいため 平行移動
		は DView内での移動に Dview.coordを掛けてWorld座標系の
		移動に変換して指定しています。

		回転移動に関しては tuto0の様に 回転角から 毎フレーム回転
		マトリックスを求めると 主観的移動では計算が複雑化するため
		直前のフレームのマトリックスを使って計算しています。

		しかし この計算法では誤差が蓄積されてしまうので 形が
		歪んできてしまいます。それを避けるために MatrixNormal()
		をコールしています。MatrixNormal()は 形を歪めるマトリックス
		を 歪めないマトリックスへ正規化します。

		ただし 平行移動に関しては このプログラムでは正規化していない
		ので 誤差が蓄積されてしまいます。その弊害として 例えば
		中心を回る軌道が 長時間回り続けると 中央に縮退するなどの
		弊害があるので注意が 必要です。


								以上
