$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$


		地面サンプルプログラム	Ver 0.2(Proto Type)	'95 6,22


tuto0	プリミティブ自動分割
	
	POLY_FT4 プリミティブをメッシュ上に自動分割します。
	プリミティブは、各辺の中点を新しい頂点とした４つの４角形に４分
	割されます。それ以上の分割が指定された場合は、分割された４つの小
	４角形ごとにおなじ操作が再帰的に繰り返されます。
	再帰分割時にすべての頂点が描画領域外であれば、それより以降の分割
	は行なわれません。

	スクリーンに近いプリミティブは、分割することにより以下の効果が
	期待できます。
	
	・描画領域をおおきくはみ出したプリミティブは、前もって除去
	  されるため描画のオーバーヘッドが軽減されます。

	・視点に近付いて、プリミティブが非常に大きくなった場合も描画
	  時にクリップされません。

	・線形のテクスチャマッピングによる対角線の歪みを軽減できます。
	
	分割プログラムのサンプルは、div.c を参照ください。
	なお、ここの自動分割サンプルは動作を説明するためのものであり、
	より高速の処理が必要な場合は、DivPolyFT4() を御使用下さい。
	
tuto1	領域クリップ

	z = 0 の平面上にメッシュ上に並べられたプリミティブをクリップし
	ます。クリップは、スクリーンの各４頂点と原点を通る直線をワール
	ド座標系に変換し、これと、z = 0 の平面上の点を求めます。
	例えば、640x480 モードでであれば、スクリーンの位置は、スクリー
	ン座標系で
	
		(-320,-240,SCR_Z)-(320,240,SCR_Z)
	
	になります。これをワールド座標系に変換した後、ワールド座標系で
	の視点の位置とスクリーンの各頂点を結ぶ直線と平面  z = 0 との交
	点をもとめます。こうして計算された４点に囲まれる領域が実際に座
	標透変換・視変換(RotTransPers()) 後に表示されることになります。
	
	詳細は、clip.c を参照下さい。
	
	screen_to_matrix() 関数はスクリーン座標系からワールド座標系へ
	の変換を行ないます。
	
	get_z_cross_point() は、指定された２点を通る直線と z = 0 の平
	面との交点を求めます。
	
	rot_trans_pers() は、座標値をワールド座標系からスクリーン座標系
	へ変換したのち、透視変換を行ないます。RotTransPers() と異なり、
	GTE オフセットの影響を受けません。
	
	y = 0, x = 0 の平面の場合も座標系の対称性を利用して若干の変更
	で使用できます。
	
	プログラムの中央の長方形が、スクリーンです。その外側の４角形が
	スクリーン長方形を z = 0 の平面に投影した図形を崩落する長方形
	です。

tuto2	有限マップを持つ地面

	地面は有限の大きさをもつメッシュ構造として表現されます。
	このモデルでは、世界の端が存在します。
	メッシュの各セルに対応するテクスチャパターンはマップデータから定
	義されます。これは、基本的には、通常の２次元のスクロール BG
	(BackGround) のデータ構造と同様のものです。

	地面メッシュは、SVECTOR の２次元配列です。ここの vz メンバ（デ
	フォルトは 0) を操作することで高さを持つ地面を表現することがで
	きます。詳細は、mesh.c を参照下さい。

	メッシュセルは、ワールド座標系とスクリーン座標系で２段階でクリッ
	プされます。ワールド座標系でのクリップ領域は RECT *clipw で指
	定されます。clipw に含まれるメッシュセルが回転・透視変換され、
	その結果がスクリーン座標系でのクリップ範囲 RECT *clips に含ま
	れるかで２段階目のクリップが行なわれます。

	メッシュの各頂点は最初に clipw の範囲にはずれるものが除去され、
	これ以内に収まるものが座標変換されます。また、変換後の２次元の
	頂点が clips で示されるスクリーン範囲をはずれるものもクリップ
	されます。メッシュセルは、セルの４頂点のいずれかがクリップ範囲
	内にあるものだけが OT に登録されます。

	ここのメッシュサンプルは、動作を説明するためのものであり、より
	高速な処理が必要な場合は、RotMesh 関数、あるいは、最低でも
	RotTransPersN() を使用すべきです。
	
tuto3	無限マップを持つ地面

	移動ベクトル(Translation Vector) をマップの１キャラクタに等し
	い大きさでラップラウンドさせ、ラップラウンドに合わせてマップの
	位置をずらすことで、無限に繰り返される地面のパターンが生成でき
	ます。
	
	このモデルでは、世界の端が存在しませんが、ワールド座標系での視
	点（カメラ）の物理的な座標値と論理的な座標値が異なります。
	
tuto4	自動分割付き地面

	OT エントリの値 sz に応じて分割の on/off と分割数を適応的に切
	替える例です。div_addprim() 関数がそれを行ないます。
	

tuto5	CLUT フォグを行なう例

	以上の処理をまとめてコーディングした例です。各プリミティブデプス
	キューの値(p)に応じて CLUT のエントリを切替え、CLUT フォグを行
	なう機能が追加されています。詳細は以下のドキュメントを参照下さ
	い。

座標変換について

	いずれのサンプルも、地面はマップデータの操作の容易さから ワー
	ルド座標系で z = 0 の平面が仮定されています。また視点位置は同
	じくワールド座標系で z > 0 の任意の点が仮定されています。
	そのため、スクリーン座標系に変換する際には、注意が必要です。
	自然な初期位置は pad.c でシンボル HOME を define して下さい。
	これは、地面を真上から見下ろす角度になります。

	モデルは、地面はワールド座標系で固定され、視点がワールド座標系
	移動していくものです。このためには、RotTrans() で常に視点のワー
	ルド座標が常に原点 （0,0,0) に変換されるように移動ベクトルを設
	定することが必要です。RotTrans() は回転後に並行移動を行なうの
	で、
		x: ワールド座標, R:回転マトリクス, t:移動ベクトル
	
	とすると、RotTrans() は、以下のようになります。
	
		 y = Rx + t
	
	これから、y = 0 とおくと t = -Rx が得られます。x は視点のワー
	ルド座標です。これが移動ベクトルの値となります。

	また、視点の移動方向（視点位置の時間差分）はスクリーン座標系で記
	述されます。コントローラで指定される移動方向は、スクリーン座標系
	で与えられた方が自然なためです。しかし、視点位置自体はワールド座
	標系で処理した方が簡単なため、スクリーン座標系で表された移動方向
	を一旦ワールド座標に変換した後、ワールド座標での視点位置座標に加
	算する処理が必要になります。
	
	スクリーン座標からワールド座標を求める処理（RotTrans() の逆変換）
	は、

		x = RR(y - t) = RRy - RRt	RR: R の逆行列

	で計算できます。回転マトリクスに限っては、R の逆行列
	(Inversed Matrix) は、R の転置行列 (Transposed Matrix) と等しい
	ことから、容易に計算できます。
	
-------------------------------------------------------	
【tuto5.c】

【サンプルの概要】

2DのBGをX軸で横倒しにして その平面上を視点が 平面にそって上下左右に移動する
サンプルです。まだ高さの表現ができていませんが 平面で地面を表現する目的
には 充分に使えると思います。また サンプルとしてソースで提供されているため
自由に改変して組み込むことができます。

負荷としては サンプルで設定されているデフォルトのパラメータでは
地面を計算するルーチンは３０〜７０スキャンラインぐらい消費しています。
これは どこまで見えるようにするか、自動分割をどの程度にするか
などのパラメータを変えることで激的に増減するのでアプリケーション毎に
負荷も含めて細かくパラメータを調整する必要があります。


実現されている機能は

・ ポリゴンの大きさ および 視点座標のZ値による 自動分割
   および Z値による分割数の決定
・ マップデータのラップラウンド
・ ポリゴン単位の デプスキューイング
・ sample/graphics/tuto/tuto8.c と共通のマップデータの採用
・ 高速化のためのエリアクリッピング
・ 主観的視点移動
・ 32bit空間で無限に広がる平面


現状でまだ実現されていないが これから実現しようと思っている機能

・ 奥行きによるテクスチャソースの切り替え
・ さらなる高速化
・ 高さの表現
・ メッシュデータ構造の導入
・ 頂点単位のデプスキューイング



【起動方法】

psymake tuto5
run tuto5

【操作ガイド】

左十字キー
	上	視点を上方へ移動させる
	下	視点を下方へ移動させる
	右	視点を右に移動させる
	左	視点を左に移動させる


右十字キー
	上	not use
	下	not use
	右	視点の向きを時計回りに回転させる
	左	視点の向きを反時計回りに回転させる

左側面キー
	奥	地面の見える範囲を広げる
	手前	地面の見える範囲を狭める

右側面キー
	奥	視点を後退させる
	手前	視点を前進させる


【パラメータの解説】

・分割条件パラメータ	自動分割の条件を定義する

typedef struct
{
  u_long nearz;
  u_long shift;
  u_long nz;
  u_long *cond;
} GsDIVCOND0;

	nearz: 視点座標系でこの値より近いZ値を持つものを自動分割する
	shift: Z値をこの値だけシフトして分割数テーブルのインデックスを得る
	nz   : 分割数テーブルの要素数
	cond : 分割数テーブルへのポインタ

分割数テーブルは u_long の配列であり 分割数を２のべき乗で指定する。
例えば 2x2分割は１ 4x4分割は２という具合



・地面オブジェクトハンドラ	地面を定義する

typedef struct
{
  GsCOORDINATE2 *coord2;
  u_long cw,ch;			/* セルの幅 */
  u_long nw,nh;			/* セルの縦横（表示）の数 */
  u_long iw,ih;			/* セルの縦横（１パターン）の数（2^n） */
  GsDIVCOND0 *cond;
}  Gs3DBG0;

	coord2:	地面の属する座標系へのポインタ
	cw,ch :	地面を構成するセルの横・縦幅
	nw,nh : 表示する地面の大きさ（セル単位）
	iw,ih : 繰り返しの単位（マップデータの大きさ）
	        有効ビット数で指定する。例えば16x16のセルが繰り返す場合
		iw=0x0f,ih=0x0f  32x32の場合は iw=0x1f,ih=0x1f
		よって繰り返しの単位は２のべき乗のみが指定可能
	cond  : 自動分割のパラメータ GsDIVCOND0へのポインタ



・マップデータ		地面のセルの順番を定義する

sample/graphics/tuto/tuto8.cを参照して下さい。同じ構造です。
マップデータはアプリケーションに左右されるので 違う構造をもつマップデータ
を使う場合は 適当にソースを書き換えて下さい。


【使い方のティップス】

分割は
１ 近づいてきた地面のポリゴン欠けを防ぐ
２ 近づいてきて巨大化したポリゴンのテクスチャの歪みを防ぐ
目的で行なう。視点を地面に近づければ近づける程 分割数をあげなければならない。
Z値により分割が 行なわれるため 分割するものとしないものの切替が視点の
近くで発生するとテクスチャが動いているところが気になる。そのときは
分割パラメータのnearzを大きくして 遠くから分割するようにすると目立たなくなる。

ただし これらの クオリィティをあげるための分割パラメータの設定は
処理速度に かなり影響を及ぼすため注意しなければならない。


テクスチャのクオリィティをあげるには セル単位のテクスチャソースを拡大率
に合わせて切り替えればよい。このサンプルでは セルのテクスチャの大きさが
32x32で 拡大し過ぎの傾向にあるので64x64ぐらいを使う方が良く見でしょう。



【バグ】

エリアクリッピングの部分がまだ正確に動いておらず 適当にマージンを
取っています。もし 端が欠けるようであれば AM の値（現在1)を2にして
下さい。

エリアクリッピングは 視点を原点から遠ざけるほどうまく働きません。

【CLUT FOG】

CLUT FOGとは 奥行きに応じて CLUTを変えることで FOG機能を実現させる
手法です。通常のFOG機能は テクスチャをはったポリゴンには 暗くする
方向にしか効きませんでしたが CLUT FOGを用いることで 任意の色に解け
こますことができます。


【パラメータの解説】

・ CLUT FOG パラメータ

typedef struct
{
  u_short *clut;
  u_short cbit;
  RECT    rectc;
  CVECTOR bgc;
} GsDPCLUT0;

	clut  :  オリジナルclutのポインタ
	cbit  :  奥行きに応じて変化させるCLUTの数（2のべき乗単位）
	rectc :  ロードされるCLUTのVRAM上のアドレス
	bgc   :  解け込ませる色

CLUT FOGパラメータを引数にして GsMakeDPClut0()を呼ぶことで CLUT FOGで
使う clutがVRAM上に用意される。clutは オリジナルのclutを先頭にして
VRAMのアドレス y 方向に形成される。(下図参照)


 	                 VRAM		CBIT = 2
     ┌─────────────────────┐
     │ 			               	 │
     │				    		 │
     │				    		 │
     │				    		 │
     │				    		 │
     │				    		 │
     │				    		 │
     │				    		 │
     │				    		 │
     │				    		 │
     ├───────┐original clut		 │
     ├───────┤clut 1	    		 │
     ├───────┤clut 2	    		 │
     ├───────┤clut 3	    		 │
     ├───────┘		    		 │
     │				    		 │
     └─────────────────────┘


【関数解説】

・GsMakeDPClut0(GsDPCLUT0 *ClutHandle)	CLUT FOGの作成及びVRAMへのロード

GsDPCLUT0に設定されたパラメータを参照して CLUT FOGを作成し
VRAMのrectcのアドレスに転送する。rectcの領域は上書きされるので
注意が必要。


このCLUT FOGを使って テクスチャポリゴンを描画するには パケット作成時に
clutのアドレスを pの値によって切り替えればよい。 オリジナルのCLUTから
yアドレスだけを オフセットすれば それだけより解け込んだ CLUTになっている。
詳しくは サンプルを参照して下さい。


