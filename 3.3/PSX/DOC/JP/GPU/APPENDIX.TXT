$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
*Appendix 

	ここでは、アプリケーション作成に当たっての以下の注意点
	について解説します。

		・ShadeTex 機能の精度
		・UV スクロール機能の精度
		・テクスチャキャッシュ
		・テクスチャポリゴンの座標指定
		・描画処理速度評価ルール
		・テクスチャキャッシュ構成に関して
		・PAL 方式への対応について
		・フレームバッファの切替えタイミングに関して	

** ShadeTex 機能の精度
		
	GPU の ShadeTex 機能（シェーディングとテクスチャマッピング
	を同時に使用する機能）について、
	
	(Sr, Sg, Sb)	シェーディング輝度値（プリミティブの (r, g, b)
			フィールドの輝度値
	
	(Tr, Tg, Tx)	テクスチャの輝度値	    
	
	とすると、シェーディングテクスチャの解像度は、

		Pr = Sr&0xf8 x Tr&0xf8 / 128;	/* 5bit x 上位 5bit */
		Pg = Sg&0xf8 x Tg&0xf8 / 128;
		Pb = Sb&0xf8 x Tb&0xf8 / 128;

	のように計算されます。

	このために、
	
	1) ShadeTex 使用時にテクスチャの色数は、32 階調のまま保存されます。
	2) ShadeTex 使用時にシェーディング輝度値が 256 階調から 32 階調に
	   減少します。

	
** UV スクロール機能の精度
	
	スプライト を使用してスクロール面を表現する際にテクスチャの内
	容を逐次書き変えてスクロールさせると正しくマッピングされない場
	合があります。

	スプライトでは、描画を高速に行なうために 2pixel 単位で処理をおこ
	なっています。そのため、スプライトでは u 座標は 2 の倍数しか指定
	できません。

	u が奇数の場合、
	
	4bit  テクスチャ	16 pixel
	8bit  テクスチャ	 8 pixel
	16bit テクスチャ	 4 pixel

	の間隔でテクスチャピクセルを打ち間違えますので注意が必要です。

** テクスチャキャッシュ

	テクスチャパターンは内部でキャッシングされます。
	テクスチャキャッシュサイズは、テクスチャのモードに応じて異なり、
	以下の通りです。

		======================
		4bit	8bit	16bit
		---------------------
		64x64	32x64	32x32
		---------------------

	プリミティブが使用するテクスチャパターンがこの範囲内にあれば、
	テクスチャパターンはキャッシュされ高速な描画が行なえます。

	CLUT は 1エントリ分のみがキャッシュされます。プリミティブが使
	用す るCLUT が変わらない限り、CLUT はキャッシュされ高速な描画
	が行なえます。

	なお、テクスチャキャッシュ、CLUT キャッシュはフレームバッファ
	アクセスを行なうと自動的にフラッシュされます。
	    
** テクスチャポリゴンの座標指定
	
	テクスチャポリゴンの描画に関しては以下のような問題が報告されて
	います。

	問題１：	
	16×16のポリゴンに16×16のテクスチャーマッピングをして表示をさ
	せるために、(0, 0)-(15, 0)-(0, 15)-(15, 15) のようにパラメータ
	を与えると下と右の1ラインが表示されない。

	問題２：	
	テクスチャポリゴン POLY_FT4 において、テクスチャを拡大して表示
	すると右端・下端が１ドット余分に表示される。

	(x,y)=(0,0)-(16,16), (u,v)=(0,0)-(16,16) 正常
	(x,y)=(0,0)-(17,17), (u,v)=(0,0)-(16,16) 正常
		..........
	(x,y)=(0,0)-(31,31), (u,v)=(0,0)-(16,16) 正常
	(x,y)=(0,0)-(32,32), (u,v)=(0,0)-(16,16) １ドット余分に表示される。

	問題３：	
	テクスチャポリゴン POLY_FT4 において、テクスチャページの右側あ
	るいは、下側に接したテクスチャパターンの指定ができない。

*** 現象と原因
	
	PlayStation では、POLY_* プリミティブの描画ルールでは、最右端
	点および最下端点は描画されません。すなわち４角形を描画した場合、
	
			描画される
			    ↓
			---------
			|	.		
	    描画される→|	.←描画されない
			|........
			    ↑
			描画されない


	となります。これは、ポリゴンを敷き詰めていった場合、ポリゴンの
	境界線上を２度書きしないようにするためのものです。これを行なわ
	ない場合、

		-----------------
		| P0	| P1	|
		|-------+-------|← ２度書きされる
		| P2 	| P3	|
		----------------
		      ↑
		  ２度書きされる
	
	のようなポリゴン P0, P1, P2, P3 を表示した場合に、中央十字の部分
	が２度書きされてしまい、半透明モードの時などに問題が生じます。

	ここで、POLY_FT4 で (x,y) = (0,0)-(8,8), (u,v) = (0,0)-(8,8)
	を指定した正方形を描画する場合、すなわち、

		POLY_FT4 ft4;
		
		ft4.x0 = 0, ft4.y0 = 0;
		ft4.x1 = 8, ft4.y1 = 0;
		ft4.x2 = 0, ft4.y2 = 8;
		ft4.x3 = 8, ft4.y3 = 8;

		ft4.u0 = 0, ft4.v0 = 0;
		ft4.u1 = 8, ft4.v1 = 0;
		ft4.u2 = 0, ft4.v2 = 8;
		ft4.u3 = 8, ft4.v3 = 8;

	とした場合を考えます。このときのテクスチャパターンは、以下のよ
	うにマッピングされます。マスの中の数字はそこのピクセルにコピー
	されるテクスチャパターンの(v,u)を表します。
	（フレームバッファアドレッシングに沿って、(u,v) でなく、(v,u)
	の順番で記述してあります。）

	   0  1  2  3  4  5  6  7  8
	  --------------------------
	0|00|01|02|03|04|05|06|07|08|		
	 |--+--+--+--+--+--+--+--+--|
	1|10|11|12|13|14|15|16|17|18|
	 |--+--+--+--+--+--+--+--+--|
	2|20|21|22|23|24|25|26|27|28|
	 |--+--+--+--+--+--+--+--+--|
		   .......
		   .......
	 |--+--+--+--+--+--+--+--+--|
	7|70|71|72|73|74|75|76|77|78|
	 |--+--+--+--+--+--+--+--+--|
	8|80|81|82|83|84|85|86|87|88|←ここの点の(u,v) が(8,8)になる。
	  --------------------------

	この状態で、先ほどの描画ルールを適用すると右側と下側の１ラインは
	表示されないことから、実際の表示は以下のようになります。
	
	   0  1  2  3  4  5  6  7  
	  -----------------------
	0|00|01|02|03|04|05|06|07|		
	 |--+--+--+--+--+--+--+--|
	1|10|11|12|13|14|15|16|17|
	 |--+--+--+--+--+--+--+--|
	2|20|21|22|23|24|25|26|27|
	 |--+--+--+--+--+--+--+--|
		   .......
		   .......
	 |--+--+--+--+--+--+--+--|
	7|70|71|72|73|74|75|76|77|
	  ------------------------
	
	この例では、正しくピクセル(0,0)から(7,7)にテクスチャ(0,0)-(7,7)
	がマッピングされることになります。

	次に、(u,v) = (0,0)-(7,7) を指定した場合は、以下のようにマップさ
	れます。
	
	   0  1  2  3  4  5  6  7  8
	  --------------------------
	0|00|00|01|02|03|04|05|06|07|		
	 |--+--+--+--+--+--+--+--+--|
	1|00|00|01|02|03|04|05|06|07|		
	 |--+--+--+--+--+--+--+--+--|
		   .......
		   .......
	
	 |--+--+--+--+--+--+--+--+--|
	8|70|70|71|72|73|74|75|76|77|←ここの点の(u,v) が(7,7)になる。
	  --------------------------

	これの、右側と下側の１ラインが削られるため、テクスチャの u=7,
	v=7 で表されるライン、一番右側と下側の１ラインは表示されません。
	
	   0  1  2  3  4  5  6  7 
	  -----------------------
	0|00|00|01|02|03|04|05|06|		
	 |--+--+--+--+--+--+--+--|
	1|00|00|01|02|03|04|05|06|		
	 |--+--+--+--+--+--+--+--|
		   .......
		   .......
	
	 |--+--+--+--+--+--+--+--|
	7|60|60|61|62|63|64|65|66|
	 ------------------------

	これから通常の使用では (x,y)=(0,0)-(8,8), (u,v)=(0,0)-(8,8)
	を使用すれば正しい結果が得られます。
	
	通常のテクスチャマッピングのように、マッピングが連続的である場合、
	すなわち、隣接するポリゴンには必ず隣接するテクスチャパターンが貼
	られる場合には、問題は生じません。しかし、ＢＧの表示では、隣接す
	るセル（POLY_FT4セル）が必ずしも隣接するテクスチャを使用するとは
	限りません。
	
	この場合には、以上のような通常の指定を行なった場合、次のような問
	題が発生します。

*** テクスチャを反転・回転する場合
	
	先ほどのテクスチャを XY 方向に 180°反転して表示する例についてを
	考えます。
	この時、POLY_FT4 で (u,v) の値を変えずに (x,y) を
 
	ft4.x0 = 8, ft4.y0 = 0;
	ft4.x1 = 0, ft4.y1 = 0;
	ft4.x2 = 8, ft4.y2 = 8;
	ft4.x3 = 0, ft4.y3 = 8;

	としたときのテクスチャパターンは、以下のようにマッピングされます。
	マスの中の数字はそこのピクセルにコピーされるテクスチャパターンの
	(u, v)を表します。
	
	   0  1  2  3  4  5  6  7  8
	  --------------------------
	0|08|07|06|05|04|03|02|01|00|		
	 |--+--+--+--+--+--+--+--+--|
	1|18|17|16|15|14|13|12|11|10|
	 |--+--+--+--+--+--+--+--+--|
	2|28|27|26|25|24|23|22|21|20|
	 |--+--+--+--+--+--+--+--+--|
		   .......
		   .......
	 |--+--+--+--+--+--+--+--+--|
	7|78|77|76|75|74|73|72|71|70|
	 |--+--+--+--+--+--+--+--+--|
	8|88|87|86|85|84|83|82|81|80|←ここの点の(u,v) が(0,8)になる。
	  --------------------------
	
	この状態で、先ほどの描画ルールを適用すると右側と下側の１ラインは
	表示されないため、下図のように、(u,v) の(0,0)-(0,7) の１ライン、
	すなわち、UV 空間の (0,0),(1,0),(2,0)....(7.0) の各点がマップさ
	れません。
	そのかわりに、(8,0),(8,1)....(8,7) の各点が左側にあらわれます。
	つまり、全体的に１ドット左にずれてマッピングされているように見え
	ます。

	   0  1  2  3  4  5  6  7 
	  ------------------------
	0|08|07|06|05|04|03|02|01|←ここには、(u,v)=(0,0) がくる
	 |--+--+--+--+--+--+--+--|  はずなのに (1,0) がマップされ
	1|18|17|16|15|14|13|12|11|  てしまう。
	 |--+--+--+--+--+--+--+--|
	2|28|27|26|25|24|23|22|21|
	 |--+--+--+--+--+--+--+--|
		   .......
		   .......
	 |--+--+--+--+--+--+--+--|
	7|78|77|76|75|74|73|72|71|
	  -----------------------
	
	この現象は、テクスチャを垂直方向に反転する場合、ポリゴンを９０°
	以上回転する場合にも発生します。特にポリゴンを回転する場合、マッピ
	ングされるテクスチャピクセルは、回転角に依存して、変動します。

*** テクスチャを拡大する場合。
	
	先ほどの POLY_FT4 を 2 倍に拡大して表示する場合を考えます。この時、
	(x,y) = (0,0)-(16,16), (u,v)=(0,0)-(8,8) と指定すると、テクスチャ
	パターンは、以下のようにマッピングされます。
	（0.5 は、四捨五入されて 1.0 に繰り上げられます。）

	    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
	   --------------------------------------------------
	 0|00|01|01|02|02|03|03|04|04|05|05|06|06|07|07|08|08|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
	 1|00|01|01|02|02|03|03|04|04|05|05|06|06|07|07|08|08|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
	 2|10|11|11|12|12|13|13|14|14|15|15|16|16|17|17|18|18|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
	 3|10|11|11|12|12|13|13|14|14|15|15|16|16|17|17|18|18|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
			   .......
			   .......

	14|70|71|71|72|72|73|73|74|74|75|75|76|76|77|77|78|78|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
	15|80|81|81|82|82|83|83|84|84|85|85|86|86|87|87|88|78|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
	16|80|81|81|82|82|83|83|84|84|85|85|86|86|87|87|88|78|
	   --------------------------------------------------

	
	この状態で、先ほどの描画ルールを適用すると右側と下側の１ライン
	は表示されないことから、下図のように、(u,v) は、(0,0)-(8,8) の範
	囲が表示されます。
	

	    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
	   -----------------------------------------------
	 0|00|01|01|02|02|03|03|04|04|05|05|06|06|07|07|08|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
	 1|00|01|01|02|02|03|03|04|04|05|05|06|06|07|07|08|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
	 2|10|11|11|12|12|13|13|14|14|15|15|16|16|17|17|18|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
	 3|10|11|11|12|12|13|13|14|14|15|15|16|16|17|17|18|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|

			   .......
			   .......

	14|70|71|71|72|72|73|73|74|74|75|75|76|76|77|77|78|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
	15|70|71|71|72|72|73|73|74|74|75|75|76|76|77|77|78|
	  |--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|
	16|80|81|81|82|82|83|83|84|84|85|85|86|86|87|87|88|
	   -----------------------------------------------
							↑
						ここに、u=8 の点が残っ
						てしまう。

	テクスチャを等倍のマッピングから徐々に拡大していくと、ちょうど
	倍率が２倍を越えたところでこの現象が現れます。

***テクスチャページの最左端・最下端のピクセルを指定する場合
	
	全く同様の理由からテクスチャパターンの最左端の１ライン、最下端
	の１ライン (u=255, v=255 のライン)を表示することができません。

	先ほどの例で、テクスチャページの右下端の 8x8 の部分を表示したい
	場合、

	ft4.u0 = 248, ft4.v0 = 248;
	ft4.u1 = 256, ft4.v1 = 248;
	ft4.u2 = 256, ft4.v2 = 256;
	ft4.u3 = 248, ft4.v3 = 256;

	と指定しなくてはなりませんが、(u,v) は、8bit の解像度しか持たな
	いため、
	
	ft4.u0 = 248, ft4.v0 = 248;
	ft4.u1 = 255, ft4.v1 = 248;
	ft4.u2 = 255, ft4.v2 = 255;
	ft4.u3 = 248, ft4.v3 = 255;

	と近似するしかありませんが、先ほどの例にもあるように(u=255, v=255)
	のラインは表示されません。この問題はポリゴンを２倍以上に拡大した場
	合に発生します。

	同様の問題がテクスチャを左右反転してマップした場合の最左端の１ラ
	イン (u=0 の１ライン）左右反転してマップした場合の最左端の１ライ
	ン、上下反転してマップした場合の最上端の１ライン (v=0 の１ライン）
	にもあてはまり、これらのラインを表示することはできません。

***対策
	(１）	
	問題がない限り、(u,v) に１引いた値を指定すれば、以上のすべての現
	象は回避されます。ただしこの時テクスチャパターンの右端および下端
	は表示されません。つまり、テクスチャパターンが、16x16 の場合は、
	16:15 に、8x8 の場合は 8:7 に拡大されて表示されます。
	またこの場合は、スプライトパターンを作成する時に注意が必要になり
	ます。
	
	（２）	
	正確に表示を行なう場合は、回転角度に応じて (u,v) を補正します。
	これは、単純なマクロ setUVWH() を例えば以下のような関数で置き換
	えます。
	
	SetUVWH(POLY_FT4 *ft4, int u0, int v0, int w, int h)
	{
	    int dx = ft4->x3 - ft4->x0;
	    int dy = ft4->y3 - ft4->y0;

	    if (dx < 0) {	/* X 方向に反転していたら u0 をずらす*/
		if (--u0 < 0)	/* u0 が負ならば、かわりに w を減らす。*/
			u0 = 0, w--;
	    }
	    if (dy < 0) {	/* Y 方向に反転していたら v0 をずらす*/
		if (--v0 < 0)	/* v0 が負ならば、かわりに h を減らす。*/
			v0 = 0, h--;
	    }
	
 	    if (u0+w > 255)	w--;	/* W, H の補正 */
	    if (u0+h > 255)	h--;

	    setUVWH(ft4, u0, v0, w, h);	/* 設定 */
	}

	BG のように矩形ポリゴンがメッシュにならんでいる場合は、各セルの
	回転条件が同じなので、プログラムは若干高速にできます。
	
	この方式でも残念ながらテクスチャページの境界上にならぶテクスチャ
	ピクセルは、表示されない場合があります。


** 描画処理速度評価ルール

	プレイステーションでの画像処理速度は、GPU による描画速度と
	CPU による演算速度のうち遅い方で決まります。アプリケーションの
	処理速度が、CPU と GPU のうちどちらで律速となっているかは、
	DrawSync() によってブロックされている時間によって知ることがで
	きます。CPU の方が遅い場合(CPU ネックの場合）は、DrawSync() は
	直ちにリターンします。逆の場合 (GPU ネックの場合）は、DrawSync()
	で待たされている時間分だけ GPU の描画速度がネックになっている
	と考えられます。ここでは、GPU の描画性能を決定するいくつかの要素
	について解説します。

	プレイステーションでは画像は一旦フレームバッファに描画されてか
	ら、ディスプレイに表示されます。フレームバッファへの描画は突き
	詰めていけば VRAM (Video RAM) へのリード／ライトアクセスの回数
	で置き換えられるので、描画性能は VRAM へのアクセス回数としてと
	らえることができます。

*** ライトアクセス
	
**** 基本ルール	
	VRAM へのライトアクセスは描画動作そのものになります。
	通常 GPU は 1pixel(16bit) を 1サイクルで描画します。

	ここで、100x100 正方形ポリゴンを描画する場合を考えます。
	４角ポリゴンは２連結３角形であることに注意して、
	
		総ライト	100x100 = 10000
		---------------------------------
		合計			  10000
	
	となります。	
	
**** 例外ルール
	
	ただし特別に TILE_*, POLY_F3, POLY_F4 は１サイクルで 2pixel
	描画できます。
	
	従ってこの例では

		10000/2 (write) = 5000 cycle
	
	で描画をおこないます。

*** リードアクセス
**** 基本ルール	

	VRAM へのリードアクセスはテクスチャパターンリードと半透明処理
	の際に使用されます。GPU は、リードの場合も 1pixel(16bit) を 1 
	サイクルで読み込みます。

	テクスチャマッピングを伴う描画の速度計算は非常に複雑ですが、
	単純には、テクスチャミスヒット時のアクセスは 1:1 のマッピング
	で考えます。

	ここで、100x100 の 4bit POLY_FT4 を描画する場合を考えます。

	１スキャンラインあたり：
	4bit モード時

	総リード	100/4    =  25
	総ライト	100      = 100
	--------------------------------
	合計		           125

	8bit モード時

	総リード	100/2    =  50
	総ライト	100      = 100
	--------------------------------
	合計		           150

	16bit モード時

	総リード	100      = 100
	総ライト	100      = 100
	--------------------------------
	合計		           200

	
	これらの違いは、1pixel に何個のテクスチャピクセルがパッキングされ
	ているかによります。

**** 例外ルール
	
	ただし特別に SPRT_*,は１サイクルで 2pixel のライトができます。
	
	従ってこの例では

	
	総リード	100/4    =  25
	総ライト	100/2    =  50
	--------------------------------
	合計		            75

	となります。
	
**** テクスチャサイズによる変動

	しかし、これはテクスチャマッピングが 1:1 の場合の例です。
	テクスチャを拡大したり縮小したりした場合では計算式が異なります。

	例えば、先ほどの例でも

	横方向テクスチャを等倍でマッピングした場合（4bit モード）
	
	総リード	100/4    =  25
	総ライト	100      = 100
	--------------------------------
	合計		           125

	横方向テクスチャを２倍に拡大した場合（4bit モード）

	総リード	100/4/2  =  12.5
	総ライト	100      = 100
	--------------------------------
	合計		           112.5

	横方向テクスチャを２倍に縮小した場合（4bit モード）

	総リード	100/4*2  =  50
	総ライト	100      = 100
	--------------------------------
	合計		           150


	のように、リードとライトのアクセス比率が異なります。
	定性的には、テクスチャを拡大する方向に使用した場合は、同じテク
	スチャピクセルを何回も使い回せるために、同じ面積を描画するため
	に必要なテクスチャリードが少なくてすむというように説明すること
	もできます。

**** テクスチャキャッシュによる変動

	以上の例はテクスチャキャッシュがすべてミスした場合のものです。
	GPU は内部にテクスチャキャッシュをもっており、キャッシュにヒッ
	トしたテクスチャはリードを行なうことなしに直接使用することができ
	ます。
	テクスチャキャッシュは以下のサイズをもちます。

		========================
		モード		サイズ
		------------------------
		 4bit		64x64
		 8bit		64x32
		16bit		32x32
		------------------------

*** 描画クリップ
	描画サイクルはどのような形でポリゴンがクリップされるかによって
	も異なります。
	ポリゴンの描画は、描画領域内でクリップされます。しかし、クリッ
	プの際、クリップされるポリゴンの左側／上側の部分については、
	空のサイクルが発生します。

			 ---------------
			|描画範囲	|
			|		|
			|		|
		    ----+------		|
		    |A	|     |		|
		    |... -----+---------
		    |B	      |
		     ---------
		    描画ポリゴン

	この例では、A の部分は空サイクルが発生しますが、B の部分は発生し
	ません。空サイクルでは空のテクスチャリードサイクルも含まれます。


*** まとめ

	以上をまとめれば、描画性能については、

		a) ライト	2 cycle	(POLY_F*, SPRT)
				1 cycle (その他）
		b) リード	1 cycle

	の３つの計算ルールに加えてマージンとして

		c) オーバーヘッド 10%

	を加算すれば大体の描画サイクルを算出できます。
	これから計算すると
	
	========================================
	ポリゴン		サイクル数	
	----------------------------------------
	100x100 POLY_G4		11000 		
	100x100 POLY_F4		 5500		
	100x100 POLY_FT4(16bit)	22000			
	100x100 POLY_FT4( 8bit)	16500			
	100x100 POLY_FT4( 4bit)	13750			
	----------------------------------------

	また全体にいえるルールとして

	1) POLY_F* は POLY_G* より速い（最大２倍）
	2) SPRT は POLY_FT* より速い（最大２倍）
	3) 不透明 は 半透明 より速い（最大２倍）
	4) テクスチャは拡大して使用した方が速い
	
	およびクリップの空サイクルとテクスチャキャッシュから

	5) 大きなPOLY_FT* は分割した方が速い（その上歪まない）
	
	がいえます。特に 5) はかなり効果があります。

** テクスチャキャッシュ構成に関して

	テクスチャマッピングを行なうポリゴンを描画する際には、フレーム
	バッファ上におかれたテクスチャパターンを一旦読み込まなければな
	らないため、その分のリードサイクル数に応じて描画速度が低下しま
	す。そのため、プレイステーションでは、内部にテクスチャキャッシュ
	を持ち、キャッシュヒットしているテクスチャパターンに対してはフ
	レームバッファへのリードアクセスを行なわずに描画を行なう機能を
	備えています。

	テクスチャキャッシュには、テクスチャモードに応じて最大以下のサ
	イズのの矩形領域を載せることができます。

			=====================
			mode	size
			---------------------
			4bit	64x64
			8bit	32x64
			16bit	32x32
			---------------------

	描画速度を大まかに評価する場合には、テクスチャキャッシュのサイ
	ズのみを注意してデータを作成するだけで十分です。
	
	しかし、より描画速度をチューンしたい場合には、さらに詳細なキャ
	ッシュの知識が必要になります。ここでは、テクスチャキャッシュの
	チューンを行なうパワーユーザのために、テクスチャキャッシュの詳
	細について説明します。

	なお、最終的に 描画（GPU）よりも計算（CPU）が、処理速度のボト
	ルネックになるアプリケーションや、テクスチャマッピングを多用し
	ないアプリケーションにおいては、このレベルまでの最適化は必要あ
	りません。

*** キャッシュブロック

	テクスチャページは、キャッシュサイズ単位の矩形領域に分割され管
	理されます。この各単位ををキャッシュブロックといいます。キャッ
	シュブロックには順番に番号（ブロック番号）がふられます。
	4bitモードの場合のキャッシュブロックとブロック番号は以下のよう
	になります。一つのキャッシュブロックは、64x64 でブロック数は 
	16 です。 

		 0       64    128   192  255
		  ┌──┬──┬──┬──┐
		  │0   │1   │2   │3	  │
		  │    │    │    │	  │
		64├──┼──┼──┼──┤
		  │4   │5   │6   │7	  │
		  │    │    │    │	  │
	       128├──┼──┼──┼──┤
		  │8   │9   │10  │11  │
		  │    │    │    │	  │
	       192├──┼──┼──┼──┤
		  │12  │13  │14  │15  │
		  │    │    │    │	  │
	       255└──┴──┴──┴──┘


*** キャッシュエントリ
	
	キャッシュブロックは、さらに、16x1 の小領域（キャッシュエント
	リ）に分けられます。4bit モードの場合は、以下のように 256 個の
	エントリに分けられることになります。
	

	 0		16	     32            48	       63
	┌──────┬──────┬──────┬──────┐
       0│0	      │1	    │2		  │3		│
	├──────┼──────┼──────┼──────┤
       1│4	      │5	    │6		  │7		│
	├──────┼──────┼──────┼──────┤


			

	├──────┼──────┼──────┼──────┤
      61│244	      │245	    │246	  │247		│
	├──────┼──────┼──────┼──────┤
      62│248	      │249	    │250	  │251		│
	├──────┼──────┼──────┼──────┤
      63│252	      │253	    │254	  │255		│
	└──────┴──────┴──────┴──────┘

	各エントリは以下の構造を持ちます。

	struct {
		u_char	block_id;	/* ブロック番号タグ */
		u_short	data[4];	/* テクスチャパターンデータ */	
	} Entry[256];

	キャッシュデータは、4 short word なので 4bitテクスチャの場合は、
	16 テクスチャピクセルが１エントリに格納されることになります。

*** キャッシュストラテジ
	
	各エントリには、ブロック番号が保持され、これを用いてキャッシュの
	ヒット／ミスを判定します。
	ここで、テクスチャマッピングに際して、テクスチャピクセル(u, v)
	がキャッシュに載っているかどうかの判定は、以下のように行なわれま
	す。

	(u,v) が属するブロック番号は、

		(v>>6)>>2 + (u>>6)

	で計算できます。また、(u,v) が属するエントリ番号は、

		(v&0x3f)<<2 + (u&0x3f)>>4

	で計算できます。これをふまえると、キャッシュヒット判定は

	is_cache_hit_4bit(u_char u, u_char v)
	{
		int block_id = (v>>6)>>2 + (u>>6);
		int entry_id = (v&0x3f)<<2 + (u&0x3f)>>4;

		if (Entry[entry_id].block_id == block_id)
			return(1);	/* キャッシュヒット */
		else
			return(0);	/* キャッシュミス */
	}
	

	のように記述できます。

	キャッシュエントリはそれぞれ個別にキャッシュブロック番号を保持
	しているため、エントリ番号が異なるテクスチャピクセルであれば、
	異なるブロック番号であってもキャッシュ上に共存できます。

	例えば、

		(u,v) = (0,0)-(63,63)
	
	の矩形領域内のテクスチャピクセルは全て同じテクスチャブロックに
	属するため、当然同時にキャッシュにのります。また、

		(u,v) = (16,16)-(79,79)

	の矩形領域内のテクスチャピクセルは複数のテクスチャブロックにま
	たがっていますが、重複するエントリがないため、同時にキャッシュ
	にのります。しかし、

		(u,v) = (8,8)-(71,71)

	の矩形領域内のテクスチャピクセルは、一部にエントリ番号が重複す
	るものがあるため、（(u,v) = (8,8)-(15,8) と、(u,v) = (64,8)-(71,8)
	の領域など）矩形領域自身は 64x64 の範囲に収まっているものの、
	同時にキャッシュにはのりません。

	また、連続した領域でなくても、それぞれのエントリが衝突していな
	い場合、例えば、

		(u,v) = ( 0, 0)-(15,15)
		(u,v) = (80,64)-(95,79)

	などは、同時にキャッシュにのることができます。

*** モードによる違い

	キャッシュブロック、キャッシュエントリのサイズは、テクスチャモー
	ドによって異なります。ただしエントリ数はいずれも 256 です。

	====================================================================
	モード	|ブロック	ブロック数	エントリ	エントリ数
	--------+-----------------------------------------------------------
	 4	| 64x64		16		16x1		256
	 8	| 32x64		32		 8x1		256
	16	| 32x32		64		 4x1		256
	--------------------------------------------------------------------

** PAL 方式への対応について

	現在の PlayStation アプリケーションは NTSC 方式のビデオ信号を
	想定して設計されており、これを PAL 方式の TV 受像機で再生する
	ためには、いくつかの変更が必要となります。

*** NTSC / PAL の違い

	NTSC/PAL では大きくは以下の２点が異なります。

	======================================================
				NTSC		PAL
	------------------------------------------------------
	フィールドレート	60Hz		50Hz
	標準垂直解像度		240		256
	------------------------------------------------------

	PAL 方式ではフィールドレートが 50 Hz であるため最大で 50 フレー
	ム／秒の表示までしかできません。また、垂直帰線割り込みも５０回／
	秒しか発生しませんので、プログラム内の同期を垂直帰線でおこなっ
	ている場合は、画面の移動速度が見ためが 5/6 に低下してみえるこ
	とになります。

	標準の TV 受像機で再生できる垂直解像度は、PAL の方が多くなりま
	す。このため、PAL 方式の TV でフルスクリーンの表示をする場合に
	は、フレームバッファ内の表示領域がより多く必要になります。
	逆に NTSC 方式と同じ表示領域を使用する場合は、PAL の TV 上では
	画面の上下が一部黒く表示されます。

*** PAL対応への変更

	NTSC 方式を仮定されて設計されたプログラムを PAL 方式に対応する
	には、以下の変更が必要です。

		a) SetVideoMode() 関数を使用して PAL モードにする
		b) 表示開始位置の調整
		c) 時間軸の調整
		d) 表示領域の調整

	このうち a),b) の変更は必須です。c),d) の処理はアプリケーション
	の必要度に応じて選択できます。

**** PAL モードの設定

	DTH-2000 の場合は、本体の DIP SW を変更した後、
	SetDispMode() 関数を使用して PAL モードにすることができます。

	#include <libetc.h>
	main()
	{
		SetVideoMode(MODE_PAL);
		.....
	}
	
	この状態で動作するプログラムは PAL 対応 PlayStation でも動作し
	ます。

**** 表示開始位置の調整

	標準の設定では、表示領域の垂直解像度は 240 本になっています。
	従ってこのままの状態で PAL の TV に表示すると表示領域が画面の
	上側にかたよって表示されます。そこで、DISPENV の screen 構造体
	のデフォルトの値を変更して、表示領域を画面の中央に合わせます。

	0		   255			0		   255
	┌─────────┐0			┌─────────┐0
	│		    │			├─────────┤8
	│     表示領域	    │			│      	    │
	│		    │		→	│    表示領域      │
	├─────────┤240		│		    │
	│		    │			├─────────┤248
	└─────────┘256		└─────────┘256

		DISPENV	disp;

		disp.screen.x = 0;	/* same as NTSC */
		disp.screen.y = 8;	/* (256-240)/2 */
		disp.screnn.w = 256;	/* same as NTSC */
		disp.screnn.h = 240;	/* same as NTSC */

		PutDispEnv(&disp);

**** 時間軸の調整

	PAL モードでは VSync 割り込みが 50 回／秒しか発生しません。
	プログラムによっては、プログラム内の時間管理を垂直同期割り込み
	(VSync()) を使用して行なっている場合が多いため、そのままの状態
	間軸を 6/5 倍する必要があります。


** フレームバッファの切替えタイミングに関して	

	PlayStation ではフレームバッファ上の表示領域の更新（ダブルバッ
	ファの交換など）はビデオのフレームレート(1/60 sec)と非同期に行
	なうことができます。しかし、1/60 sec の整数倍でない変則的なレー
	トで表示を切替えると、切替え時が垂直帰線同期区間に行なわれない
	ことになり、表示画面がちらつく現象が発生します。これは、ユーザ
	にアプリケーションの不良との誤解を与える原因になります。

	また、計算・描画の処理時間が瞬間的に期待されるフレーム切替え期
	間（フレームレート）を越えると、画像の動きが一瞬遅れて見える場
	合があります。これはコマ落ちなどと呼ばれ、一般には許容されてい
	る現象ですが、やはり一部のユーザには故障ととられる場合もあります。

	従って開発に際しては、フレームレートの管理に関して以下の点にご
	注意くださるようお願い申し上げます。

*** ダブルバッファ切替えの時期

	フレームダブルバッファの切替えを完全に行なうためには、通常の処
	切替えを垂直同期にあわせて行ないます。
	
	(A) では、バッファの切替えは描画・表示のいずれか処理の遅い方に
	のみ依存し、垂直同期とは非同期になりバッファの切替が表示期間に
	発生することになります。従って、意図して特殊な効果を狙う場合で
	なければ、バッファの交換時に VSync(0) を実行して同期をとるよう
	にして下さい。

	(A)				(B)		
	while (1) {			while (1) {
		....				....
		DrawSync(0);			DrawSync(0);
						VSync(0);
		swap_buffer();			swap_buffer();
		DrawOTag(ot);			DrawOTag(ot);
	}				}
	
*** フレームレートの固定

	しかし、切替えを強制的に垂直同期に同期させると、ちょうど 1/60
	sec 近辺で処理が終了する場合、フレームレートが 1/60 sec と 
	1/30 sec の間を頻繁に切り替わり物体の動きが不自然になります。
	これも、ユーザのクレームの原因になることがあります。

	こうした場合は、VSync(2) を使用してフレームレートを 1/30 sec
	に固定します。

	while (1) {
		.....
		DrawSync(0);
		VSync(2);	/* 1/30 sec に固定 */
		swap_buffer();
		DrawOTag(ot);
	}

	このように、事情の許す限り、フレームレートは、VSync(n) を使用
	して一定に保つようにします。同様に、フレームレートが２０コマの
	場合は、VSync(3) を １５コマの場合は、VSync(4)を使用することで
	フレームレートを固定に保つことができます。

*** 絶対時間の導入

	しかし、アプリケーションによっては最悪のフレームレートに全てを
	合わせることができないものもあります。例えば特定の瞬間だけフレ
	ームレートが落ちるだけの場合では、残りをすべて最悪のフレームレ
	ートに下げることは合理的ではありません。

	また、バッファの切替を固定の垂直同期に強制的に同期させると、ど
	うしても CPU/GPU が実質的な処理を行なわないアイドル期間が発生
	します。これを避けるために、フレーム間での画像の変化が小さいか、
	局所的である場合にはフレームバッファの切替えを垂直同期にあえて
	合わせないアプリケーションも考えられます。

	この場合は、プログラム内部の時計は、バッファの交換をカウントす
	るのではなく、VSync(-1) か、RCnt3 などの絶対的なカウンタを使用
	するようにして下さい。

	(A)				(B)		
	while (1) {			while (1) {
		....				....
		DrawSync(0);			DrawSync(0);
		VSync(0);			VSync(0);
		swap_buffer();			swap_buffer();
		frame++;			frame = VSync(-1);
		DrawOTag(ot);			DrawOTag(ot);
	}				}
	
	(B) のようなフレームカウンタの数え方をすれば、計算・描画がオー
	バーフローしてフレームレートが瞬間的に落ちても内部のカウンタが
	遅れることがありません。物体の位置の更新にこのカウンタを使用す
	れば、フレームレートが落ちた場合も物体の動きは自然なままに保た
	れます。

	逆に、絶対的なカウンタを元に物体の移動量やスクロール量を決定す
	れば、フレームレートを固定にする必要はないことになります。従っ
	て、この方法は、フレームレートを強制的に固定する方法よりも、よ
	り根本的な解決策と言えます。
	
	しかし、ダブルバッファの切替えとは独立にプログラムの状態を更新
	することを厳密に行なうと、どうしてもプログラムの負荷は大きくな
	ります。従って、いずれの方法を選択するかはアプリケーションの目
	的に応じて決定する必要があります。

*** 描画のキャンセル

	インターレースモードでは、計算・描画とも 1/60 sec で必ず完結し
	なくてはなりません。そのため、バッファの切替えは描画の終了
	(DrawSync(0)) よりも垂直同期を優先する必要があります。
		
	そのためには、VSync(0) に合わせて描画を途中でリセットするように
	します。一般に計算時間に比べて描画時間の方が変動が大きく予想が
	困難です。万一、大きな図形を描画する状態が発生して、描画時間が
	オーバーフローしても、描画を途中でリセットすることで、インター
	レースモード特有の画面の乱れをおさえることが出来ます。

	(A)				(B)		
	while (1) {			while (1) {
		....				....
		DrawSync(0);			VSync(0);
		VSync(0);			ResetGraph(1);
		swap_buffer();			swap_buffer();
		DrawOTag(ot);			DrawOTag(ot);
	}				}

	特に横幅が１６ドット以下の矩形のMoveImage()や、狭い幅のポリゴン
	描画は、ページブレークが多発するため、処理時間が変動しがちです。
	インターレースモード時にこうした処理を多く使用する場合は、バッ
	ファの切替が描画速度に依存しないようにする必要があります。




	
