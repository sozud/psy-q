$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
*グラフィクス基本ライブラリ (libgpu)

	グラフィクス基本ライブラリ (libgpu) は、プリミティブ（３角形・
	４角形・スプライト）などの基本単位図形を表示するための低レベル
	関数ライブラリです。
	
	ライブラリ関数には大きく分けて以下のものがあります。

	・システム関数
		グラフィックシステムのリセットなどグラフィックシステム
		全体の制御をするもの
	・フレームバッファアクセス関数
		フレームバッファの内容を直接読み書きするもの
	・プリミティブ関数
		プリミティブを初期化したり、テクスチャページを設定する
		などのプリミティブ構造体の内容を操作するもの
	・プリミティブ操作・オーダリングテーブル操作関数
		プリミティブをオーダリングテーブルに登録したり、オーダ
		リングテーブル上のプリミティブを描画するものなど
	・同期制御
		垂直同期や描画同期などの管理を行なうもの

*ライブラリファイル
	基本グラフィクスライブラリのファイル名は libgpu.lib です。
	各サービスを呼び出すプログラムは、必ずこれをリンクする必要があり
	ます。また libgpu.lib を使用する際には、libapi.lib libetc.lib を
	同時にリンクする必要があります。
	
*動作環境								
	基本グラフィクスライブラリのインクルードヘッダは、 libgpu.h で	
	す。各種のデータ構造、マクロはすべてこのファイルで定義されてい	
	ます。各サービスを呼び出すプログラムは、必ずこれをインクルード	
	する必要があります。						
	libgpu.h を使用する場合は、libetc.h, libgte.h を必ずインクルード
	して下さい。							
									
	例）								
									
	#include <sys/types.h>						
	#include <libetc.h>						
	#include <libgte.h>						
	#include <libgpu.h>						
									
	libgpu.h は、<sys/types.h> 内の以下の型を使用しています。	
	libgpu.h をインクルードする時は同時に <sys/types.h> もインクルー
	ドして下さい。詳細は、libgpu.h を参照下さい。			
									
		typedef	unsigned char	u_char;				
		typedef	unsigned short	u_short;			
		typedef	unsigned int	u_int;				
		typedef	unsigned long	u_long;				
									
* GPU									
	PlayStation では高速なグラフィック機能を実現するために、専用の	
	レンダリングエンジン（描画装置）を備えています。これを GPU	
	(Graphic Processing Unit) とよびます。				
	GPU は、フレームバッファタイプの描画装置で、メインメモリ上に配	
	置されたインストラクション列（プリミティブ）を次々に実行してフ	
	レームバッファ上に描画を行ないます。				
	フレームバッファ上のデータはビデオ信号に変換され、ディスプレイ	
	に表示されます。このフレームバッファの内容をディスプレイのフィ	
	ールドレート（60 フィール／秒）で次々に書き換えることで動きの	
	ある映像を生成します。						
									
	  ┌───┐  ┌───┐┌────┐				
	  │CPU	  │  │GPU   ├┤フレーム├──→ Video		
	  │	  │  │      ├┤バッファ│				
	  └─┬─┘  └─┬─┘└────┘				
	───┴─────┴───────────────────	
	───────┬─────────────────────	
		 ↓   │ ↑				メインバス	
	     命令作成 │ 命令実行					
	      ┌───┴───┐					
	      │┌─────┐│					
	      ││描画命令  ││					
	      ││          ││					
	      │└─────┘│メインメモリ				
	      └───────┘					
									
	このように、グラフィックシステムではすべての画像データを一旦フ	
	レームバッファ上描画したのちに描画をおこなうため、特定のＢＧ	
	（バックグラウンド）プレーンなどは持ちません。これらのデータ構	
	造はメインメモリ上のプリミティブ列をどのように設計するかに応じ	
	て全てアプリケーションに任されています。			
									
	なお、GPU とフレームバッファを総称してグラフィックシステムと呼	
	びます。							
									
*フレームバッファ	
**フレームバッファアドレッシング	
	フレームバッファとは、グラフィックシステムがローカルに持つ
	1024x512x16bit のビデオメモリを指します。。フレームバッファは、
	描画および、表示用のバッファであると同時に、テクスチャパターン
	やテクスチャCLUT の領域としても使用されます。
	
			        1024
	      ←───────────────────────→
	      ┌───────────────────────┐  ↑
	      │┌───────────┐   ┌──────┐ │  │
	      ││表示領域     		│   │テクスチャ  │ │  │
	      ││      		│   │パターン	   │ │  │
	      ││      		│   │ 	   │ │  │
	      │├───────────┤   │ 	   │ │  │512
	      ││描画領域     		│   └──────┘ │  │
	      ││      		│  ┌───────┐│  │
	      ││      		│  │テクスチャCLUT││  │
	      │└───────────┘  └───────┘│  │
	      └───────────────────────┘  ↓

	フレームバッファ上のピクセルは 左上を原点とする (X, Y)
	(X=0〜1023, Y=0〜511) の２次元座標で指定されます。
	各ピクセルは 16bit の深さをもち、RGB各5bitで以下のように構成さ
	れます。

	１５　１４　　　　　１０　９　　　　　　　５　４　　　　　　　０　
	┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
	│Ｓ│　　　　Ｂ　　　　│　　　　Ｇ　　　　│　　　　Ｒ　　　　│
	└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
	
	S:	半透明FLAG (STP)

	従ってフレームバッファの総容量は 1024 x 512 x 16 bit = 1MB と
	なります。

	フレームバッファの内容は、表示中の領域であってもいつでもアクセ
	スすることができます。また、描画中の領域であっても、いつでも表
	示可能です。

** 表示領域								
	ビデオ映像として表示されるのは、フレームバッファの一部分の矩形	
	領域になります。これを表示領域と呼びます。			
									
	表示領域の大きさは表示モードによって異なり、256x240		
	から、640x480 (オーバースキャン時709x488) まで以下の組合せから	
	選ぶことができます。						
									
	ただし、高さ 480 モードの場合でノンインターレースを選択するこ	
	とはできません。						
									
	===========================================================	
	幅		| 320	360	512	640			
	----------------+------------------------------------------	
	高さ		| 240	480					
	----------------+------------------------------------------	
	ピクセルモード	| 24bit	16bit					
	----------------+------------------------------------------	
	インターレース	| on	off					
	-----------------------------------------------------------	
									
	
** 描画領域
	
	描画は、フレームバッファの一部の矩形領域に対して行なわれます。
	これを描画領域と呼びます。描画領域は、フレームバッファに収まる
	範囲であれば、大きさの制限はありません。

**フレームダブルバッファ
	
	描画領域と表示領域は フレームバッファ 上のどこを指定しても構い
	ませんが、描画領域をそのまま表示領域とすると、現在描画している
	様子がそのまま画面に反映されてしまいます。
	
	そこで、通常は、別々の描画領域と表示領域を用意しておいて、片側
	の領域に描画をしている間はもう片側を表示し、描画が終了したら、二
	つをお互いに取り替える方式（ダブルバッファ）をとります。

	ダブルバッファの切替えは描画終了時に垂直同期にあわせて、次に述
	べる描画環境・表示環境を切替えることで行ないます。

**描画環境
	フレームバッファ内のどこに描画するか、描画の原点（オフセット）
	をどこに持つかなど、プリミティブの描画全般に関わる情報を描画環
	境と呼びます。描画環境は DRAWENV 構造体を用いて、PutDrawEnv()
	関数により設定できます。また、現在の描画環境は、GetDrawEnv() 
	関数で獲得できます。
	DRAWENV 構造体では以下のパラメータを設定できます。

	typedef struct {
		RECT	clip;		/* clip area */
		short	ofs[2];		/* drawing offset */
		RECT	tw;		/* texture window */
		u_short tpage;		/* texture page */	
		u_char	dtd;		/* dither flag (0:off, 1:on) */
		u_char	dfe;		/* flag to draw on display area */
		u_char	isbg;		/* enable to auto-clear */
		u_char	r0, g0, b0;	/* initital background color */
		DR_ENV	dr_env;		/* reserved */
	} DRAWENV;

***クリップ (clip.x, clip.y, clip.w,  clip.h)
	描画は、矩形領域 (clip.x, clip.y)-(clip.x+clip.w, clip.y+clip.h)
	内に制限されます。クリッピング領域外には描画は行なわれません。
	
***オフセット (ofs[0], ofs[1])
	描画は、(x,y) にオフセットメンバで指定されたオフセット
	(ofs[0], ofs[1]) が加算された値をアドレスとして、フレームバッファ
	に描画されます。
	
***テクスチャウィンドウ (tw.x, tw,y, tw,w, tw.h)
	テクスチャページ内のある部分だけをラップラウンドして使用する場合
	に使用します。
		
***テクスチャページ
	デフォルトで使用するテクスチャパターンを指定します。１テクスチャ
	ページは 256x256 の大きさをもちます。

***ディザ (dtd)
	これを 1 にすると、グラフィックシステムは、ピクセルを書き込む際に
	ディザ処理を行います。

***表示領域描画 (dfe)
	グラフィックシステムはデフォルトでは、表示中の領域への描画をブロッ
	クします。これを 1 にすると、表示中の領域であっても描画を行なうこと
	を許可します。

***描画領域クリア(isbg)、背景色(r0,g0,b0)
	これを１にすると、描画環境設定時にクリップエリアを輝度値 (r0,g0,b0)
	で一旦クリアします。

**表示環境								
	フレームバッファ内のどこを表示するかなどの、フレームバッファ	
	の表示に関わる情報を表示環境と呼びます。表示環境は DISPENV 構	
	造体を用いて PutDispEnv() 関数により設定できます。また、現在の	
	描画環境は、GetDispEnv() 関数で獲得できます。			
	表示環境では以下のパラメータを設定できます。			
									
	typedef struct {						
		RECT	disp;		/* display area */		
		RECT	screen;		/* display start point */	
		u_char	isinter;	/* interlace 0: off 1: on */	
		u_char	isrgb24;	/* RGB24 bit mode */		
		u_char	pad0, pad1;	/* reserved */			
	} DISPENV;							
									
	・表示領域（disp.x, disp,y, disp.w, disp.h)			
									
		フレームバッファ内で、					
		(disp.x, disp.y)-(disp.x+disp.w, disp.y+disp.h)	のエリアを
		表示エリアとします。表示エリアの幅は、256,320,360,512,640
		のいずれかになります。表示エリアの高さは240,480 のいずれか
		を指定します。						
									
	・画面領域（screen.x, screen,y, screen.w, screen.h)		
									
		表示領域を実際の物理ディスプレイ上のどの位置に表示す	
		るかを指定します。ディスプレイは表示エリア／表示モード	
		に関わらず左上を原点として(0,0)-(256,240)でアドレッシン	
		グされます。画面エリアを (0,0)-(256,240) で指定した場	
		合が標準の画面となります。これよりも小さい場合はアンダー
		スキャンとなり、大きい場合はオーバースキャンになります。
		例えば、screen.w に 256 以上の値を設定した場合は、320	
		モードであってもそれ以上のピクセルが画面に表示されます。
		ただしこの場合は、１ピクセルの大きさは変化しません。	
									
	・表示オフセット(ofs[0],ofs[1])					
		ディスプレイ上の表示の開始位置を指定します。横方向はピクセル
		単位・縦方向はラスタ単位です。				
									
	・インターレース(isinter)					
		表示を強制的にインターレースモードとします。ただし表示領域
		の高さが 240 を越えると、ここの指定に関わらず常にインターレ
		ースモードになります。					
									
	・24bit モード(isrgb24)						
		表示を 24bit モードにします。				
									
	表示領域と画面領域の関係を以下に示します。			
									
	フレームバッファ		ディスプレイ			
	0		       1023    0		   255		
         ┌───────────┐     ┌─────────┐		
         │(disp.x,y)            │     │(screen.x,y)      │		
         │ ┌────┐……………………→┌───────┐│		
         │ │表示領域│         │     ││      	  ││		
         │ │        │disp.h   │     ││      screen.h││		
         │ │        │         │     ││       	  ││		
         │ └────┘……………………→│	          ││		
         │    disp.w            │     │└───────┘│		
         │        	         │     │    screen.h	    │		
      511└───────────┘  255└─────────┘		
									

**表示・描画環境の切替え
	フレームダブルバッファは、表示・描画環境を２組用意しておき、そ
	れらを交互に切替えることで実現します。

	バッファ0 を (0,0)-(320,240), バッファ1 を (0,240)-(0,480) と
	とる場合は、それぞれの描画環境・表示環境は以下のように設定しま
	す。この二つは描画・表示バッファを取り替える際に交互に PutDrawEnv(),
	PutDispEnv() 関数を用いてシステムに設定します。

	================================================================
			|バッファ0	|バッファ１	|備考
	----------------+---------------+---------------+---------------
	・描画環境	|		|		|
	(clip.x,clip.y)	| (  0,  0)	| (  0,240)	|クリップ開始点
	(ofs[0],ofs[1])	| (  0,  0)	| (320,240)	|描画オフセット
	・表示環境	|		|		|
	(disp.x, disp.y	| (  0,240)	| (  0,  0)	|表示開始位置
	----------------------------------------------------------------
	
	描画環境は PutDrawEnv() を使用する以外にも、後述する DR_MODE 
	プリミティブを使用してオーダリングテーブルに組み込むことで、
	描画の途中で動的に切替えることができます。

	ダブルバッファのを使用した描画の基本的なプログラムの処理は以下
	のようになります。

	DRAWENVV drawenv[2];	/* 描画環境 */
	DISPENV	 dispenv[2];	/* 表示環境 */
	int	 dispid = 0;	/* ディスプレイバッファ ID */
	
	while (1) {
		VSync(0);		/* V-BLNK に同期をとる */
		dispid = (dispid+1)%2;	/* バッファ ID をスワップ */
		PutDispEnv(&drawenv[dispid]);
		PutDrawEnv(&drawenv[dispid]);
		/* プリミティブの設定・実行 */
	}

	描画環境・表示環境メンバの標準値は、SetDefDrawEnv(), SetDefDispEnv()
	関数で設定できます。

	なお、描画中に描画環境を設定する際は、その時実行されているプリミテ
	ィブあるいはプリミティブリストには影響を与えません。設定された
	描画環境は、その次の描画から有効になります。

	それに対して表示環境は描画中であっても即座に設定が有効になりま
	す。従ってバックグラウンドで描画を行なっている間でも表示位置や
	表示領域は変更することができます。

**インターレースダブルバッファ						
									
	高さ 480 のインターレースモードを使用した場合 (640x480など)では、
	シングルバッファで描画／表示を行なうことができます。		
									
	インターレースモードでは、偶数フィールドでは偶数ラインを、奇数	
	フィールドでは奇数ラインを交互に表示してしています。このとき、	
	偶数フィールドを表示中に奇数フィールドを描画し、奇数フィールドを
	表示中に偶数フィールドを描画すれば、表示／描画バッファを共通にする
	ことができます。						
	これは、描画環境の dfe フラグを 0 にしておくことにより実現できま
	す。すなわち 640x480 の共通バッファに 1/60 秒で描画を完了さえ	
	していれば、表示中のフィールド（この場合は、偶数ラインか奇数ラ	
	イン）には描画されないため、自動的にダブルバッファが実現します。
									
	この場合は、バッファの切替えごとに描画環境／表示環境を切替える	
	必要はありません。						
									
**フレームバッファアクセス関数	
	フレームバッファの内容は以下の関数を用いて直接アクセスすること
	ができます。

	=========================================================,
	関数名		転送元			転送先
	---------------------------------------------------------
	LoadImage()	メインメモリ		フレームバッファ
	StoreImage()	フレームバッファ	メインメモリへ
	MoveImage()	フレームバッファ	フレームバッファ
	---------------------------------------------------------

**ブロック関数とノンブロック関数	
	フレームバッファアクセス関数などのように処理時間の長い以下の
	関数、

	LoadImage(), StoreImage(), MoveImage(), DrawPrim(), DrawOTag()

	は、バックグラウンドで処理を実行しその終了を待たずにリターンし
	ます。（ノンブロック関数）。
	これに対して、グラフィックシステムが処理を終了するのを待って
	リターンするものをブロック関数とよびます。先にあげた関数以外は
	全てブロック関数です。

	ノンブロック関数の終了は DrawSync() で検出できます。
	ブロック型の LoadImage() を行ないたい場合は以下のようにします。

		LoadImage(&rect, pix);
		DrawSync(0);

	ノンブロック関数の実行は最大 64 個までキューイングできます。
	例えば、一回の描画で何本かのＯＴをまとめて走らせる場合
	
		DrawOTag(ot0);		/* 0 */
		DrawOTag(ot1);		/* 1 */
		DrawOTag(ot2);		/* 2 */
			.....

	DrawOTag(ot1) が呼ばれた時点で DrawOTag(ot0) が終了していない場合は、
	システムは、リクエストを単にキューに登録されるだけで、実際の処理を行
	なわずにリターンします。
	そして、DrawOTag(ot1) は、DrawOTag(ot0) の終了をまって自動的に実行さ
	れます。
	ただし、キューは 64個なため、65 個目のリクエストが来た時点で、そのリ
	クエストはキューが空くまでブロックされます。

		for (i = 0; i < 100; i++)
			LoadImage(....);

	の例では、65個目の LoadImage() は、最初の LoadImage() が完了して
	待ち行列がひとつ空くまでブロックされます。

*プリミティブ
	グラフィックシステムの扱う命令の最小単位をプリミティブ（パケッ
	ト）と呼びます。プリミティブは、メインメモリ内に作成され、ＣＰＵ
	と、グラフィックシステムで同時に参照されます。

	プリミティブには、実際にフレームバッファに図形を描画するための描
	画プリミティブと、グラフィックシステムの内部状態を変更するための
	特殊プリミティブとに分けられます。

	特殊プリミティブは、クリップ領域やテクスチャページなどのグラフィッ
	クシステムのパラメータを描画の途中で切替えるためのもので、直接フレ
	ームバッファの内容は変更しません。
	特殊プリミティブは通常のプリミティブと混在して後に述べるオーダリン
	グテーブルに登録することができます。

	これら、プリミティブは、DrawPrim(), DrawOTag() 関数によって実
	行することができます。
	プリミティブの描画の流れは以下のようになります。

	POLY_F3	f3;				/* 1) プリミティブ領域の確保 */
	SetPolyFT4(&f3);			/* 2) プリミティブの初期化 */
	setRGB0(&f3, 255, 0, 0);		/* 4) プリミティブメンバ設定 */
	setXY3(&f3, 0, 0, 0, 100, 100, 100);	
	
	if (直接実行)
		DrawPrim(&f3);	
	else if (オーダリングテーブルに一旦登録してから実行) {
		AddPrim(ot, &f3);			
		DrawOTag(ot);
	}
	
	
**描画プリミティブ	
	描画プリミティブには以下のものがあります。
	
***ポリゴンプリミティブ
	
	プリミティブにはシェーディングの種類に応じてグーローシェーディ
	ングプリミティブおよびフラットシェーディングプリミティブがあり
	ます。それぞれテクスチャマッピングの on/off を選択でき、さらに
	３角形あるいは４角形を選択できます。したがってポリゴンプリミティ
	ブはその組合せで以下のものからなります。
	
	============================================================
	プリミティブ名	内容
	------------------------------------------------------------
	POLY_F3		３角形ポリゴン、フラット
	POLY_FT3	３角形ポリゴン、フラットテクスチャ
	POLY_G3		３角形ポリゴン、グーロー
	POLY_GT3	３角形ポリゴン、グーローテクスチャ
	POLY_F4		４角形ポリゴン、フラット
	POLY_FT4	４角形ポリゴン、フラットテクスチャ
	POLY_G4		４角形ポリゴン、グーロー
	POLY_GT4	４角形ポリゴン、グーローテクスチャ
	------------------------------------------------------------

***ラインプリミティブ
	ラインプリミティブは、直線描画を実行するプリミティブです。

	============================================================
	プリミティブ名	内容
	------------------------------------------------------------
	LINE_F2 	非連結直線
	LINE_G2 	非連結直線、グラデーション付き
	LINE_F3		３点連結直線*2
	LINE_G3		３点連結直線、グラデーション付き*2
	LINE_F4		４点連結直線*2
	LINE_G4		４点連結直線、グラデーション付き*2
	------------------------------------------------------------
	
***スプライトプリミティブ						
	ここでのスプライトとは、矩形領域の描画命令を指し、等倍のテクスチ
	ャマッピングを伴うものと単色で描画するものとからなります。	
									
	============================================================	
	プリミティブ名	内容						
	------------------------------------------------------------	
	SPRT		スプライト（Free Size）				
	SPRT_8		スプライト（8x8)				
	SPRT_16		スプライト（16x16)				
	TILE		単色タイル (Free Size)				
	TILE_1		ドット (1x1)					
	TILE_8		単色タイル (8x8)				
	TILE_16		単色タイル (16x16)				
	------------------------------------------------------------	

**特殊プリミティブ							
	特殊プリミティブは、描画環境のすべてあるいは、その一部を描画の	
	途中で切替えるためのもので、以下のものがあります。		
									
	=====================================================================
	プリミティブ名	変更されるパラメータ		対応するDRAENVメンバ
	---------------------------------------------------------------------
	DR_ENV		描画環境を変更			全てのメンバ	
	DR_MODE 	描画・テクスチャモード		tpage, dtd, dfe, tw
	DR_TWIN;	テクスチャウィンドウ		tw		
	DR_AREA;	描画エリア			clip		
	DR_OFFSET;	描画オフセット			offset		
	---------------------------------------------------------------------
									
									

**プリミティブの表現形式
	プリミティブは、Ｃでは、構造体の形で定義されます。
	例えば、POLY_FT4（４角形ポリゴン、フラットテクスチャ）プリミティブ
	の定義は以下の通りです。

	typedef struct {
		PRIM	 *tag;
		u_char	r0, g0, b0, code;
		short	x0, 	y0;
		u_char	u0, v0;	u_short	clut;
		short	x1,	y1;
		u_char	u1, v1;	u_short	tpage;
		short	x2,	y2;
		u_char	u2, v2;	u_short	pad1;
		short	x3,	y3;
		u_char	u3, v3;	u_short	pad2;
	} POLY_FT4;		

	tag:			次のプリミティブへのポインタ（システム予約）
	code:			プリミティブ識別子（システム予約）
	r0,g0,b0:		表示色(R,G,B)
	tpage:			テクスチャページ ID
	clut:			CLUT ID
	x0,y0,....x3,y3:	ポリゴンの頂点座標
	u0,v0,....u3,v3:	ポリゴンのテクスチャ座標

	プリミティブは内部に次のプリミティブへのポインタ (tag) を持っ
	ており、これを用いて、リミティブ同士をリスト構造で表現し、まと
	めて複数のプリミティブを実行することもできます。

	構造体のメンバのなかで、最初の２ワードは全てのプリミティブで共
	通の構造で、以下のようなプリミティブ構造体で定義できます。
	
	typedef struct {
		u_long	tag;
		u_char	r0, g0, b0, code;
	} P_TAG;

**プリミティブの初期化
	プリミティブはメンバ内にプリミティブ識別子、次に実行するプリミテ
	ィブののポインタを持ちます。そのため、プリミティブは、最初ににプ
	リミティブ初期化関数で最初に初期化する必要があります。
	プリミティブを初期化する際には、プリミティブの型に対応した初期
	化関数を使用します。

	例えば、POLY_FT4（４角形ポリゴン、フラットテクスチャ）プリミティブ
	は最初に、以下のように初期化を行ないます。
	
		POLY_FT4 ft4;
		SetPolyFT4(&ft4);

**プリミティブ属性
	描画プリミティブには以下の半透明属性が設定できます。
	      SemiTrans:	半透明モード
	      ShadeTex:		テクスチャマッピングとシェーディングを同時
				に行なう機能を禁止する。		
	
	これらの属性は、SetSemiTrans() および、SetShadeTex() 関数でプリ
	ミティブごとに設定・解除できます。これらの関数はプリミティブの
	初期化を行なったあとであればいつでも設定・解除することができます。

	POLY_F4	f4;
	SetPolyF4(&f4);
	SetSeimiTrans(&f4, 1);	/* 半透明プリミティブにする */
	SetShadeTex(&f4, 1);	/* シェーディングを off にする */

**プリミティブのメンバの設定
	プリミティブメンバのうち、tag, code メンバ以外は自由に書き換え
	ることができます。この時、プリミティブメンバを設定するいくつか
	のマクロが用意されています。例えば、以下の a) と b) とは同じコ
	ードを生成します。詳細は、libgpu.h を参照下さい。

	a)
	POLY_F4 f4;
	SetPolyF4(&f4);				/* プリミティブを初期化 */
	setRGB0(&f4, 0, 0, 255);		/* R,G,B = 0,0,255 */
	setXY4(&f4, 0, 0, 100, 0, 0, 100, 100, 100);
	DrawPrim(&f4);				/* プリミティブ実行 */
	
	b)
	POLY_F4 f4;
	SetPolyF4(&f4);				/* プリミティブを初期化 */
	f4.r = 0, f4.g = 0, f4.b = 255;		/* = setRGB0() */
	f4.x0 =   0; f4.y0 =   0;		/* = setXY4() */
	f4.x1 = 100; f4.y1 =   0;
	f4.x2 =   0; f4.y2 = 100;
	f4.x3 = 100; f4.y3 = 100;
	DrawPrim(&f4);				/* プリミティブ実行 */
	
	マクロで実現されているものは先頭が小文字から始まっています。

**プリミティブの合成
	組み合わせて使用することが多い２つのプリミティブを合成して新しい
	一つのプリミティブを生成することができます。
	
	typedef struct {
		DR_MODE	mode;	/* モード設定プリミティブ */
		SPRT	sprt;	/* スプライト プリミティブ */
	} TSPRT;					

	setTSPRT(TSPRT *p)
	{
		SetDrawMode(&p->mode);
		SetSprt(&p->sprt);
		return(MargePrim(&tsprt->mode, &tsprt->sprt));
	}

	setTRPRT()は、新しい型 TSPRT を初期化する関数の例です。
	こうして初期化された TSPRT プリミティブは他のプリミティブと同
	様に AddPrim() や DrawPrim() の引数として使用できます。

**プリミティブの実行
	初期化されたプリミティブは DrawPrim() 関数で個別に実行できます。

		POLY_F4	f4;
		SetPolyF4(&f4);				
		setXY4(&f4, 0,0,100,0,0,100,100,100);	/*(0,0)-(100,100) */
		setRGB0(&f4, 0xff, 0x00, 0x00);		/* RGB = (255,0,0) */
		DrawPrim(&f4);				/* draw */

	しかし、通常は複数のプリミティブをあらかじめリストで接続して、
	（プリミティブリスト）DrawOTag() 関数でまとめて実行する方法をと
	ります。

**プリミティブの実行優先順位	
	描画プリミティブの実行順位は、そのままプリミティブの表示優先順位
	となります。すなわち、最初に実行されるプリミティブが一番奥に表
	示され、最後に実行されたプリミティブが一番手前に表示されます。

	for (i = 0; i < 100; i++)
		DrawPrim(&prim[i]);

	この例では、prim[0] が最も奥に、prim[99] が最も手前に表示され
	ます。
	この実行順序制御を容易に行なうためには、後に述べるオーダリング
	テーブルを使用する必要があります。

**プリミティブの描画規則
	
	プリミティブの描画で描画の対象になるピクセルは各頂点(x,y)を結ん
	だ領域（描画領域）の内部にピクセル中心があるピクセルです。辺上
	にピクセル中心がある場合の描画規則は以下のようになります。

	右側のピクセルが描画領域内に含まれる→描画される
	左側のピクセルが描画領域内に含まれる→描画されない
	
	上側のピクセルが描画領域内に含まれる→描画される
	下側のピクセルが描画領域内に含まれる→描画されない
	
	従って、POLY_* プリミティブの描画ルールでは、最右端点および
	最下端点は描画されません。すなわち４角形を描画した場合、
	
			描画される
			    ↓
		         ┏━━━  
		         ┃      │     	
	    描画される→ ┃      │→描画されない
			   ───┘
			     ↑
			描画されない

	というようになります。これは、ポリゴンを敷き詰めていった場合、
	ポリゴンの境界線上を２度書きしないようにする機能があります。

**プリミティブの描画速度						
									
	プリミティブの実行速度（描画速度）はプリミティブの面積とプリミ	
	ティブのタイプによって異なります。				
									
	プリミティブの描画は、実際にはフレームバッファを構成する VRAM	
	(ビデオ RAM) へのリード・ライトのアクセスの繰り返しからなりま	
	す。プリミティブの面積が大きいとそれに比例して VRAM のライトア	
	クセスが増大し、描画時間がかかります。				
									
	また、半透明描画ではリードのアクセスも必要となるため、同じプリミ
	ティブを不透明で描画する場合に比べて速度が半分程度に低下します。
									
	描画速度はプリミティブのタイプによっても異なります。		
	同じ描画面積のプリミティブの実行速度は以下の順番になります。	
									
	=============================================================	
	高速 ←						→ 低速		
	-------------------------------------------------------------	
	TILE								
	POLY_F3		POLY_G3						
	POLY_F4		POLY_G4						
			POLY_FT3(OnK)	POLY_FT3(OffK)			
			POLY_FT4(OnK)	POLY_FT4(OffK)			
			POLY_GT3(OnK)	POLY_GT3(OffK)			
			POLY_GT4(OnK)	POLY_GT4(OffK)			
	SPRT(OnK) SPRT(OffK)						
	-------------------------------------------------------------	
									
	OnK はテクスチャキャッシュがヒットしている状態、OffK はテクス	
	チャキャッシュがミスしている場合を指します。			

*オーダリングテーブル（ＯＴ）
	プリミティブは、描画に際して、一旦、オーダリングテーブル(OT)とよ
	ばれる実行キューに、AddPrim()/AddPrims() 関数によって登録された
	のち、DrawOTag() 関数によってまとめて実行することができます。
	ＯＴを使用した描画は、
	
	a) プリミティブの実行順序を容易に変更できる。
	b) DrawOTag() 関数がノンブロック関数であるので、ＣＰＵは、描画の
	   終了を待たずに、並行して次の処理を行なうことができる。

	などの利点を持ちます。

	ＯＴ は、メインメモリ内にとられたプリミティブへのポインタ配列で、
	大きさは表示優先順位の分解能によってきまります。例えば優先順位を
	256 通り持たせたい場合、OT は以下のように定義します。
	
		u_long *ot[256];					
	
	また、ＯＴは、最初に ClearOTag() 関数で初期化される必要があります。

		ClearOTag(ot, 256);

	ClearOTag() によってＯＴには、以下のようなリストが張られます。
	(EndOfPrim) はリストの終端を表します。
	
		ot[0] -> ot[1] ->  .....-> ot[255] -> (EndOfPrim)
	
**ＯＴへの登録
	ＯＴを用いて描画を行なう場合は、まず、一旦プリミティブをＯＴに
	登録します。プリミティブの登録には AddPrim() を使用します。

		AddPrim(ot+i, &prim);	/* = AddPrim(&ot[i], &prim);

	プリミティブの表示実行優先順位は、そのプリミティブがＯＴの何番
	目に登録されるかで決定されます。ＯＴの最初に登録されたプリミティ
	ブが最初に実行されＯＴの最後に登録されたプリミティブが最後に実行
	されます。
	
		u_long	ot[256];	/* OT (256 エントリ) */
	
		ClearOTag(ot, 256);	/* OT の初期化 */
		AddPrim(&ot[0],   p1);	/* ot[0] にプリミティブ p1 を登録 */
		AddPrim(&ot[255], p2);	/* ot[255] にプリミティブ p1 を登録 */
		DrawOTag(ot);		/* OT 上のプリミティブを実行 */

	この例では、p1 が最初に実行され、画面の一番奥に表示されます。
	また、p2 が最後に実行されるため、一番手前に表示されます。
	この時、実際にプリミティブの実行が開始されるのは、AddPrim() を
	実行時した時ではなく、DrawOTag() をコールした時点であることに
	ご注意下さい。

	同じＯＴのエントリに複数のプリミティブを登録することもできます。
	この場合は、後に登録されたプリミティブから順に実行されます。
	
		AddPrim(ot+2, p0);	/* ot[2] に登録 */
		AddPrim(ot+3, p1);	/* ot[3] に登録 */
		AddPrim(ot+3, p2);	/* ot[3] に登録 */
		AddPrim(ot+3, p3);	/* ot[3] に登録 */
		AddPrim(ot+4, p4);	/* ot[4] に登録 */
	
	では、プリミティブは、p0, p3, p2, p1, p4 の順番で実行されます。

**特殊プリミティブの登録	
	特殊プリミティブは、描画環境のすべてあるいは、その一部を描画の
	途中で切替えるためのもので、以下のものがあります。

	特殊プリミティブも一旦ＯＴに登録されたのち、DrawOTag() 関数でま
	とめて実行されます。

	特殊プリミティブの有効範囲は、登録されたテーブルの位置に依存し
	ます。
		AddPrim(&ot[  0], p1);	/* 描画プリミティブ p1 を登録 */
		AddPrim(&ot[128], env);	/* 特殊プリミティブ env を登録 */
		AddPrim(&ot[255], p2);  /* 描画プリミティブ p2 を登録 */
		DrawOTag(ot);
	
	では、env プリミティブの設定は、ot[128] 以降に登録されたプリ
	ミティブの実行に対して有効です。この例では、p2 が env プリミ
	ティブの影響を受けます。

** プリミティブリンク							
	ＯＴはタグ(tag) だけをもつヌルプリミティブとも考えることができ	
	ます。従ってＯＴを介さずに、直接プリミティブ同士を接続して、そ	
	の後、DrawOTag 関数でまとめて実行する方法もあります。		
									
	例えば以下は、DrawPrim() と同じ働きをします。			
									
	myDrawPrim(void *p)						
	{								
		TermPrim(p);						
		DrawOTag(p);						
	}								
									
	これは、16 個のプリミティブからなるプリミティブリストを作成し	
	描画する例です。						
									
	drawSprites(SPRT *p, int n)					
	{								
		int i;							
		for (i = 0; i < n-1; i++, p++)				
			CatPrim(p, p+1);				
		TermPrim(p);						
		DrawOTag(p);						
	}								
									

*ＯＴとＺソート
	Ｚソート法は表示したいプリミティブをその奥行き座標（Ｚ座標）の
	値で並び替え、遠くに表示したいプリミティブから順に描画すること
	で、隠面除去を行なう方法です。
	
	ＯＴは、上位アドレス側に登録されたプリミティブを先に、下位アド
	レス側のプリミティブを後から実行するため、登録するＯＴの位置を
	プリミティブのＺから適切に計算すれば、ＯＴを用いてＺソートを実
	現することができます。
	例えば、
		u_long	*ot[256];
		....
		AddPrim(ot+256-z0, p0);
		....
	の様にプリミティブ p0 のＺ座標 z0 に応じて登録するＯＴの位置を
	計算すれば、ＯＴ上には遠方のプリミティブから順に並んだリストが
	形成されます。

**ジオメトリ関数とＯＴ
	ジオメトリ関数の多くは、３次元座標値を計算する際にＺソートのた
	めに、ＯＴへのエントリも計算します。例えば、

		SVECTOR	x3, x2;
		long	flag, otz;
		otz = RotTransPers(&x3, (long *)&x2, &flg);
	
	RotTransPers()	関数は、３次元座標値 SVECTOR x3 をカレントマト
	リクスで座標変換・透視変換を行ない、結果の２次元座標を x2 に格
	納しますが、同時に otz と呼ばれるＯＴへのインデクスを戻します。
	otz は座標変換した後のＺ座標を 1/4 倍したものでこのままＯＴへ
	のインデクスの計算に使用できます。

	ここで、otz は座標変換した後のＺ座標を 1/4 倍しているために、
	実際のＺのダイナミックレンジの 1/4 の大きさのＯＴを用意してお
	くことで足ります。
	この otz を活用することで３ＤのＺソートを高速に行なうことがで
	きます。

**逆方向ＯＴ
	otz はプリミティブが遠方にあるほど大きい値をとり、近くほど０に
	近づきます。このため otz を ＯＴのインデクストして使用する際に
	は、一旦 otz の符号を反転する必要があります。
	そのためにあらかじめＯＴの実行順位が逆方向になるようにＯＴを初
	期化する関数 ClearOTagR() が用意されています。
	通常の ClearOTag() 関数は

	ClearOTag(ot, OTSIZE);
	ot[0]->ot[1]->ot[2]->.....ot[OTSIZE-1];

	の順番で実行されるようにＯＴが初期化されますが、ClearOTagR()の
場合は、
	
	ClearOTagR(ot, OTSIZE);
	ot[OTSIZE-1]->ot[OTSIZE-2]->ot[OTSIZE-3]->.....ot[0];

	の順番で実行されるようにＯＴが初期化されます。

	ClearOTagR() を使用して初期化したＯＴは、otz をそのままインデ
	クスとして使用できます。

	===================================================================
	ClearOTag() を使用した場合	|	ClearOTagR() を使用した場合
	--------------------------------+-----------------------------------
	#define OTSIZE	1024		|	#define OTSIZE	1024
	u_long	*ot[OTSIZE];		|	u_long	*ot[OTSIZE];
	.....				|	.....
	ClearOTag(ot, OTSIZE);		|	ClearOTagR(ot,OTSIZE);
	.....				|	.....
	AddPrim(ot+OTSIZE-otz, &prim);	|	AddPrim(ot+otz,&prim);
	.....				|	.....
	DrawOTag(ot);			|	DrawOTag(ot+OTSIZE-1);
	--------------------------------------------------------------------

	このように、逆順 OT の場合、DrawOTag() 関数にわたすＯＴの先頭
	ポインタのアドレスも変わりますのでご注意下さい。
	
	一般に順ＯＴ は２次元のアプリケーション、逆順ＯＴ は３次元のア
	プリケーションで使用されます。そのため、逆順ＯＴのほうが通常エ
	ントリ数（配列のサイズ）が大きくなります。そのため大きなＯＴを
	クリアする場合は逆順ＯＴのクリアのほうが高速になっています。

	
*ジオメトリ関数との組合せ						
									
	３次元の情報を持った物体を表示するためには、物体（オブジェクト）
	を囲む曲面を３角形／４角形の集まりに分解して、各３／４角形（ポ	
	リゴン）ごとに座標計算を行ない、対応するプリミティブの位置を決	
	定します。すなわち、３Ｄの計算はオブジェクトを構成するポリゴン	
	の３次元座標からフレームバッファ上のプリミティブの位置、すなわ	
	ちプリミティブの (x,y) メンバを獲得する作業になります。		
	この座標変換はジオメトリライブラリが行ないます。		
									
	オブジェクトの移動／回転、視点の移動／回転は最終的には一つの回	
	転マトリクスと移動ベクトルで記述できます。従って、オブジェクト	
	を構成するポリゴンの各頂点は、以下の式で記述されます。		
									
	(Wx,Wy,Wz)   : ワールド座標での座標位置				
	(Sx,Sy,Sz)   : スクリーン座標での座標位置			
	(m00,,,,m22) : 回転マトリクス					
	(Tx,Ty,Tz)   : 移動ベクトル					
									
		┌  ┐	┌           ┐  ┌  ┐  ┌  ┐			
		│Sx│	│m00 m01 m02│	 │Wx│  │Tx│			
		│Sy│＝│m10 m11 m12│×│Wy│＋│Ty│			
		│Sz│	│m20 m21 m22│  │Wz│  │Tz│			
		└  ┘	└           ┘	 └  ┘  └  ┘			
									
	あるいは、							
		→       →    →					
		Ｓ = Ｍ×Ｗ ＋ Ｔ					
									
	実際に描画される図形はこれを２次元平面（スクリーン）に投影した	
	ものになります。スクリーンは視点からある距離 h に立てられた仮	
	想平面でここへの変換を透視変換と呼びます。			
									
		┌   ┐  ┌       ┐					
		│ x │  │h*Sx/Sz│					
		│ y │= │h*Sy/Sz│					
		│otz│  │Sz/4   │					
		└   ┘  └       ┘					
									
	ここで計算された (x,y) がプリミティブの (x,y) メンバとなり、	
	otz がＯＴへのエントリとなります。以下の作業を行なう関数の例を	
	示します。							
									
	rotTransPersAddPrim(pos, s, ot, ot_size)			
	SVECTOR	*pos;		/* position */				
	SPRT	*s;		/* Sprite primitive */			
	u_long	*ot;		/* OT */				
	int	ot_size;	/* size of OT */			
	{								
		long otz, dmy, flg;					
									
		otz = RotTransPers(&pp->x[0], (long *)&sp->x0, &dmy, &flg);
									
		if (otz > 0 && otz < ot_size)				
			AddPrim(ot+otz, sp);				
	}								
									
	詳細は libgte のドキュメントを参照下さい。			
									
* 複数ＯＴ								
									
	ＯＴ自体は単なるリンクの張られたヌルプリミティブの配列であるため、
	ＯＴを親ＯＴの１エントリとして登録することができます。		
	これは複数の階層座標系を行なう場合に有効になります。		
									
	これは、ot0 に長さ n のサブＯＴ ot1 を接続する例です。		
									
	AddOT(u_long *ot0, u_long *ot1, int n)				
	{								
		AddPrims(ot0, ot1, ot1+n-1);				
	}								
									
									
*パケットダブルバッファ							
	ＯＴとプリミティブ領域を総称してパケットバッファと呼びます。	
									
	描画を行なう際に、ＯＴへプリミティブを登録を待ってＯＴの描画を	
	行なう場合、ＣＰＵとグラフィックシステムが並列に動作しなくなり	
	ます。								
									
	        ┬───────┬───────┬───────┬─	
	CPU	│ＯＴ登録     	│	-     	│ＯＴ登録     	│	
		┴───────┴───────┴───────┴─	
				↓				↓	
	        ┬───────┬───────┬───────┬─	
	GPU	│	-     	│ＯＴ描画     	│	-	│	
		┴───────┴───────┴───────┴─	
									
	そのため、グラフィックシステムと CPU を並列に動作させる場合は、	
	通常、二つのパケットバッファ、設定パケットバッファと実行パケッ	
	トバッファを用意しておき、片側のバッファに描画をしている間はも	
	う片側を実行し、実行が終了したら、二つバッファをお互いに取り替	
	える方式をとります。これをパケットダブルバッファと呼びます。	
									
	        ┬───────┬───────┬───────┬─	
	CPU	│ＯＴ#0登録   	│ＯＴ#1登録   	│ＯＴ#0登録   	│	
		┴───────┴───────┴───────┴─	
		↓		↓		↓		↓	
	        ┬───────┬───────┬───────┬─	
	GPU	│ＯＴ#1描画   	│ＯＴ#0描画   	│ＯＴ#1描画 	│	
		┴───────┴───────┴───────┴─	
									
									
	パケットダブルバッファの例を以下にあげます。			
									
	typedef struct {						
		u_long	ot[256];	/* ＯＴ */			
		SPRT	sprt[256];	/* スプライトプリミティブ */	
	} DB;								
									
	main() {							
	    int j;							
	    DB	db[2], *cdb;						
									
	    while (1) {							
		cdb = (cdb==db)? db+1: db;	/* バッファを交換 */	
		ClearOTag(cdb->ot);		/* ＯＴをクリア */	
		for (j = 0; j < 256; j++) {	/* スプライトを登録 */	
			/* ここでスプライトの位置を計算する */		
			AddPrim(cdb->ot, cdb->sprt[j]);			
		}							
		DrawOTag(cdb->ot);		/* 描画 */		
	    }								
	}								
									
	このようにパケットダブルバッファを行なう際にはＯＴ・プリミティ	
	ブ共に２組必要なことになります。				

* 同期とリセット	
	現在バックグラウンドで行なわれている処理の終了を検出するには、
	ポーリングによる方法と、後に述べるコールバックを使用する方法が
	あります。

	関数 DrawSync(0) は、キューに残っている全てのリクエストが終了す
	るまで処理をブロックします。また、 DrawSync(1)は、キューの状態
	および実行状態の検出のみをおこないます。

	グラフィックシステムのリセットには、カレントのリクエストを途中終
	了させて、キューもフラッシュするもの、カレントのリクエストのみ
	を途中終了するものなど何レベルかのリセットモードがあります。
	これは、ResetGraph() 関数の引数で制御できます。
	
**コールバック								
	垂直同期や、描画の終了時によばれる関数（コールバック）を定義す	
	ることで、バックグラウンド処理の終了を検出する方法もあります。	
	グラフィックライブラリでは、２つのコールバック関数 VSyncCallback(),
	DrawSyncCallback() が用意されて	います。			
									
		================================			
		関数名			トリガ				
		--------------------------------			
		VSyncCallback()		垂直同期			
		DrawSyncCallback()	描画終了			
		================================			
									
	VSyncCallback() では垂直同期の開始時で呼ばれる関数を指定し	
	ます。								
									
	main() {							
		/* 初期化ルーチンがここにはいる */			
									
		VSyncCallback(1, callback);	/* コールバックを定義 */
		callback();			/* リターンしてはいけない */
	}								
	callback() {							
		/* フレーム内で行なう処理がここにはいる */		
									
		while (1);			/* リターンしてはいけない */
	}								
									

*テクスチャマッピング
	ポリゴン／スプライトを描画する際に、テクスチャページにおかれたパ
	ターンを使用してテクスチャマッピングを行なうことができます。
	テクスチャマッピングとは、テクスチャパターンと呼ばれる２次元画像
	の一部を切りとって、３角形・４角形の表面に変形しながら張り付ける
	ものです。

	テクスチャパターンは、通常フレームバッファの表示領域・描画領域以
	外に 256x256のテクスチャピクセル単位に配置されます。これをテクス
	チャページと呼びます。
	テクスチャパターンのピクセルフォーマットとしては 4、8、16bit の３
	種類のモードがあります。各モードはプリミティブ単位で切替えること
	ができます。
	
			=========================
			モード	| タイプ |色数
			--------+--------+-------
			4bit 	| pseudo | 16
			8bit 	| pseudo | 256
			16bit 	| direct | 32767
			-------------------------	
	
	テクスチャマッピングを使用する場合は、使用するテクスチャページと、
	各頂点に対応するテクスチャページ内のオフセット値、および必要が
	あればテクスチャ CLUT を指定することで行なわれます。
	
	テクスチャページ内でのオフセットはフレームバッファ内の座標値
	(x,y)と区別するために、通常 (u,v) のシンボルを使用します。
	
**テクスチャパターンフォーマット
	4bit,8bit,16bit のテクスチャパターンのうち、16bit モード以外のパタ
	ーンは１ワード内に何個かのピクセルがパックされた形で、フレーム
	バッファ上に配置されます。従ってテクスチャパターンのピクセル(u,v)と
	フレームバッファのアドレス(x,y)は１対１に対応しません。
	
	そのため、フレームバッファにテクスチャパターンをロードする場合
	のサイズの指定には注意が必要です。
	
	各モードの場合のピクセルフォーマットは以下の通りです。

	4bit モード (pseudo color)
	１５　　　　１２　１１　　　　８　７　　　　　４　３　　　　　０　
	┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
	│　　ｐｉｘ３　│　　ｐｉｘ２　│　　ｐｉｘ１　│　　ｐｉｘ０　│
	└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
	
	8bit モード (pseudo color)
	１５　　　　　　　　　　　　　８　７　　　　　　　　　　　　　０　
	┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
	│　　　　　　ｐｉｘ１　　　　　│　　　　　　ｐｉｘ０　　　　　│
	└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
	
	16bit モード (direct color)
	１５　１４　　　　　１０　９　　　　　　　５　４　　　　　　　０　
	┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
	│Ｓ│　　　　Ｂ　　　　│　　　　Ｇ　　　　│　　　　Ｒ　　　　│
	└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
	
	Ｓ：STP ビット

	4bitモード, 8bitモードの場合、ピクセル値は実際の輝度値ではなく、
	CLUT へのインデックスとなります。
	CLUT のピクセルパターンフォーマットは 16bitモードのフォーマッ
	ト（後述）と同様です。

**透明ピクセル／半透明ピクセル
	テクスチャマッピングを行なう際に、ピクセルごとに透明、不透明、半透
	明を選択することができます。

	テクスチャパターンのピクセル値（4/8bit モードの場合は、対応する
	CLUT の値）が 0x0000 の場合 (STP=R=G=B=0) にのみそのピクセルは透明
	となり、描画されません。これを透明ピクセルといいます。
	これ以外のピクセル、すなわち STP=1 あるいは R,G,B いずれかが非
	零のピクセルはすべて非透明ピクセルとなります。
	
	SetSemiTrans() 関数で半透明モードにしたプリミティブは、非透明
	ピクセルのうち、STP が 1 のピクセルのみが半透明になります。

	================================================================
		     (STP,R,G,B)|(0,0,0,0)|(1,0,0,0)|(0,n,n,n)|(1,n,n,n)
	------------------------+---------+---------+---------+---------
	不透明プリミティブ	|透明     |黒       |不透明   |不透明
	半透明プリミティブ	|透明     |半透明黒 |不透明   |半透明
 	----------------------------------------------------------------
	
	STP は 4bit, 8bit モードの場合は CLUT 内の各エントリ内の最上位 bit
	です。16bitモードの場合、テクスチャソースパターンの輝度値の最上位
	bit が STP になります。

	テクスチャマッピングを行なわない描画（フラット／グーロープリミ
	ティブ）などで、SetSemiTrans() を用いて半透明モードにした場合は、
	そのプリミティブを構成するピクセルがすべてが半透明になります。

**半透明ピクセルのモード
	半透明プリミティブはプリミティブ単位でその割合を指定できます。
	指定できる半透明レートには以下のものがあります。

		===================================
		背景輝度値	プリミティブ輝度値
		-----------------------------------
		0.5		 0.5
		1.0		 1.0
		1.0		-1.0
		1.0		 0.25
		-----------------------------------
	半透明処理をした結果の輝度値が(0-255) の範囲を越える場合はその
	範囲でクリップされます。
	
	各半透明レートは、後述するカレントテクスチャページのものが使用
	されます。テクスチャマッピングを行なわないプリミティブに関しても
	同じレートが適用されます。
	
**テクスチャマッププリミティブの輝度値
	テクスチャマッピングを行なうプリミティブの場合、ポリゴン内部の各ピク
	セルは、対応するテクスチャパターンの輝度値にプリミティブの (r,g,b)
	メンバで指定された輝度値が乗算されて実際の輝度値となります。

	描画される輝度値は、対応するテクスチャパターンのピクセル値Ｔと対応す
	る輝度値Ｌから、以下のように計算されます。
	
			P = (T*L)/128

	すなわち、(r,g,b) フィールドにそれぞれ0x80(=128) を設定した場合、
	もとのテクスチャの輝度値がそのまま描画されることになります。

	そのため、テクスチャマッププリミティブを初期化する際には必ず r,g,b
	メンバも指定するか、SetShadeTex() 関数でこの機能を禁止する必要があ
	ります。
	
	POLY_FT4 ft4;
	SetPolyFT4(&f4);			/* プリミティブを初期化 */
	setRGB0(&fT4, 0x80, 0x80, 0x80);	/* 輝度値を初期化 */
		
**テクスチャページ
	テクスチャページはフレームバッファ上のどこを指定しても構いませ
	んが、ページ右上点アドレスは x は 64pixel, y は、256 ピクセル
	の整数倍に限られます。
	一枚のテクスチャページには、256x256 ピクセルのテクスチャパター
	ンが置かれます。テクスチャページのフレームバッファ上で占める領
	域のサイズは、モードによって256x256(16bit モード) から、64x256
	(4bit モード) まで異なります。
	
	プリミティブにテクスチャページを指定する時は、実際のページアドレス
	(x,y) ではなく、テクスチャページID を使用します。これは GetTPage()
	関数で獲得できます。
	
**テクスチャ CLUT
	4bit/8bit モードのテクスチャマッピングを行なう場合は、使用する
	テクスチャCLUT を指定する必要があります。テクスチャ CLUT は使
	用するテクスチャページに関わらず、プリミティブ毎に独立に設定で
	きます。
	CLUTは、フレームバッファ上の、1x256 (8bit モード）あるいは、
	1x16 (4bit モード）の横に細長い形で配置されます。
	プリミティブに CLUT を指定する時は実際の CLUT アドレス(x,y) ではな
	く、テクスチャ CLUT ID を使用します。これは GetClut()関数で獲得でき
	ます。
	
**テクスチャページ ID とテクスチャ CLUT ID
	使用するテクスチャページ・テクスチャ CLUT は、プリミティブの
	tpage、clut メンバに、テクスチャページ ID、テクスチャ CLUT ID
	を与えることで指定します。

	POLY_FT4 ft4;
	
	SetPolyFT4(&ft4);			/* プリミティブを初期化 */
	ft4.tpage = GetTPage(0, 0, 640, 0);	/* テクスチャページ=(640,0) */
	ft4.clut  = GetClut(0, 480);		/* テクスチャ CLUT=(0,480) */

	/* (x, y)=(0,0)-(256,256) の領域にテクスチャページ内のテクスチャ
	 * パターン (u,v)=(0,0)-(128,128) をテクスチャマップする 
	 */
	setXY4(&ft4, 0, 0, 256, 0, 0, 256, 256, 256);
	setUV4(&ft4, 0, 0, 128, 0, 0, 128, 128, 128);

	DrawPrim(&ft4);				/* プリミティブの実行 */

	テクスチャページ・テクスチャ CLUT はあらかじめフレームバッファ
	に LoadImage() を用いてロードしておく必要があります。
	LoadTPage(), LoadClut() はテクスチャページ・テクスチャ CLUT を
	ロードして適切なテクスチャページ ID, テクスチャ CLUT ID を返し
	ます。

**カレントテクスチャページ
	スプライトプリミティブ(SPRT)は、tpage メンバを持たないため、スプ
	ライトが実行される時点で最後に使用されたテクスチャページ（カレ
	ントテクスチャページ）が使用されることになります。
	描画の最初のカレントテクスチャページは描画環境で指定できます。
	スプライトプリミティブでテクスチャページを明示的に変更したい場
	合は、特殊プリミティブ DR_MODE を使用します。これは、カレント
	のテクスチャページ・モードを切替えるものです。

	DR_MODE	dr_mode;	/* モードプリミティブ */
	SPRT16	sprt;		/* 16x16 スプライトプリミティブ */
	
	SetDrawMode(&dr_mode, 0, 0, GetTPage(2, 0, 640, 0), 0, 0);
	SetSprt16(&sprt);
	setXY0(&sprt, 100, 100);

	ClearOTag(ot, 2);
	AddPrim(ot+1, &sprt);		/* ot[1] に SPRT16 を登録 */
	AddPrim(ot+1, &dr_mode);	/* ot[1] に DR_MODE を登録 */
	DrawOTag(ot);

	同じＯＴのエントリでは、後から登録されたプリミティブから実行さ
	れることにご注意下さい。

**テクスチャパターンの繰り返し
	テクスチャページ内のある部分だけにテクスチャウィンドウを設定し、
	その間で、テクスチャパターンをラップラウンド（折り返し）して使用
	することができます。
	通常は、テクスチャウィンドウは (0,0)-(255,255)を使用します。
	
	テクスチャウィンドウの設定は描画環境の設定時に行なうか、DR_MODE
	プリミティブを使用します。

	u_short	tws[2], twe[2];	
	DR_MODE	dr_mode;	/* 描画モードプリミティブ */
	tws[0] = tws[1] = 32;	/* テクスチャウィンドウ (32,32)-(64,64) */
	tws[0] = tws[1] = 64;
	
	/* 描画モードプリミティブの初期化 */
	SetDrawMode(&dr_mode, 0, 0, GetTPage(0, 0, 640, 0), tws, twe);
	.....

	AddPrim(ot+n, &dr_mode);

*デバッグ環境
**デバッグモード
	デバッグモードが指定されると各関数は可能な限りデータの整合性を
	チェックします。問題があればリターンコードと、後述するデバッグ
	ストリングに内容をプリントします。
	
**デバッグストリング
	関数 SetGraphDebug() でデバッグモードを指定した場合、あるいは、
	Dump*() 関数を用いて構造体の内容を出力した場合、出力文字列は
	一旦指定された文字列バッファに貯められます。
	デバッグ文字列は Fnt*() 関数を使用してスクリーンに表示できます。

**高レベルライブラリインターフェース
	libgpu のレベルではある特定のデータ構造やパラダイムになるべく
	依存しないような形式がとられています。そのために、３次元オブ
	ジェクトのデータ構造である TMD フォーマットや、２次元画像に関
	するデータ構造である TIM フォーマットなどを直接ハンドルする関
	数は用意されていません。それらを使用するには、統合的な環境であ
	る拡張グラフィクスライブラリ(libgs) 内の関数を使用する必要があ
	ります。
	
	しかし、高レベルライブラリと低レベルライブラリ間のインターフェー
	スおよび、データ自体のデバッグのために TMD データ TIM データの内
	容の解析のみを行なう関数 OpenTMD()/ReadTMD()、OpenTIM()/ReadTIM()
	が用意されています。
	ReadTIM() 関数は TIM データの任意番目の TIM 形式画像データのヘッ
	ダ情報を可能な限り解釈します。
	ReadTMD() 関数は、TMD データの任意番目のオブジェクト内の任意番
	目のポリゴンデータの情報を可能な限り解釈します。

	


