$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
概要
*セクタ
	CD-ROM 上には CD オーディオディスクと同様に、スパイラル状にディ
	ジタルデータが記録されています。
	このディジタルデータは、セクタと呼ばれる処理単位で管理されます。
	１秒分のデジタルデータ領域は 75 個のセクタに分割されます。
	各セクタはどのような目的で使用されるかによって以下のようなセクタ
	タイプに分けられます。

	==========================================================
	セクタタイプ		格納データ
	----------------------------------------------------------
	オーディオセクタ	CD-DA オーディオデータ
	ADPCM セクタ		ADPCM 圧縮オーディオセクタ
	データセクタ		ユーザデータセクタ
	----------------------------------------------------------
	

**オーディオセクタ
	オーディオセクタには fs = 44.1kHz ディジタルステレオオーディオ
	データ（通常の CD オーディオデータ）が記録されています。オーデ
	ィオセクタは、CdlPlay コマンドで再生させることができます。これを
	ユーザデータとして読み込むことはできません。
	
**データセクタ
	データセクタにはユーザデータが記録されています。データセクタの実
	効ユーザエリアはモードによって若干異なりまが、標準は 2048 バイト
	が使用されます。（mode-1 フォーマット）

**ADPCM セクタ
	正式には、リアルタイムセクタ、mode-2 form-2 セクタと呼ばれるセ
	クタを指します。
	ここには、ADPCM 圧縮音声データが格納されています。これはオーデ
	ィオセクタ同様に音声として再生することができます。
	
**インターリーブ
	ADPCM セクタには、通常音声データをオーディオセクタのデータと比べ
	て 1/4 に圧縮されて記録されています。CD-ROM がセクタごとにシーク
	を行なわないで ADPCM 再生するためには、ADPCMセクタを４セクタおき
	にディスク上に配置する必要があります。
	これをインターリーブとよびます。ADPCM セクタをインターリーブす
	ることで、余ったセクタには他のデータを記録しておくことが可能と
	なり、データを読み込みながらオーディオを再生することができます。
	
	なお、ディスクを標準の２倍（倍速）で再生する場合はインターリー
	ブ間隔は、８セクタおきでなくてはなりません。
	
*アドレッシング	
	CD-ROM のアドレッシング（位置指定）は、CDオーディオとの互換性
	からトラック番号・インデクス番号・分・秒・セクタを用いて行なわ
	れます。すなわち CD-ROM データをオーディオデータとして見た時の
	トラック番号・インデクス番号、あるいは、ディスクの先頭から数え
	てその地点が何分何秒何セクタであるかで位置を確定します。
	1秒は 75 セクタ, 1分は 60 秒からなります。先頭セクタは、00分02
	秒00セクタから始まります。

**トラック	
	ディスクには各トラックの先頭にトラック信号が記録され、さらにトラ
	ック信号の位置のテーブルがディスクの先頭に TOC (Table Of Contents)
	として記録されています。オーディオセクタの再生開始位置は TOC とト
	ラック信号を用いて検出することができます。

**絶対セクタ	
	データセクタは、分・秒・セクタでアドレシングされますが、位置計
	算を容易にするために先頭（00分02秒00セクタ）からの総セクタ数で
	数える指定方法もあります。これを絶対セクタ指定と呼びます。絶対
	セクタは分・秒・セクタの値から容易に計算できます。これを行なう
	ためのCdIntToPos(),CdPosToInt() 関数が用意されています。

**ファイルシステム
	これら低レベルのアドレシング手段の他にも、9660 ファイルシステム
	を通じてディスクの絶対値を取得する方法があります。
	ただし、これはディスクが IS0-9660ファイルシステムフォーマットで
	記録されている場合に限ります。
	CD-ROM はリードオンリのため、ディスク上のファイルは全て連続した
	セクタ領域になるように配置しておくことができます。従ってファイ
	ルを読み出すためにはそのファイルの先頭位置を確定するだけで良く、
	通常の FAT (File Allocation Table) に相当するものは必要ありま
	せん。ライブラリでは、ファイル名をインデクスとしてファイルの先
	頭ポジションを検索する関数 CdSearchFile() が用意されています。

*転送レート
	CD-ROM はディスクを標準速度・倍速度のいずれかで回転できます。
	標準速は、通常の CD プレイヤと同じ回転数で、倍速はその２倍にな
	ります。ディスクの回転が速いほどデータ転送速度は上がります。

	CD-ROM の転送レートは、標準速度・倍速度の場合に応じてそれぞれ、
	150KB/sec 300KB/sec になります。これは１秒間に標準速で 75セク
	タ、倍速で 150 セクタのデータが読めることを表します。

**セクタバッファ
	CD-ROM の転送速度はホストシステムのバス速度 (132MB/sec) に比べ
	て極めて遅いため、CD-ROM システムは内部にセクタバッファと呼ば
	れる１セクタ分のローカルメモリを内部に持っており、CD-ROM から
	のデータは、一旦セクタバッファに格納されてから、まとめて転送さ
	れます。従って CD-ROM からの転送は

		      CD-ROM	
			↓		CdRead()
		   セクタバッファ
			↓		CdGetSector()
		    メインメモリ	
			↓
		     各デバイス

	のような手順を踏むことになります。
	
*サウンド制御	
	CD-ROM サブシステムからは右（Ｒ）と左（Ｒ）２チャンネルのオー
	ディオ信号が出力されています。ここには、CDオーディオ、および、
	ADPCM オーディオが出力されます。これらは、一旦 SPU に入力され、
	続いて SPU 内の音源からの信号と加算合成されて最終的なサウンド
	として出力されます。CD-ROM からのオーディオ出力は 4 個のアッテ
	ネータ（減衰器）によって制御されます。
									+
		CD (L) → ATV0 → SPU (L)				+
		CD (L) → ATV1 → SPU (R)				+
		CD (R) → ATV2 → SPU (R)				+
		CD (R) → ATV3 → SPU (L)				+
	
	アッテネータの制御は、CdMix() 関数を通じて、CdlATV 構造体を用
	いて指定します。

*プリミティブコマンド
	
CD-ROM に対する最も低レベルの操作は、CD-ROM サブシステムに直接コマンド
を発行することで行ないます。各コマンドの発行には CdControl()関数を使用
します。CdControl() 関数は以下の引数を持ちます。

	CdControl(com, param, result)
	u_char	com;		/* コマンドコード */
	u_char	*param;		/* コマンド引数設定アドレス */
	u_char	*result;	/* コマンドの返り値格納アドレス */

例えば、CdControl() を使用して CD を1分00秒から再生する場合は、
以下のように、CdlPlay プリミティブコマンド(コード 0x03）を発行します。
	
#includ <libcd.h>

	CdlLOC	pos;
	u_char	result[8];

	pos.minute = 0x01;	/* 1 min */
	pos.second = 0x00;	/* 0 sec */
	pos.sector = 0x00;	/* 0 sector (void) */
	pos.track  = 0x00;	/* void */
	
	CdControl(CdlPlay, &pos, result);
	
param, result の内容、ビットアサインはコマンドごとに異なります。
CdControl() 関数で定義される低レベルコマンドをプリミティブコマンドと呼
びます。プリミティブコマンドには、それぞれ対応するコマンドコードが以下
のように割り当てられています。

--------------------------------------------------------------------------
シンボル	コード	タイプ	内容
--------------------------------------------------------------------------
CdlNop		0x01	B	NOP (No Operation)
CdlSetloc	0x02	B	シークのターゲット位置を設定
CdlPlay		0x03	B	CD-DA 演奏買開始
CdlForward	0x04	B	早送り
CdlBackword	0x05	B	巻き戻し
CdlReadN	0x06	B	データリード開始（リトライつき）
CdlStanby	0x07	N	ディスクを回転させた状態で待機
CdlStop		0x08	N	ディスクの回転を停止
CdlPause	0x09	N	現在位置で一時停止
CdlMute		0x0b	B	CD-DA ミュート
CdlDemute	0x0c	B	ミュート解除
CdlSetfilter	0x0d	B	再生 ADPCM セクタを選択
CdlSetmode	0x0e	B	基本モード設定
CdlGetlocL	0x10	B	論理位置獲得（データセクタ）
CdlGetlocP	0x11	B	物理位置獲得（オーディオセクタ）
CdlSeekL	0x15	N	論理シーク（データセクタシーク）
CdlSeekP	0x16	N	物理シーク（オーディオセクタシーク）
CdlReadS	0x1b	B	データリード開始（リトライなし）
--------------------------------------------------------------------------
 			B: Blocking, N: Non-Blocking operation

プリミティブコマンドは処理の終了を待ってリターンするブロックコマンド、
終了をまたずにリターンするノンブロックコマンドの２つのタイプがあります。

** コマンド引数

プリミティブコマンドのうち以下のものはパラメータと呼ばれる引数のリスト
が必要になります。
コマンドの引数は以下の通りです。
	
--------------------------------------------------------------------------
シンボル	|パラメータタイプ	|内容
----------------+-----------------------+---------------------------------
CdlSetloc	|CdlLOC	*		|開始セクタ位置
CdlReadN	|CdlLOC	*		|開始セクタ位置
CdlReadS	|CdlLOC	*		|開始セクタ位置
CdlPlay		|CdlLOC	* 		|開始セクタ位置
CdlSetfilter	|CdlFILTER *		|再生 ADPCM セクタ指定
CdlSetmode	|u_char *		|基本モード指定
--------------------------------------------------------------------------

これ以外のコマンドは引数は必要ありません。引数の必要ないコマンドには、
引数ポインタに NULL (0) を指定します。

CdlLOC はディスクの位置を表現するもので、以下の構造をもちます。
	
	struct {
		u_char minute;		/* セクタ位置（分）*/
		u_char second;		/* セクタ位置（秒）*/
		u_char sector;		/* セクタ位置（セクタ）*/
		u_char track;		/* reserved */
	} CDlLOC;

このうち、minute,second,sector メンバは BCD と呼ばれる形式で指定されま
す。BCD は 10進数表示の各桁をそれぞれ 4bit ごとのフィールドに割り当て
たものです。

CdlFILTER 構造体はマルチチャネル ADPCM の再生チャネルを特定するために
使用するもので、以下の構造を持ちます。

	struct {
		u_char	file;		/* 再生 file ID */
		u_char	chan;		/* 再生 channel ID */
		u_short	pad;
	} CdlFILTER;
	
** コマンド返り値

一方、プリミティブコマンドは、コマンド実行後に常に８バイトの返り値を返
します。返り値の意味はコマンドごとに異なります。返り値の内容は以下の通
りです。

==============================================================================
シンボル	返り値
		0	1	2	3	4	5	6	7
------------------------------------------------------------------------------
CdlNop		status	
CdlSetloc	status	
CdlPlay		status
CdlForward	status
CdlBackword	status
CdlReadN	status
CdlStanby	status
CdlStop		status
CdlPause	status
CdlMute		status
CdlDemute	status
CdlSetfilter	status
CdlSetmode	status
CdlGetlocL	min    	sec   	sector  mode  	file 	chan
CdlGetlocP	track  	index 	min	sec 	frame 	amin 	asec 	aframe
CdlSeekL	status
CdlSeekP	status
CdlReadS	status
CdlReset	status
-------------------------------------------------------------------------------

返り値が status の１バイトだけのコマンドであっても返り値を格納するバッ
ファ領域は、８バイト分必要になります。
また、返り値の引数に NULL (0) を指定する返り値の設定が抑制されます。
すなわち、
	
	CdlLOC	pos;
	CdControl(CdlSeekL, &pos, 0);

の例では、CdlSeekL の返り値は設定されずに関数はリターンします。

** ステータス

ほとんどのコマンドでは、返り値の最初の１バイトは CD-ROM のステータスを
表します。ステータスバイトのビットアサインは以下の通りです。ステータス
だけを獲得したい場合は CdlNop コマンドを使用します。

==========================================================================
シンボル	コード	内容						
--------------------------------------------------------------------------
CdlStatPlay	 0x80	1: CD-DA 再生中
CdlStatSeek	 0x40	1: シーク中
CdlStatRead	 0x20	1: データセクタ読み込み中			
CdlStatShellOpen 0x10	1: 蓋（シェル）が開いている
CdlStatSeekError 0x04	1: シーク・リード中にエラー発生
CdlStatStandby	 0x02	1: モータ回転中
CdlStatError	 0x01	1: コマンド発行エラー
--------------------------------------------------------------------------

** コマンド概要	
*** CdlNop
	何もしません。ステータスを獲得するために使用します。
	
*** CdlSetloc
	ターゲットポジションを設定します。これは位置の設定のみを行ない、
	実際の動作は行なわれません。ここで設定したターゲットポジション
	は次に CdlPlay, CdlReadN, CdlReadS, CdlSeekP, CdlSeekL を実行
	する時に使用されます。
	
*** CdlPlay
	ターゲットポジションへ CD-ROM のヘッドをシークしてからCD-DA の
	再生を開始します。ターゲットポジションは、引数で設定します。引
	数に NULL を指定すると直前の CdlSetloc, CdlSeekP で指定された値
	が使用されます。
	
*** CdlReadS/CdlReadN
	ターゲットポジションへ CD-ROM のヘッドをシークしてからデータセク
	タの内容を読み出して、ローカルバッファへ転送します。
	ターゲットポジションは、引数で設定します。引数に NULL を指定する
	と直前の CdlSetloc, CdlSeekL で指定された値が使用されます。
	
	CdlReadS は、エラー発生の際にリトライしません。これは主にストリー
	ミング再生などのリアルタイム読み込みに使用されます。
	CdlReadN はリードエラーが発生した場合可能な限り（最大８秒）リトラ
	イをおこないます。
	
*** CdlSeekL/CdlSeekP
	ターゲットポジションへ CD-ROM のヘッドをシークしてからポーズ状
	態で待機します。CD-ROM はハードディスクなどと異なりシーク時間
	が長いため、目的のアドレスがあらかじめ確定している場合は、前も
	ってヘッドをターゲットポジションへ移動しておくことでアクセスを高
	速にすることができます。
	
	CdlSeekL は、データセクタへの論理シークを行ないます。データセク
	タの先頭にはセクタアドレスが記録されており、それを使用して正確な
	シークが可能です。これを論理シークと呼びます。論理シークはデー
	タセクタに対してのみ有効です。
	これに対してセクタヘッダを持たないオーディオセクタに対してはサブ
	コードを使用したシーク（物理シーク）を行なわれます。物理シークは
	正確さに欠けるもののあらゆるタイプのセクタに対して有効です。

	===============================================================
	コマンド	シーク方法	精度	使用可能セクタ
	---------------------------------------------------------------
	CdlSeekL	論理シーク	高い	オーディオセクタ以外	
	CdlSeekP	物理シーク	低い	全てのセクタ
	---------------------------------------------------------------

*** CdlForward/CdlBackword
	オーディオセクタを再生中に早送り・巻き戻しを開始します。

*** CdlStandby/CdlStop/CdlPause
	CdlStandby は、スピンドルモータを回転させた状態で待機します。
	CdlStop は、スピンドルモータを停止させます。ストップ状態にあ
	るよりも、スタンバイ状態にある方が次のシーク・リード・プレイへ
	遷移を高速に行なうことができます。
	CdlPause は、リード・プレイを一時停止し、スタンバイ状態でヘッドを
	停止位置で待機させます。
	
*** CdlMute/CdlDemute
	CD-DA, ADPCM 再生をミュート（消音）・ミュート解除を行ないます。

*** CdlSetfilter
	マルチチャネル ADPCM の再生チャネルを指定します。再生できるチャ
	ネルはファイル番号とチャネル番号の２つでインデクスされます。デ
	フォルトのファイル番号・チャネル番号は、(1,1) です。

*** CdlSetMode
	CD-ROM の基本的な動作モードを設定します。
	モードの設定は、以下のビットの論理和をとった１バイトをCdlSetMode
	コマンドを用いて設定することで行ないます。また、現在のモード
	は、CdlGetlocL コマンドで獲得できます。

==========================================================================
シンボル	コード	内容
--------------------------------------------------------------------------
CdlModeSpeed	0x80	転送速度	0: 標準速	1: 倍速
CdlModeRT	0x40	ADPCM 再生	0: ADPCM OFF	1: ADPCM ON
CdlModeSize1	0x20	セクタサイズ	0: 2048 byte	1: 2340byte
CdlModeSize0	0x10	セクタサイズ	0: -		1: 2328byte
CdlModeSF	0x08	ADPCM フィルタ	0: OFF		1: ON
CdlModeRept  	0x04	レポートモード	0: off		1: ON	
CdlModeAP	0x02	オートポーズ	0: off		1: ON
CdlModeDA	0x01	CD-DA 再生	0: CD-DA off	1: CD-DA on	
--------------------------------------------------------------------------
	
*** CdlGetlocL
	データセクタをリード／ADPCM 再生中の現在ポジションを獲得します。
	獲得されるパラメータには以下のものがあります。
	CdlGetlocL は、オーディオセクタ再生中には動作しません。

	===========================================================
	result		内容
	-----------------------------------------------------------
	0		分    (BCD)
	1		秒    (BCD)
	2		セクタ(BCD)
	3		モード（CdlSetMode コマンド参照）
	4		ファイル番号（CdlSetFileter コマンド参照）
	5		チャネル番号（CdlSetFileter コマンド参照）
	-----------------------------------------------------------
	
*** CdlGetLocP
	現在リード／プレイ中のセクタ物理アドレスを獲得します。
	獲得されるパラメータには以下のものがあります。
	CdlGetlocP は、サブコードアドレスを獲得するためオーディオセク
	タを含む全てのセクタタイプに対して有効に動作します。

	===========================================================
	result		内容
	-----------------------------------------------------------
	0		トラック番号	  (BCD)
	1		インデックス番号  (BCD)	
	2		トラック相対分	  (BCD)
	3		トラック相対秒	  (BCD)
	4		トラック相対セクタ(BCD)
	5		絶対分		  (BCD)
	6		絶対秒		  (BCD)
	7		絶対セクタ	  (BCD)
	-----------------------------------------------------------

	トラック相対分・秒・セクタは、そのトラックの先頭位置からのオフ
	セット値を表します。絶対分・秒・セクタは、先頭トラックからの位
	置を表します。
	
	
* コマンド同期
	プリミティブコマンドのうち、処理時間のかかるものは実際の処理の
	終了を待たずにリターンします。これらのコマンドをノンブロックコ
	マンド（非同期コマンド）と呼びます。これに対して処理の終了を待っ
	てリターンするものをブロックコマンド（同期コマンド）と呼びます。
	ノンブロックコマンドは、CdControl() 関数がリターンした後もバッ
	クグラウンドで処理を続行します。その間ホストシステムは並列して
	他の処理を行なうことができます。

	ノンブロックコマンドの実際の処理の終了は CdSync() 関数を使用す
	るか後述するコールバック関数を使用します。以下の例は全てのコマ
	ンドの終了までブロックする関数です。
	
	CdControlB(u_char com, u_char *param, u_char *result)
	{
		/* コマンドの発行 */
		if (CdControl(com. param, result) == 0)
			return(0);
	
		/* コマンドが終了するまでブロックする */
		if (CdSync(0, result) == CdlComplete)
			return(1);
		else
			return(0);
	}

	なおノンブロックコマンドを発行した際の CdControl() 関数の返り値
	は一時的なものであり、最終的なステータスは CdSync() 関数の返り値
	かコールバック関数に渡される引数で確定します。
	
** コマンドの実行状態
	プリミティブコマンドは以下の処理状態をもちます。
	
		======================================
		処理状態	内容	
		--------------------------------------
		CdlNoIntr	コマンド実行中
		CdlComplete	実行終了・待機中
		CdlDiskError	エラー発生
		--------------------------------------

	コマンドが発行されると実行状態は CdlComplete から CdlNoIntr へ
	移行します。コマンドが正常終了して次のコマンドが受け付けられる
	状態になると CdlComplete 状態へ移行します。実行時にエラーが検
	出されると CdlDiskError 状態になります。

	ブロックコマンド・ノンブロックコマンドは、関数のリターン時の処理
	状態によっても定義できます。ブロックコマンドではコマンド発行後
	CdlComplete/CdlDiskError 状態になるのを待ってリターンするのに対し
	てノンブロックコマンドは、CdlNoIntr のままリターンします。
	
	これらのコマンド実行状態は CdSync() 関数のリターン値で獲得できます。
	
	CdSync(mode, result)
	u_char	mode;		/* モード 0:ブロック 1:ノンブロック */
	u_char	*result;	/* コマンドの返り値格納アドレス */
	
	mode 引数によってブロックモード／ノンブロックモードが選択さ
	れます。

	============================================================
	mode	内容
	------------------------------------------------------------
	0	実行状態が CdlNoIntr 以外に移行するまでリターンしない
	1	実行状態にかかわらずに直ちにリターンする
	------------------------------------------------------------
	
	従って以下のコードは同じ結果になります。

	a)	CdControl(CdlSeekL, (u_char *)pos, 0);
		CdSync(0, result);
	
	b)	CdControl(CdlSeekL, (u_char *)pos, 0);
		while (CdSync(1, result) != CdlNoIntr);

	なお、CdSync() の返り値 (result) は実行状態が CdlComplete/
	CdlDiskError になった時点で始めて確定します。
	
	処理状態が CdlNoIntr の場合、次のコマンドは受け付けられません。
	コマンドの実行はキューイングされないため、新しいコマンドは前の
	コマンドが終了し、実行状態が CdlNoIntr に移行するのを待って実行
	されます。従って以下のコードは同じ結果になります。

	a)	CdControl(CdlSeekP, (u_char *)pos, 0);
		CdControl(CdlPlay, 0, result);
	
	b)	CdControl(CdlSeekP, (u_char *)pos, 0);
		CdSync(0, 0);
		CdControl(CdlPlay, 0, result);

	a), b) の例ともシークの間は処理がブロックされます。これを避け
	るためには、直接位置指定をして CdlPlay を発行するか、コールバッ
	ク関数内で CdlPlay を起動するようにします。

		/* シークの間ブロックされる */
		CdControl(CdlSeekP, (u_char *)pos, 0);
		CdControl(CdlPlay, 0, result);
	
		/* シークの間ブロックされない。*/
		CdControl(CdlPlay, (u_char *)pos, result);

** コマンド同期コールバック
	コマンド実行状態が CdlNoIntr から CdlComplete/CdlDiskError
	に移行する際に呼ばれる関数（コールバック関数）を登録すること
	ができます。
	コールバックの登録には CdSyncCallback() 関数を使用します。
	コールバック関数には以下の形式の引数が渡されます。

	callback(u_char intr, u_char *result)
	u_char	intr;	/* その時点の実行状態 */
	u_char	*result;/* その時点で最新の返り値  */
	
	以下にコールバックを使用した例をあげます。
	
	main() {
		void	callback();
		CdlLOC	pos;
			....

		/* コールバック関数 callback() を登録 */
		CdSyncCallback(callback);
			....
	
		/* コマンド発行 */
		CdControl(CdlSeekP, (u_char *)&pos, 0);
	}
	
	/* コマンド終了時に以下の関数が呼ばれる */
	void callback(u_char intr, u_char *result)
	{	
		if (intr == CdlComplete)
			CdControl(CdlPlay, 0, 0);
	}

* データリード
	CD-ROM は、倍速モードでもデータ転送速度が 300KB/sec とメインバ
	ス転送速度に比べて非常に遅いために、内部にセクタデータバッファ
	を持ち、セクタ単位にまとめてデータを読み出せるようになっていま
	す。
	データセクタ読みだしコマンド (CdlReadN/CdlReadS) が発行される
	と、CD-ROM サブシステムはセクタデータを読みだし、一旦セクタバ
	ッファ上にデータを展開します。セクタバッファに展開されたデータ
	の内容は次のセクタのデータが新しく上書きされるまで有効です。
	セクタバッファ上に確定したデータは、CdGetSector() 関数を使用し
	て高速にメインメモリに転送することができます。
	
** リトライリードとノーリトライリード
	データリードには、読み込み時にエラーが発生した時にセクタ単位で
	リトライをかけるタイプ(CdlReadN) と、エラーを報告するだけでリト
	ライを行なわないタイプ(CdlReadS)があります。
	CdlReadN を使用した読み込みは読み出されたデータが正しいことが保
	証されますが、エラー発生時に一旦前に戻って再度セクタの読み込み
	（リトライ）を行なうために、ADPCM の再生と同時に使用できません。
	また、ストリーミングのように、データの品質よりも転送レートを一
	定に保ちたい場合にも適切ではありません。こうした場合には、エラー
	発生時にもリトライを行なわない CdReadS を使用します。

	===========================================================
	リードコマンド	リトライ	エラー検出
	-----------------------------------------------------------
	CdlReadN	あり		あり
	CdlReadS	なし		あり
	-----------------------------------------------------------

** セクタレディ同期	
	セクタバッファにデータが用意されたかどうかは、CdReady() 関数に
	よって検出できます。

	CdReady(mode, result)
	u_char	mode;		/* モード 0:ブロック 1:ノンブロック */
	u_char	*result;	/* 最近のコマンド返り値 */
	
	CdReady() 関数は以下のセクタバッファの状態を返します。

		======================================
		処理状態	内容	
		--------------------------------------
		CdlNoIntr	準備中
		CdlDataReady	データ準備完了
		CdlDiskError	エラー発生
		--------------------------------------
	
	セクタバッファ上にデータが確定すると状態は CdlNoIntr から
	CdlDataReady/CdlDiskError 状態に移行します。CdReady() の mode 
	引数に 0 を指定した場合は、状態が CdlNoIntr から移行するまで処
	理をブロックします。
	また、CdRady() 関数が一旦 CdDataReady/CdDiskError を返すと状態は
	CdNoIntrに戻ります。

	なお、CdReady() 関数はセクタバッファの状態をレポートするもので、
	後述する CdRead() の終了をリポートする CdReadSync() 関数よりも
	低レベルのインターフェースであることにご注意下さい。
	
** データレディ同期コールバック
	CdSyncCallback() と同様にセクタバッファの状態が CdlNoIntr から
	CdlDataReady/CdlDiskError に移行する際に呼ばれる関数（コールバッ
	ク 関数）を登録することができます。
	コールバックの登録には CdReadyCallback() 関数を使用します。
	ここで登録されたコールバック関数は、１セクタ分のデータが用意され
	るたびに起動します。後述する CdReadCallback() とは仕様が異なる
	の点にご注意下さい。
	
** セクタバッファ転送	
	セクタバッファ上には次々に新しいセクタデータが上書きされていき
	ます。従ってセクタデータは、上書きされる前にセクタデータをメイ
	ンメモリ上に転送する必要があります。これには CdGetSector() 関数
	が使用されます。セクタバッファのデータを直接フレームバッファやサ
	ウンドバッファに転送する場合も一旦メインメモリに転送してから各
	デバイスへ再転送を行ないます。

	セクタバッファのサイズは１セクタ分です。セクタサイズは、CD-ROM
	のモードによって異なりますが、通常は 2KB が使用されます。この
	場合、一回の CdGetSector() 関数でメインメモリに引き上げられる
	データサイズの上限も 2KB になります。データは、複数回にわけ
	て別々の場所に転送することもできます。ただしその場合も転送する
	データサイズの合計は、セクタサイズに等しくなくてはなりません。
	
	CD-ROM から n セクタ分のデータを読み出す例を以下にあげます。

	cd_read(loc, buf, nsec)
	CdlLOC	*loc;		/* ターゲットポジション */
	u_long	*buf;		/* 読み込みバッファ */
	int	n;		/* セクタ数 */
	{
		u_char	param[4];

		/* 倍速モードを指定 */					
		param[0] = CdlModeSpeed;				
		CdControl(CdlSetmode, param, 0);			+
									
		/* リトライリードコマンドを発行 */
		CdControl(CdlReadN, u_char *loc, 0);

		/* データが用意され次第メインメモリへ転送 */
		while (n--) {
			if (CdReady(0, 0) != CdlDataReady)
				return(-1);
			CdGetSector(buf, 2048/4);
			buf += 2048/4;
		}
	}
	
	この例では、フォアグラウンド転送を行ないますが、CdReadyCallback()
	を使用することで、バックグラウンド転送を行なうにすることもできます。
	
** セクタ転送同期
	セクタバッファからメインメモリへのデータの転送も非同期にバック
	グラウンドで実行されます。セクタバッファ・メインメモリ間の転送
	は、CD-ROM・セクタバッファ間の転送よりもはるかに高速であるため、
	通常はメインメモリへの転送の終了を意識する必要はありません。
	しかし、ムービーの再生のようにメインメモリ上のデータが確定する
	時を正確に知りたい場合もあります。その場合は、CdDataSync(),
	CdDataCallback() 関数を使用します。CdDataSync() 関数はセクタデ
	ータ転送の状態をレポートします。CdDataCallback() はセクタデー
	タ転送の終了時に呼ばれるコールバック関数を定義します。

* 高レベルインターフェース
** データリード	
	CD-ROM 上のデータは、CdlReadN プリミティブコマンドと CdGetSector()
	関数を組み合わせて読み出すことができますが、ライブラリではこれ
	らをまとめて複数セクタをメインメモリへ展開する関数 CdRead()も用意
	されています。

	CdRead(sectors, buf, mode)
	int	sectors;		/* 読みだしセクタ数 */
	u_long	*buf;			/* メインメモリアドレス */
	u_char	mode;			/* リードモード */

	CdRead() は内部で CdReadyCallback() を使用します。そのため CdRead()
	関数使用時にはこのコールバックは使用できません。
	
** データリード同期
	CdRead() 関数はノンブロック関数として動作します。CdRead() の実
	際の終了は CdReadSync() 関数を使用します。CdReadSync() 関数は
	ノンブロックモード動作時には、未リードの残りセクタ数を返します。
	以下の例はブロック型の CD-ROM 読み込み関数です。

	CdReadB(loc, buf, nsector)
	CdlLOC	*loc;			/* ターゲットポジション */
	u_long	*buf;			/* メモリアドレス */
	int	nsector;		/* 読みだしセクタ数 */
	{
		int	cnt;
		u_char	param[4];
		
		/* 倍速モードを指定 */
		param[0] = CdlModeSpeed;	
		CdControl(CdlSetmode, param, 0);			+
	
		/* ターゲットポジションを設定 */
		CdControl(CdlSetloc, (u_char *)&loc, 0);

		/* リード開始 */
		CdRead(nsector, buf, mode);
	
		/* リードが終了するまで残りのセクタ数を監視する */
		while ((cnt = CdReadSync(1, 0)) > 0 ); 
		
		return(cnt);
	}

** ストリーミング
	CD-ROM からデータを連続的に読み込んでメインメモリへ転送する処
	理をストリーミングと呼びます。ストリーミングは、複数のセクタか
	らなるデータの処理単位（１フレーム分の圧縮画像データなど）をメ
	インメモリ上にまとめ、その先頭ポインタをアプリケーションに渡し
	ます。
	ストリーミングは、St*() 関数として別に詳細に解説されております
	のでそちらを参照ください。
	
* ADPCM
	ADPCM (Adaptive Differential PCM: 適応的差分符号）は、16bit ス
	トレートPCM で表現された音声データを 1/4 に圧縮したものです。
	ADPCM データが格納されたセクタを ADPCM セクタと呼びます。一連
	の音声を再生するためのADPCMセクタは、標準速再生時には、４セクタ
	おき、倍速再生時には８セクタおきにディスクに飛び飛びに記録され
	ます。（インターリーブ）

	倍速度の場合の ADPCM セクタインターリーブは以下のようになります。
	
	 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f ・・ 
	--------------------------------------------------------
	|A |D |D |D |D |D |D |D |A |D |D |D |D |D |D |D |・・
	--------------------------------------------------------
					A: ADPCM セクタ
					D: データセクタ
	インターリーブを行なうことで ADPCM 再生を行ないながらデータの
	リードを行なうことができます。
	
** マルチチャネル

	ADPCM がインターリーブされたデータセクタに他の ADPCM チャネル
	の ADPCM セクタをおくことができます。

	 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f ・・ 
	--------------------------------------------------------
	|A0|A1|A2|A3|A4|A5|A6|A7|A0|A1|A2|A3|A4|A5|A6|A7|・・
	--------------------------------------------------------
					An: n チャンネル ADPCM データ
	
	この例では 8 チャネルの ADPCM セクタ (A0 - A7) をインターリーブ
	してディスクに記録することを表します。この場合、8 チャネルまでの
	オーディオ再生をディスクのシークなしに切替えることができます。

	こうした、マルチチャンネル ADPCM トラックを再生する際、どのチャ
	ネルを再生するかは CdlSetFilter コマンドを使用します。
	ADPCM トラックは、CdlFILTER 構造体のファイルメンバとチャネルメ
	ンバで確定されます。

* ポジション確定ユーティリティ
	CD-ROM への直接的なのアドレシングは、CdlLOC 構造体に分・秒・
	セクタのメンバを指定して対応するプリミティブコマンドを発行する
	ことでおこないます。CD-ROM の各トラック・ファイルの絶対位置はは
	ディスクを作成する前にあらかじめ決定できるために、基本的にはア
	プリケーション内で動的にトラック・ファイルの先頭ポジションを検
	索する必要はありません。しかしプログラムの開発・デバッグのために
	実行時に動的に目的のトラック・ファイルの先頭ポジションを検索す
	るユーティリティが用意されています。
	
** TOC リード
	CD-ROM は CD プレイヤの機能としてディスク作成時にオーディオセクタ
	・データセクタ列の先頭にトラックおよびインデクスを打ち込むこと
	ができます。トラック・インデックスは、ディスクの TOC 領域に記録さ
	れ、CdGetToc() 関数で獲得できます。
	TOC を使用したアドレッシングは、もともとオーディオトラックの再
	生位置を確定するための規格です。そのため秒単位の分解能しかもた
	ず、正確ではありません。

** ディレクトリリード
	ディスクが IS0-9660 ファイルシステムフォーマットで記録されてい
	る場合は、9660 ファイルシステムを通じてディスクの絶対値を取得
	することができます。ファイルシステム経由のアドレッシングは、
	TOC を使用したアドレッシングよりも正確な位置を取得できますが、
	ISO-9660 ファイルシステムが実装されていることが必要であり、オー
	ディオセクタには使用できません。

	9660 ファイルシステムを経由してファイルの先頭位置を検索するに
	は、CdSearchFile() 関数を使用します。
	CdSearchFile() はファイルの絶対パスから、ファイルの先頭位置を
	検索します。検索結果は、構造体 CdlFILE に格納されます。
	以下は 9660 ファイルをディスクから読み出す例です。

	CdlFILE	fp; 
	
	while (CdSearchFile(&fp0, "\\PSX\\SAMPLE\\RCUBE.TIM") == 0);	+
	CdControl(CdlSetloc, (u_char *)&fp.pos, 0);
	CdRead((fp.size+2047)/2048, sectbuf, CdlModeSpee);

	CdSearchFile () は、以下の CdlFILE 構造体メンバを返します。
	
	typedef struct {
		CdlLOC	pos;		/* ファイルポジション */
		u_long	size;		/* ファイルサイズ */
		char	name[16];	/* ファイル名（ボディ） */
	} CdlFILE;

** レポートモード
	オーディオセクタを再生中に再生ポジションを定期的にレポートする
	機能があります。これをレポートモードと呼びます。モードに
	CdlModeRept ビットを設定すると、CDオーディオ再生中１秒あたり 
	10回 CdDataReady 状態に移行して、レポート結果を返り値 (result)
	に返します。返り値には以下の情報が格納されます。
	
	===================================================================
	0	1	2	3	4	5	6	7
	-------------------------------------------------------------------
	status track 	index 	amin 	asec 	aframe	levelH	levelL
	-------------------------------------------------------------------

	レポートの取得には、CdReady()関数でポーリングするか、CdReadyCallback()
	を使用してバックグラウンドで取り込みます。

* イベントサービス
	初期化時には各コールバックに対してデフォルトのコールバック関数
	が登録されています。これらは、以下に示すイベントを配布します。
	
	==============================================================
	原因ディスクリプタ	内容			イベント種別
	--------------------------------------------------------------
	HwCdRom			処理完了		EvSpCOMP
	HwCdRom			データレディ		EvSpDR
	HwCdRom			データエンド		EvSpDE
	HwCdRom			エラー発生		EvSpERROR
	--------------------------------------------------------------
	
	従ってコマンドの終了・データ読み込み終了はイベントハンドラを経
	由して検出することができます。ただし、新しくコールバックを設定
	した時点でデフォルトコールバックは解除され、イベントの送信は停
	止します。解除されたデフォルトコールバックの復帰はアプリケーシ
	ョンに任せられています。以下にその例を示します。

	void	(*old_callabck)();

		・・・・
	
	/* コールバック設定の際に前のコールバックポインタを退避する */
	old_callback = CdSyncCallback(local_callback);
	
		・・・・
	/* コールバックを復帰 */
	CdSyncCallback(old_callback);

	
* コールバック・同期関数一覧

	====================================================================
	発行関数	同期検出	コールバック	内容
	--------------------------------------------------------------------
	CdControl	CdSync		CdSyncCallback	コマンド発行
	    -		CdReady		CdReadyCallback	セクタリード
	CdGetSector	CdDataSync	CdDataCallback	セクタバッファリード
	--------------------------------------------------------------------
	CdRead		CdReadSync	CdReadCallback	複数セクタリード
	--------------------------------------------------------------------
