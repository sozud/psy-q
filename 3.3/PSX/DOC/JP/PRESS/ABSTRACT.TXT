$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
*データ処理基本ライブラリ (libpress)

	データ処理ライブラリ (libpress) は、画像および音声データを圧縮
	（エンコード）・伸長（デコード）するための低レベル関数ライブラ
	リです。
	
	ライブラリ関数は、扱う対象によって画像ライブラリと音声ライブラ
	リに分けられます。

	libpress ─┬─画像 ──┬──T (離散コサイン変換
		   │   	│      	Discrete Cosine Translation)
		   │   	├─BVQ (ブロックベクトル量子化
		   │   	│      	Blocked Vector Quantization)
		   │   	└─Huffman (ハフマン符号化
		   │   			fixed codebook)
		   │
		   └─音声──── ADPCM

	画像ライブラリは、画像データを圧縮・解凍します。圧縮手法には、
	ダイレクトカラーの画像を DCT を用いて圧縮する手法、同じくダイ
	レクトカラーの画像鵜の色数を 256/16 色にまとめる BVQ （ブロッ
	クベクトル量子化、および、4bit インデクスカラーを可逆的に圧縮
	するハフマン符号化の３つが用意されています。

	音声ライブラリは、 16bit ストレート PCM を ADPCM を用いて約 1/4
	に圧縮します。
	圧縮された音声データは、SPU の音源データとして使用できます。

	さらに、各ライブラリの関数は、それぞれ圧縮を行なう Compressor
	ライブラリと解凍を行なう Decompressor ライブラリに分けられます。
	
	libpress ─┬──縮関数: Compressor
		   │
		   └─解凍関数: Decompressor	

	Compressor 関数は、メインメモリ上に展開された画像・音声データ
	を圧縮して、結果を再びメインメモリ上に戻します。Compressor 関
	数はアプリケーション内で動的にデータを圧縮する必要がある場合や、
	オーサリング環境からリモートで起動してオフラインでデータを生成
	する場合に用いられます。特に、実機には、DCT 回路が搭載されており、
	これを用いて DCT を用いた画像の圧縮を高速に処理できます。
	
	Decompressor 関数は Compressor 関数で圧縮されたデータをリアル
	タイムで解凍します。ただし、Compressor 関数の出力の中では、BVQ
	のようにそのまま実機のハードウェアで処理できる形式のものもあり
	ます。そうしたデータ形式の場合は対応する Decompressor はありま
	せん。

	データ処理ライブラリのファイル名は libpress.lib です。
	各サービスを呼び出すプログラムは必ずこれをリンクする必要があり
	ます。

	データ処理ライブラリのインクルードヘッダは、libpress.h です。

*MDEC
	PlayStation では高速な画像データ解凍を実現するために、専用のデー
	タ解凍エンジン（解凍装置）を備えています。これを MDEC (Motion
	DECoder) と呼びます。
	
	MDEC はメインメモリ上に配置された圧縮データを解凍し、結果をメ
	インメモリに書き戻します。これはされにフレームバッファの表示領
	域へ転送され解凍画像としてディスプレイに表示されます。
	
						            ┌──────┐
					        	    │FrameBuffer │
					      		    │		  │
					     		    └──┬───┘
		                ┌─────┐┌─────┐┌──┴───┐
		        	│CPU       ││MDEC      ││GPU         │
	                    	│          ││	  ││	          │
	                        └──┬──┘└──┬──┘└──┬───┘
	─────┬─────────┴──────┴────↑─┴───
		  │  →→→→      →→  │    →→→→    → 
		  │↑(1)     ↓  ↑(2)	↓│  ↑(3)    ↓ ↑(4) 
		  │↑        ↓  ↑    ↓│  ↑       ↓ ↑
	    ┌──┴──┐  ┌──────┴─────────┐
	    │ CD-ROM	│  │┌──┐ ┌───┐┌────┐ │
	    │		│  ││BS  │ │RUN   ││MACRO   │ │
	    └─────┘  ││    │ │ LEVEL││ BLOCK  │ │
	          ↑        ││    │ │      ││        │ │
	    ┌─────┐  │└──┘ └───┘└────┘ │
	    │BitStream │  └────────────────┘
	    │          │			Main Memory
	    └─────┘

	メインメモリに書き戻されたメインバスのアクセスは CPU および他の
	ペリフェラルと時分割に行なわれプログラムやフレームバッファ転送な
	どと並列して解凍処理ができます。


*画像データの圧縮

**概要
	画像データの圧縮には、対象となるデータのタイプや目的によって使
	用する圧縮アルゴリズムが異なります。
	
	DCT は、JPEG/MPEG で採用されている圧縮手法でダイレクトカラーの
	画像を高能率で圧縮します。圧縮は非可逆(lossy) ですが、圧縮率は
	自由に制御できます。指定する圧縮率は、通常 10%〜5% 程度が指定
	されます。
	DCT では、16x16 の24bit ダイレクトカラー画像を処理の基本単位と
	します。
	このセルを特にマクロブロックと呼びます。全ての画像は一旦 16x16
	のマクロブロックに分解されてからビットストリームと呼ばれる形式
	に圧縮され、解凍結果もマクロブロック単位で出力されます。
	
	例えば、320x240 の画像データは、以下のように、16x16 の多数のマク
	ロブロックに分解され、それぞれがビットストリームに圧縮されます。
	
	マクロブロック	    再生画像
			     ←			320 		    →
			    ┌─┬─┬─┬─┬─┬─┬──────┬─┐
	 B┌────┐←──┼  │  │  │  │  │  │  	  │  │
       G┌┴───┐│	    ├─┼─┼─┼─┼─┼─┼──────┼─┤
      ┌┴───┐││	    │  │  │  │  │  │  │  	  │  │
     R│↑	│││	    ├─┼─┼─┼─┼─┼─┼──────┼─┤
      │ 16     │││	    │  │  │  │  │  │  │  	  │  │
      │  pixel	│├┘	    │  │  │  │  │  │  │  	  │  │
      │↓      ├┘	    │  │  │  │  │  │  │  	  │  │
      └────┘ 	    │  │  │  │  │  │  │  	  │  │
        ← 16 → 	    │  │  │  │  │  │  │  	  │  │
	    pixel	    ├─┼─┼─┼─┼─┼─┼──────┼─┤
			    │  │  │  │  │  │  │  	  │  │
			    └─┴─┴─┴─┴─┴─┴──────┴─┘

	← 16 →					← 16 →
       ┌───┐       				┌───┐
       │      │					│      │      
       │      │ →圧縮→  ビットストリーム  →解凍 →	│      │
       │      │					│      │
       └───┘     				        └───┘
	マクロブロック					マクロブロック
	
	BVQ は、ダイレクトカラーの画像をベクトル量子化して 256/16 色に
	色数をまとめて、8bit/4bit インデクスカラーの画像を生成します。
	インデクスカラー形式の画像とは、実際の輝度値を記したテーブル
	(CLUT=Color LoopUp Table) および、CLUT へのインデクスからなる
	２次元配列で表現されたデータ形式を指します。
	
	インデクスカラー画像は同等のダイレクトカラー画像に比べて若干デ
	ータ量を抑えることができます。たとえば、各ピクセルの輝度値の種
	類が 16 以下であれば、インデクスは 4bit で済みます。そのため、
	16bit のダイレクトカラー形式の画像に比べその容量を 25% に圧縮す
	ることができます。
	
	4bit/8bit のインデクスカラーはそのまま 4bit/8bit のテクスチャパ
	ターンとして使用できるため、特別な解凍フィルタは必要ありません。
	
	BVQ では、圧縮の際に画像を複数の小領域に分割して、小領域ごとに
	ベクトル量子化を行ない色数をまとめることができます。この時、各
	小領域ごとに生成された CLUT に対してさらにベクトル量子化を行な
	い、CLUT 自体の個数をまとめることも可能です。その場合、画像デー
	タの各ピクセルは、ピクセルが属する小領域が保持する CLUT 番号、
	および、その CLUT へのインデクス値で２重にインデクスされること
	になります。
	このようにインデクス参照が多段階に行なわれるようなベクトル量子化
	をブロックベクトル量子化 (Block Vector Quantization) と呼びます。
	
	DCT,BVQ は、圧縮・解凍は可逆的 (loss-less) ではありません。
	4bit インデクスカラーを可逆圧縮するためのハフマン符号化関数がさ
	れています。使用するハフマンコードはコードブック（辞書）を最初
	に一回生成する古典的なものです。
	ハフマン符号化とは出現頻度の多いピクセル値（インデクス値）から順
	に短い符号長の符号（ハフマン符号）を割り当てることでデータを圧縮
	するものです。
	実際のピクセル値と対応するハフマン符号の対応表をコードブック（辞書）
	と呼びます。
	ハフマン符号の圧縮率はソース画像の性質によって異なります。一般
	に出現するピクセル値に偏りが大きいほど高い圧縮率が得られま
	す。

	以上の各圧縮・解凍アルゴリズムの概要は以下の通りです。

	=================================================================
	|		| DCT		| BVQ		| ハフマン	|
	|---------------+---------------+---------------+---------------|
	| タイプ	| lossy		| lossy 	| loss-less	|
	| 入力形式	| 24bit/16bit	| 24bit/16bit	| 4bit		|
	| 出力形式	| BitStream	| 4bit/8bit	| BitStream	|
	| 圧縮率	| 10%〜5%	| 50%〜25%	| -		|
	=================================================================
	
** DCT
*** 原理
	DCT は一般的には直交変換と呼ばれる線形変換に含まれ、一種の周波
	数変換と考えることができます。
	Ｎ×Ｎの矩形画像に DCT 変換を施すと、その画像の低周波成分が一箇所
	に集中します。その結果をハフマン符号化することによりデータの圧縮
	が行なわれます。つまり DCT そのものは、データの圧縮が容易な形に変
	換するだけで、それ自体データサイズを小さくする性質のものではなく、
	実際にデータ圧縮を行なうのは、ハフマン符号化ということになります。
	DCT 変換を行なうと、一般的な画像はその周波数成分が低域に集中して
	いるため、変換後の成分のほとんどが零になり、画像を直接ハフマン符
	号化するよりも遥かに高能率の圧縮を実現できます。
	ここでのハフマン符号化を特に VLC(Varable Length	Coding)と呼びます。
	
	VLC されたデータはバイト／ワードバウンダリは論理的には無意味とな
	り、単なるビットの並びで表現されたものとなります。これをビットス
	トリームと呼びます。
	
	この一連の作業はすべて 16x16 の矩形領域単位で行なわれます。この
	単位をマクロブロックと呼びます。DCT 圧縮はマクロブロックを入力と
	してそれを圧縮しビットストリームの形式に変換するものと言い替える
	こともできます。
	
	画像は DCT 変換された後に一旦ある単位でクオンタイズ（量子化）がか
	けられます。この量子化ステップを制御することで圧縮率を制御する
	ことができます。一般に量子化ステップをあらくすれば圧縮率は向上しま
	す。

	DCT の解凍は、圧縮の逆の手順を行ないます。すなわち取り込んだビッ
	トストリームを一旦 VLC デコードした後、これを IDCT (Inversed
	Discrete Cosine Translation=逆DCT)して、元の画像を復元します。
	従ってビットストリームを解凍は、
	
	1) VLC のデコード
	2) IDCT

	の二つのパスから構成されることになります。

*** 実装方式
	24bit カラーデータは一旦 DCT 変換されたのちランレングス圧縮さ
	れた形式 (ランレベル）の中間データを出力します。これを VLC をか
	けてビットストリームを出力します。圧縮率の制御はランレベルを生
	成する過程で量子化ステップを指定することで行ないます。

	・圧縮
		    24bit 16x16 マクロブロック
				↓	←圧縮率設定
			    ランレベル（出力されない）
				↓
			 ビットストリーム


	実際には、圧縮時には中間データであるランレベルは出力されません。
	マクロブロックエンコードの流れを以下に示します。	


		  16	   	      8   8
	      ┌───┐            ┌─┬─┐    ┌─┐	    
	      │      │→ CSC →  8│Y0│Y1│ → │  │→ DCT → 量子化 → 
	    16│      │            ├─┼─┤    └─┘	    
	      │      │           8│Y2│Y3│   ブロック
	      └───┘            └─┴─┘
	    マクロブロック	    ┌─┬─┐
			           8│Cb│Cr│
			            └─┴─┘
	
		→ ジグザグスキャン →  ランレベル → VLC → BS

				CSC: Color Space Convertion
				DCT: Descrete Cosine Transformation
				VLC: Variable Length Coding
				BS : Bit Stream

	解凍は圧縮の逆の作業を行ないます。	
	
	DCT の対象となる画像データは、24bitダイレクトカラーですが、こ
	れを圧縮して作られたビットストリームは、16bit/24bit のいずれの
	モードでも解凍できます。モードの設定は解凍時に選択できます。
	また、16bit ピクセルの場合先頭の 1bit (STP ビット）の on/off 
	も解凍時に選択できます。
	
	・解凍
			 ビットストリーム
				↓	VLC デコード
				↓	関数名：DecVLC()
			    ランレベル
				↓	IDCT
				↓	関数名：DecDCTin()/DecDCTout())
		    24bit 16x16 マクロブロック

	解凍のブロック図を以下に示します。
	
  		       ランレベル
	BS → IVLC → ┌─┬───┐ →
		      └─┴───┘ 
								    ┌───┐
								  ┌┴──┐│
	ランレベル						┌┴──┐││
	┌─┬───┐ 	→ ジグザグ → IQ → IDCT → CSC →     │MB  	│││
	└─┴───┘		スキャン			│      │├┘
		│						│      ├┘
		└──────────┬───────────┘└───┘
				     MDEC

	ランレベルからマクロブロックへの解凍を MDEC が行ないます。

	VLC のデコードは、関数 DecVLC() を使用します。IDCT は、処理時
	間がかかるため、CPU と並列にMDECが処理を行ないます。そのため、
	MDEC へデータを転送するための関数 DecDCTin() および、解凍した
	データを受けとる関数 DecDCTout() が用意されています。
	
*** 非同期デコード
	MDEC と CPU はお互いにメインメモリを共有しながら並列に動作しま
	す。DecDCTin()関数は CPU がバス権を開放している間をぬってバッ
	クグラウンドでビットストリームを MDEC へ送信します。
	同様に、DecDCTout() 関数もバックグラウンドで、解凍したマクロブ
	ロックをメインメモリに転送します。

	MDEC で解凍したデータは必ず一旦メインメモリを経由してフレーム
	バッファに転送されます。

	この時、MDEC とメインメモリ間の送受信は非同期に行なうことがで
	きます。従って１フレーム分(640x240) の画像を解凍するのに際して、
	メインメモリ上にフレームサイズ分のバッファを構成せずに解凍する
	ことが可能です。
	
	この例では、画像を 16x240 (15 マクロブロック）の縦に細長い領域
	（短柵）に切り分けて短柵ごとにデータを受信、転送しています。

	extern u_long	*mdec_bs;	/* ビットストリーム */
	extern u_long	*mdec_rl;	/* ランレベル（中間データ）*/
	extern u_short	mdec_image[15][16][16];
					/* デコードマクロブロック */
	
	DecDCTvlc(mdec_bs, mdec_rl);	/* VLC の解凍 */
	DecDCTin(mdec_rl, 0);		/* ランレベルを送信 */

	for (rect.x = 0; rect.x < width; rect.x += 16) {
		DecDCTout(mdec_image, slice);	/* 受信 */
		LoadImage(&rect, mdec_image);	/* フレームバッファへ転送 */
	}

	このように、一回の DecDCTin() 関数で送信したビットストリームを
	複数回の DecDCTout() にわけて受信することによりメインメモリ上
	のバッファサイズを削減することができます。
	ただし、この場合でも、送信するビットストリームと受信するマクロ
	ブロックの個数は対応がとれていなくてはなりません。

*** コールバック
	
	DecDCTin/DecDCTout() 関数はいずれもノンブロック関数であり、データの
	送信／受信の終了を待たずにリターンします。
	そのため、転送の終了を検出するには、DecDCToutSync(), DecDCTinSync()
	関数か、後述するコールバック登録関数が必要になります。
	コールバック登録関数(DecDCToutCallback()/DecDCTinCallback())は、転送
	処理が終了した時に呼ばれる関数（コールバック）を定義します。コール
	バック関数内で次のデータの送受信を起動するような構成にすること
	で、画像の解凍をバックグラウンドで非同期に行なうことができます。

	以下の例では、DecDCTout() のコールバック関数中で次の DecDCTout()
	を起動しています。

	/* メイン関数 */
	main()
	{
		DecDCTout(mdec_image, slice);	/* 最初のブロックを送信 */
		DecDCToutCallback(callback);	/* コールバックを定義 */
	 	DecDCTvlc(mdec_bs, mdec_rl);	/* VLC デコード */
	 	DecDCTin(mdec_rl, 0);		/* ランレベルを送信 */
			.......
		
			/* ここにフォアグラウンド処理を記述する */
	
			.......
	}
	
	/* コールバック */
	callback()
	{
		LoadImage(&rect, mdec_image);	/* フレームバッファへ転送 */
		if ((rect.x += 16) < width)
			DecDCTout(mdec_image, slice);	/* 次を受信 */
		else
			DecDCToutCallback(0);		/* 終了 */
	}
	
*** CD-ROM による動画再生
	ビットストリームを CD-ROM から連続的に読み込み再生することによ
	り動画の再生を行なうことができます。
	動画の解像度とフレーム数は、解凍速度とCD-ROM 転送速度の両方で決
	まります。
	
	MDEC の解凍速度は、最大 9000 マクロブロック／秒です。これは、
	320x240 の画像を秒３０枚の速度で解凍することに当たります。
	この解凍速度は圧縮率には関係ありません。
	当然ながら、画像の解像度と再生フレーム数は反比例します。
	すなわち、320x240 の画像であれば、30フレーム/秒, 640x240 であれば
	15 フレーム／秒の動画が実現できます。

	解凍速度
	---------------------------------------------------------
	解像度	     |320x240	| 640x240 | 640x480....
	-------------+----------+---------+-----------------------
	フレーム／秒 |	30	|15	  | 7.5 .......
	---------------------------------------------------------
	
	一方、CD-ROM は転送レートとして 150KB/sec（標準速）か 300KB/sec
	（倍速）を選択できます。倍速再生時は、１フレームを構成するビット
	ストリームを 10KB (= 300KB/30) 以下に圧縮して、CD-ROM に記録すれ
	ば、CD-ROM から30フレーム／秒のデータが読み出せることになります。
	
	転送速度
	---------------------------------------------------------
	データサイズ | 10KB	|20KB     | 30KB
	-------------+----------+---------+-----------------------
	フレーム／秒 | 30	|15	  | 7.5 .......
	---------------------------------------------------------
	
	動画再生レートはこれら二つの条件で決まります。例えば、倍速再生時
	は、１フレーム(320x240)を構成するビットストリームを 10KB
	(= 300KB/30) に圧縮し、CD-ROM に記録すればよいことになります。
	この条件を満たす範囲であれば、フレーム数・画像解像度・圧縮率は
	任意に選ぶことができます。
	
	一般にCD-ROM から連続的にデータを読み込む処理をストリーミング
	と呼びます。ストリーミングを行なうためのライブラリ（ストリーミ
	ングライブラリ）はより汎用的な形で別に用意されています。
	動画の再生はこのストリーミングメカニズムが提供するコンテナにビ
	ットストリームを載せて実現することになります。
	
	また、ビットストリームには画像のサイズなどの付加情報は含まれて
	いません。そのため、動画を再生するために必要な情報をヘッダに付
	加したデータ形式（STRフォーマット）が別に定義されています。

*** ダイレクト転送とテクスチャ転送
	単純に動画を再生する場合は、フレームバッファをダブルバッファ構
	成にして、描画バッファ側に解凍した画像を次々に転送することで実
	現します。動画の転送を最初の BG (バックグラウンド）面のクリア
	として使用し、その上にオブジェクト・プリミティブを描画すること
	ができます。
	このように、解凍画像を直接フレームバッファの描画領域に転送する
	方法をダイレクト転送とよびます。
	これに対して、解凍画像を一旦テクスチャエリアに転送し、テクスチャ
	アニメーションを行なうような転送方法をテクスチャ転送と呼びます。
	テクスチャ転送を行なう場合、使用するテクスチャは、16bit モード
	に限られます。

*** 実機エンコーダ
	通常は、ランタイムにはDCT による圧縮は行ないません。しかし、描
	画装置で生成した画像をフレームバッファから取り込んで、その場で
	圧縮する場合や、オーサリング時に実機の CPU パワーを利用してデー
	タを圧縮するために DCT 圧縮関数も用意されています。
	
	圧縮処理に必要な DCT演算は、MDEC が持つ IDCT 演算回路でも実現で
	きるので、実機を用いたエンコードの場合はより高速にデータをエンコ
	ードできる利点があります。
	
** BVQ
	BVQ は、24bit/16bit ダイレクトカラーの画像の色数をベクトル量子
	化によって縮退して、8bit/4bit インデクスカラー形式の画像を生成
	するものです。ベクトル量子化とは、輝度値のように１次元的に順序
	づけのできない量（ベクトル）をその出現頻度に応じて適応的に量子
	化する手法の一つです。
	
	DCT によって圧縮されたデータはフレームバッファに転送する時点で
	はすでに 16bitに復号されているため、フレームバッファ自体の領域
	の節約にはなりません。これに対して、ベクトル量子化された画像は
	圧縮された形式のままフレームバッファへ転送し、そのままテクスチ
	ャパターンとして使用できる利点があります。
	
	ブロックベクトル量子化をする際には、１枚の画像を複数の小領域に
	あらかじめ分割する必要があります。一般に分割方法は、その画像が
	テクスチャパターンとしてどのように使用されるかによって決まります。
	PlayStation では、テクスチャマップを行なうポリゴンごとに別々の
	CLUT を割り当てることができます。従って領域の分割は各ポリゴン
	プリミティブの (u,v) の値に応じて分割するのが標準的です。
	
	小領域に対してそれぞれベクトル量子化を行なうと、分割した領域の数
	だけの CLUT が生成されます。しかし、分割数が大きい場合、CLUT の占
	める領域が無視できない大きさになります。
	そのために、BVQ では、CLUT 自体をさらにベクトル量子化する機能を
	備えています。
	たとえば、320x240 の画像を 300 個の16x16 の 4bitセルに分割する
	場合、セルごとに生成される 300 本の CLUT をさらに量子化してたと
	えば 8 本にまとめることも可能です。

** ハフマン符号化
	ここでのハフマン符号は、コードブックが固定の古典的なものが使用さ
	れます。ハフマン符号化の対象になるものは 4bit インデクスカラー
	データのみです。
	圧縮・解凍の過程ではデータの内容は保存されます。こうした圧縮法を
	可逆圧縮 (loss-less圧縮) と呼びます。一般にloss-less 圧縮では圧縮
	率を制御することはできません。
	
	ハフマンエンコーダは入力ピクセルの出現頻度からまずコードブックを
	生成します。コードブックのサイズはピクセル数に関わらず一定なので、
	ピクセル数が少ない場合、コードブックの占める割合が大きくなり圧縮
	効率が低下します。
	
	コードブックが生成されるとそれに応じて各ピクセルが圧縮されます。
	結果として生成されるデータは、DCT と同様のビットストリーム形式
	になります。
	圧縮されたデータは、常にコードブックとセットで解凍されます。

*音声データの圧縮
**概要	
	PlayStation では、音声データは、16bit ストレート PCM データを
	4bit ADPCM に圧縮されて使用されます。
	圧縮された音声データはそのまま、SPU の音源データとして使用でき
	ます。
	
	SPU では、周期的な音声データを少ないサンプル数で記録できるよう
	に、ルーピングと呼ばれる機能を備えています。音声圧縮関数は、デー
	タ圧縮時に適正なループポイントを設定する機能もあります。

