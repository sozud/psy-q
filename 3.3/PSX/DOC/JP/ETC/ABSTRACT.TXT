$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
*周辺機器ライブラリ libetc						+
									+
	libetc はコールバックの制御を行なう関数ライブラリです。		+
	各ライブラリの使用するコールバック機能の実体はすべてここで管理	+
	されています。							+
	加えて、libetc では、現在は、コントローラに関するライブラリも	+
	収められています。						+
									+
	なお、各コールバックに関する詳細は対応するノンブロック関数の収	+
	められているドキュメント内に記述されています。そちらも御参照下	+
	さい。								+
									+
	ライブラリのファイル名は libetc.lib です。			+
	各サービスを呼び出すプログラムは必ずこれをリンクする必要があり	+
	ます。								+
									+
	インクルードヘッダは、libetc.h です。				+
	各種ののデータ構造、マクロはすべてこのファイルで定義されていま	+
	す。各サービスを呼び出すプログラムは必ずこれをインクルードする	+
	必要があります。						+

*コールバック
** 概要	
	グラフィックの描画、サウンドバッファへの転送、CD-ROM からのロー
	ドなどのように非同期で処理を行なう関数の多くはバックグラウンド
	で並列に実行することができます。これらの関数をノンブロック関数
	と呼びます。ノンブロック関数が実際に終了したときの処理は、コー
	ルバック関数によって前もって定義しておくことができます。

	コールバック関数は、対応するノンブロック関数の終了時に呼び出さ
	れます。実際には、ノンブロック関数の終了時に割り込みが発生し、
	コールバックとして登録された関数のアドレスにプログラムがジャン
	プすることになります。
	コールバック関数がリターンすると、プログラムは、そのコールバック
	が起動された地点に戻り、そこから通常の処理が再開されます。

	コールバック関数のリターン時に元の状態に復帰できるようにするた
	めに、コールバック関数内では専用のローカルスタックが使用され
	ます。また、コールバック関数内では、全ての割り込みが禁止され
	ます。（クリティカルセクション）


	  通常セクション    クリティカルセクション
	 ┌──────┐  ┌──────────┐
	 │main() {    │  │			 │
	 │   ....     │  │    ┌──────┐│
	 │            │  │  ┌┤callback() {││
	 │        →─┼─┼─┘│ ....       ││
	 │        ←─┼─┼─┐│            ││
	 │            │  │  └┤}           ││
	 │            │  │	 └──────┘│
	 │            │  │			 │
	 │}           │  │			 │
	 └──────┘  └──────────┘

		コールバックのコンテクスト	  

** コールバックの種類

	コールバックは、現在以下のものがサポートされています。
	詳細は、各ライブラリのドキュメントを参照ください。

	==========================================================
	関数			対応するノンブロック関数
	----------------------------------------------------------
	VSyncCallback		-
	DrawSyncCallback	DrawOTag()/LoadImage()/StoreImage()	
	-----------------------------------------------------------
	DecDCTinCallback	DecDCTin
	DecDCToutCallback	DecDCTout
	-----------------------------------------------------------
	CdSyncCallback		CdControl
	CdReadyCallback		CdControl
	CdDataCallback		-
	-----------------------------------------------------------
	
** コールバックの初期化

	コールバックを使用する場合には、あらかじめローカルスタックの設
	定などの初期化が必要になります。従ってプログラムはコールバック
	を使用するに先立ち必ず初期化関数 ResetCallback() を呼び出さな
	くてはなりません。しかし、ほとんどのライブラリの初期化関数は、
	内部で ResetCallback() を呼び出すようになっており、アプリケー
	ションが明示的に呼び出す必要はありません。
	
	現在自動的に ResetCallback() を呼び出す初期化関数には以下のも
	のがあります。

	============================================================
	関数名			内容
	------------------------------------------------------------
	ResetGraph(0)		描画装置の初期化
	DecDCTReset(0)		解凍装置の初期化
	SsInit()		音源装置の初期化
	CdInit(0)		CD-ROM の初期化
	PadInit(0)		コントローラの初期化
	------------------------------------------------------------

	ResetCallback() が呼ばれた直後は全てのコールバックポインタは、
	NULL (0) に初期化されています。

** コールバックの終了

	コールバック機能は StopCallback() を呼び出すことによって一時的
	に停止することができます。StopCallback() で停止したコールバッ
	クは、もう一度 ResetCallback() を呼び出すことで再起動されます。
	ただし、この場合、StopCallback() を呼び出す前に登録されていた
	コールバック関数ポインタは保存されません。

** コールバックポインタ

	コールバックに設定する関数のポインタをコールバックポインタと呼
	びます。
	コールバックインターフェースは低レベルのものであり、１つのコー
	ルバックに同時に登録できるポインタは１つに限られます。
	そのため、１つのコールバック要因に複数のポインタを設定するメカ
	ニズムはアプリケーションのプログラムに任されています。
	
		main(void) {		/* メインプログラム */
			void callback(void);	
			...
		
			VSyncCallback(callback);
			..
		
		}
		void (*func)() = {	/* コールバックテーブル */
			func0,		/* 最初に呼びたいコールバック */
			func1,		/* ２番目に呼びたいコールバック */
			func2,		/* ３番目に呼びたいコールバック */
			0,
		};
		void callback(void)	/* 親コールバックプログラム */
		{
			int	i;
			for (i = 0; func[i]; i++)
				(*func[i])();
		}
	
	また、新しくコールバックを設定すると、以前のコールバックポイン
	タは捨てられてしまいます。従って一時的にコールバックを設定する
	場合には、それを解除する際に、以前と同じ状態を復帰させておくこと
	が必要です。
	
		void (*old)();
		void addVSyncCallback(void (*func)())
		{
			old = VSyncCallback(func);
		}
		void delVSyncCallback(void )
		{
			VSyncCallback(old);
		}

** 多重コールバック							+
									+
	コールバックコンテクストは、現在すべてのコールバックに対して共	+
	通で一つのローカルスタックを使用しています。そのためにコールバッ+
	ク内で他のコールバックが発生することができません。		+
	コールバック関数内で他のコールバック要求が発生した場合は、要求	+
	は一旦保留され、現在のコールバック関数が終了するまで処理は待た	+
	されます。以下のように、event1, event2 がコールバック実行中に	+
	発生しても、対応するコールバックの実行はキュー上のコールバック	+
	が順に処理されるまで待たされます。				+
									+
	通常セクション	    クリティカルセクション			+
       ┌─────┐	   ┌──────┐	← event0		+
       │main()	   │	 ┌┤callback0() │				+
       │{	   │	 ││(event0)	 │				+
       │	   │	 ││		 │	← event1		+
       │  ..... →┼──┘│            │				+
       │        ←┼──┐└──┬───┘				+
       │	   │	 │┌──┴───┐	← event2		+
       │	   │	 ││callback1() │				+
       │	   │	 ││(event1)	 │				+
       │	   │	 │└──┬───┘				+
       │	   │	 │┌──┴───┐				+
       │	   │	 ││callback2() │				+
       │	   │	 └┤(event2)	 │				+
       │ return();│	   └──────┘				+
       │}	   │							+
       └─────┘							+
									+
	従ってコールバック内で時間のかかる処理を行なうような場合はご注	+
	意下さい。							+
									+
	ただし、タイマによるコールバックをルートカウンタ(RCnt)インター	+
	フェースを使用して使用する場合は、これが、通常のコールバックよ	+
	りも優先して処理されます。					+
									+

** 子プロセスとコールバック
									+
	コールバックのコードの一部およびデータは、アプリケーションと一	+
	緒にメモリ上にリンクされます。現在共有ライブラリが実現されてい	+
	ないため、コールバックのコード・データは、プロセス同士で共有さ	+
	れず、それぞれが同じコピーを持って使用されることになります。	+
	このため、親プロセスから子プロセスへ処理を移す場合には、コール	+
	バック環境の継承が必要になります。				+
									+
	現在の、Exec インターフェースでは、コールバック環境の継承は自動	+
	的に行なわれないため、CD-ROM からロードしたプログラムへジャンプ	+
	する場合や、子プロセスに制御を移す場合には、アプリケーション側で+
	この操作を行なう必要があります。				+
									+
	この場合は、							+
									+
	親プロセス							+
		1) イベントをすべてクローズする(CloseEvent)		+
		2) コールバックを一旦停止 (StopCallback)		+
		3) 小プロセスへ大域ジャンプを行なう。(Exec)		+
									+
	小プロセス							+
		1) コールバックを初期化 (ResetCallback)			+
		2) 改めてライブラリを初期化 (CdInit, ResetGraph etc)	+
		3) 改めてアプリケーションコールバックを設定する		+
		4) 改めてイベントをオープンする	(OpenEvent)		+
									+
	この手順は小プロセスからリターンして親プロセスに制御を戻す場合	+
	にも必要となります。						+
									+

** デフォルトコールバックとイベント
	
	各ライブラリの初期化時には、各コールバックに対してデフォルトの
	コールバック関数が登録されています。
	
	例えば、初期化時には、CdSyncCallback() （CD-ROM プリミティブコ
	マンドの終了時に呼び出される関数) には、以下のようなコールバッ
	クが設定されています。 

	static void def_cbsync(u_char intr, u_char *result)
	{
		DeliverEvent( HwCdRom, EvSpCOMP );
	}

	従ってデフォルトコールバックを使用すれば、コマンドの終了・データ
	読み込み終了はイベントハンドラを経由して検出することができます。
	
	ただし、新しくコールバックを設定した時点でデフォルトコールバック
	は解除されイベントの送信は停止しますのでご注意下さい。


*コントローラ								+
	標準コントローラは、起動時に PadInit() 関数でオープンする必要があり+
	ます。								+
	初期化されたコントローラの内容は、垂直帰線時に一回スキャンされ、+
	最新の状態は PadRead() によっていつでも獲得することができます。	+
	PadRead() は 32bit 整数値を返し、下位 16bt、上位 16bit でそれ	+
	ぞれコントローラＡ／Ｂの状態を表します。			+
									+
	各コントローラのボタンアサインは、libetc.h に記述されていますの	+
	でそちらを参照下さい。						+
									+
	PadInit/PadRead インターフェースは標準コントローラを対称として	+
	おり、その他のコントローラインターフェースを使用する場合は、直	+
	接コントローラドライバを操作する必要があります。		+

* ビデオモード								+
									+
	ライブラリに現在のビデオ信号方式を宣言する関数 SetVideoMode()	+
	を提供します。							+
									+
	現在の PlayStation のライブラリにおいては NTSC 方式のビデオ信	+
	号の環境をデフォルトとして設計されておりますが、上記		+
	SetVideoMode() を全てのライブラリの関数より先だって呼ぶことに	+
	より、関連するライブラリがそのモードを判断して、指定されたビデ	+
	オ信号方式の環境に即した動作をするようになります。なお、関連す	+
	るライブラリとして libgpu, libsnd のドキュメントもご参照下さい。+
