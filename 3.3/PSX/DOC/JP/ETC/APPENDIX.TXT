$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
*Appendix:
** VSync の割り込みと、パッド／カード／マウスについて

	コントローラ／カード／マウスの処理は、全てコントローラドライバ
	が、まとめて管理をしています。

	現在のライブラリの構成では、コントローラドライバは、初期化関数
	を呼ばれた時点で、V-BLNK （垂直帰線同期）の割り込みに自動的に、
	フックされるようになっています。
	
	その際にドライバは、デフォルトで V-BLNK の割り込みをクリアし
	てしまうような設定にあることがわかりました。
	
	この場合、V-BLNK の割り込み発生時に最初にコントローラドライ
	バに処理が飛んだ場合、V-BLNK の割り込みはそこでクリアされ、
	VSync() の割り込みが検出できなくなります。現在報告されている
	VSync TImeout に関するバグはほぼこれが原因と思われます。

	コントローラドライバのこの設定を抑制するには、
	
		ChangeClearPAD(0);
	
	を最初に１回コールする必要があります。
	
	この関数は、PadInit() インターフェースを使用している場合は内部
	で自動的に呼ばれるようになっています。しかし、それ以下のレベル
	のパッドインターフェース、あるいは、カード／マウスを使用する場
	合は、ChangeClearPAD() は自動的には呼ばれません。
	
	さらに、PadInit() 以外の初期化関数は、関数の多くは、最後で
	ChangeClearPAD(0) と逆の働きをする
	
			ChangeClearPAd(1);
		
	を呼び出して、コントローラドライバを割り込みをクリアする状態にし
	てリターンします。

			InitCard();
			PadInit();
	が動作して
			PadInit();
			InitCard();

	しないのはそのためであると思われます。

	この問題を確実に解決するためには、パッド／カードの全ての初期化が
	終了したあとに、

			ChangeClearPAD(0);

	を呼び出して、割り込みフラグのクリアをしないようにする必要があり
	ます。

	以前の VSync() は、その検出に割り込みを使用していなかったため、
	動作していましたが、現在のバージョンでは V-BLNK の割り込みを使
	用して正確に V-BLNK の立ち上がりを検出するように変更されており、
	この処理を行なわない場合、TimeOut が発生します。

	従って、先ほどの動作しない例に関しても

		PadInit(0);
		InitCard(0);
		ChangeClearPAD(0);

	の順番にコールすれば動作します。
	
								
** VSync のコールバックに関して

	いつもお世話になっております。先日御指摘のありました垂直同期割り
	込みに関する問題点について検討した結果をご報告致します。

*** Vsync のコールバックを複数 open した場合

	内部でコールバックのエントリ自体は一つですが、RCnt インターフェ
	ースでは、コールバック関数ポインタは、内部のリストでチェーンさ
	れています。チェーンされたコールバック関数がシステム内部でどの
	ような順番で呼ばれるかは一意ではありません。一つのコールバック
	で複数の関数を任意の順番でコールする場合は、最低レベルである、
	VSyncCallback() を使用して、アプリケーションで各ローカル関数に
	分岐するのが確実と思われます。

	例）
	/* メインプログラム */
	main(void) {
		void callback(void);	
		...
	
		VSyncCallback(callback);
		..
	
	}

	/* コールバックテーブル */
	void (*func)() = {
		func0,		/* 最初に呼びたいコールバック */
		func1,		/* ２番目に呼びたいコールバック */
		func2,		/* ３番目に呼びたいコールバック */
		0,
	};
	
	/* 親コールバックプログラム */
	void callback(void)
	{
		int	i;
		for (i = 0; func[i]; i++)
			(*func[i])();
	}

*** VSync の割り込みタイミングについて

	VSync の割り込みは V-BLNK の最初で発生します。
	従って、コールバック関数の先頭で描画を起動し、その描画が、V-BLNK
	期間に終了する程度のものであれば、 シングルバッファを使用した描画
	を行なうことができます。

	しかし、VSync の割り込みでサウンドドライバを起動していて、かつ、
	サウンドドライバ (SsSeqCalledTbyT) が描画関数 (DrawOTag) の前
	で呼ばれている場合では、描画の開始が遅れて、その結果、描画が
	V-BLNK 期間内に終了しない可能性があります。

	callback()
	{
		SsSeqCalletTbyT();	
		DrawOTag(ot);
		DrawSync();
	}

	|<-------------------- V-BLNK ----------------->|
	|callback					|
	|<----- SsSeqCalledTbyT ------->|		|	
	|				DrawOTag	|
	|				|<-------- 描画 ------->|
	|						|
	
	この場合は、
	
	callback()
	{
		DrawOTag(ot);
		SsSeqCalletTbyT();
		DrawSync();
	}

	の順番でサウンドドライバ実行と並行して描画を行なうようにする方
	法があります。DrawOTag() はノンブロック関数であるため即座にリ
	ターンすることにご注意下さい。

	|<-------------------- V-BLNK ----------------->|
	|callback					|
	|DrawOTag					|
	|<-------- 描画 ------->|			|
	|SsSeqTickCallTbyT				|
	|<----- SsSeqCalledTbyT ------->|		|
	|				DrawSync	|



** メモリカードについて

PSボード（DTL-H2000）上でメモリカードを運用するためにはパッチプログラ
ム patchx.cpeを 実行しておく必要があります。

patchx.cpe によるパッチが無効な状態でのメモリカード関連関数の実行はバ
スエラーなどによるハングアップを引き起こします。

プログラミングに詳細についてはサンプルプログラム CMAN を参照ください。


［諸元］

○ハードウェア

  ======================================================================
   容量            フォーマット時120Kバイト
                   （128バイトのセクタ単位でアクセス）

   アクセス速度    (1) １セクタ書き込み後、20m秒間アクセス不可
                   (2) 最大連続読みとり速度は約10Kバイト／秒

   その他          電源を落さずに抜き差し可能
                   10 万回書き込み保障
                   20代替セクタ／カード（ファイルシステム内部で実現）
  ----------------------------------------------------------------------


○ BIOS

コントローラ読み込みおよびAB 2 つのコネクタへのアクセスを共存させるため 
2 VBLANKに１セクタを扱うBIOSを用意しました。
デメリットとして、１コネクタに対しての連続読みとりを最大速度で行なうこ
とができません。


 ======================================================================
  起動タイミング          VBLANKの先頭（コントローラ読みとり）直後
  実効アクセス速度        30 セクタ／秒 ＝ 3.75Kバイト／秒
  CPU負荷                 2 枚のカードから連続read時2.5％
                          2 枚のカードに連続write時3.2％
 ----------------------------------------------------------------------


○ ファイルシステム

 ======================================================================
  デバイス名              buX0    X:コネクタ番号（０または１）
  ファイル名              21文字までのASCIZ文字
                          （先頭にタイトル固有の文字列を含むこと）
  ディレクトリ構造        なし
  管理単位：スロット      8Kバイト（64セクタ）→ファイルサイズの単位
  スロット数              15個／カード（最大ファイル数は15）
  内部使用イベント数      ０（以前の４との記載を修正）
  初期化関数              _bu_init()（起動時は未初期化）
  同時アクセス制限        各差込口に１処理のみ受け付け可能
                          （多重した関数は実行失敗）
  その他                  ファイルcreate時にサイズをスロット単位で指定
                          以後サイズ変更不可
                          容量管理はスロット単位
                          自動代替セクタ機能
                          オープン時自動初期化機能（オプション）
 ----------------------------------------------------------------------


［運用ルール］

○ 異常処理

アプリケーション実行中に容量不足や未フォーマットカードの検出などが発生
した場合の処理についてはSCE標準の画面やメッセージ（例えばOSDと同じアイ
コンによる表示が必須というような）は定めません。個々のアプリケーション
に応じた設計をお願いします。ただし、次の点に留意ください。

  (1) 論理初期化を行なう場合は必ずオペレータに問い合わせて下さい。
      よって自動初期化機能は使わないでください。
  (2) カードが検出できず、かつ将来何んらかの操作制限が生ずることが判明
      した場合は必ずオペレータに通知してください。できれば問い合わせを
      お願いします。


○ 用語体系

商品カタログでの必要メモリ容量の単位は「ブロック」となっています。これ
は 8 Kバイトに相当します。弊社開発部リリースのドキュメントでは、同じ容
量単位を「スロット」と呼び、「ブロック」はアクセスの単位である 128 バ
イトを指します。BBS などによるお問い合わせの場合は「スロット」をお使い
ください。


○ ファイル名

ファイル名は次のような構成としてください。

 =========================================================
   バイト          内容            備考         
 ---------------------------------------------------------
     0              マジック	 常に'B'      
     1              地域         国内は'I' 北米は'A' 
	                         欧州は'E'（*1）    
     2-11           タイトル     SCE品番(*2)
     12-20          ユーザ公開   0x00以外のASCIIのみ使用
				 0x00で終了
 ---------------------------------------------------------
	*1：いずれもシステムによるチェックなし
	*2：複数discタイトルは先頭discのもの

SCE 品番は弊社発売決定予備会議（マスタ出稿の約 3 週間前）にて決定し、
各社営業ご担当へ通知します。それを元に次のように決定してください。


	例：商品コードが「SLPS-00001」の場合、
	    ファイル名の先頭１２文字は「BISLPS-00001」となる

	＊数字部は必ず 0 詰めで 5 桁に拡張してください。


○ ファイルヘッダ

各ファイルの先頭には次のヘッダを必ず配置してください。

 ==============================================================
	項目			サイズ（バイト）
 --------------------------------------------------------------
	ヘッダー                128 
               	Magic           	2（常に'SC'）
               	Type              	1
               	スロット数            	1
       	      	文書名            	64（シフトJIS、＊１）
              	pad             	28
               	CLUT             	32
 ..............................................................
      	アイコンイメージ (1)    128 (16 x 16 x 4 bits)
       	アイコンイメージ (2)    128（Type==0x12,0x13のみ）
       	アイコンイメージ (3)	128（Type==0x13のみ）
 ..............................................................
       	データ                  任意 (128B x N)
 --------------------------------------------------------------
	*1：非漢字および第一水準漢字のみ、全角３２文字。

              ===============================
		Type    アイコンイメージ数
			（自動差し替えアニメ）
	      -------------------------------
        	0x11    1
        	0x12    2
        	0x13    3
	      -------------------------------


○ 書き込みデータの内容保障

データ書き込み中のリセットやカード抜きとり・電源オフによるデータ破壊へ
の対策はアプリケーション側で実施してください。


  例：書き込みデータを 2 重化。書き込みは交互に行なう。
      また、各セクタの最終バイトは自身のチェックサムを付加する。
      読みとり時にチェックサムテストを行ない、エラー検出時はもうひと
      つのデータセットを使用する。

    ＊ファイルシステムの代替セクタ機能はカード内メモリの書き込みエラー
      にのみ有効です。


○ 通信エラー対応

静電放電や電源ノイズによりカード接続やアクセスプログラムが正常であるに
もかかわらずアクセスが失敗する場合があります。カードの有無のテストや書
き込み、読みとりについてはリトライ（1〜 2秒間）実施をお願いします。


［コーディング上の注意点］

・_card_info()の前に_new_card()をコールしてEvSpNEWイベントを抑制しない
  でください。デバッギングステーションとその他のシステムでの挙動が異
  なってしまいます。

・card.objは内部でlibapi.lib中の_card_write()をコールします。同名の関
  数は作成しないでください。


［既知のバグ］

○ すべてのシステムに発生するバグ。

・open()によりファイルを生成した場合は直ちにclose()をコールしてファイ
  ルをクローズしてください。そのままread()やwrite()を発行するとエラー
	  となります。

・read()とwrite()による非同期アクセスではファイルポインタが128バイト少
  なく更新されます。lseek()による修正が必要です。

・メモリカードＡ（向かって左）についてタイムアウトイベントが発生した
  フレーム中ではコントローラＡ（向かって左）へのアクセスが失敗し、
  全ボタンが「リリース」状態となる。


  ＜差し込み口Ａにカードがセットされていない場合に問題が発生＞

	垂直同期 --------------------------------------------------
			_card_info(0x00)など非同期アクセス要求
			pad = PadRead();    /* 正常 */

	垂直同期 --------------------------------------------------
			カードＡへ通信開始
			pad = PadRead();    /* 正常 */

	垂直同期 --------------------------------------------------
			カードＡタイムアウトイベント発生
			pad = PadRead();    /* コンローラＡ */
					    /* 全ボタンリリース */

	垂直同期 --------------------------------------------------
			pad = PadRead();    /* 正常 */

	垂直同期 --------------------------------------------------


★対策
  カードＡへの非同期アクセスを行なう場合は、コントローラがオペレータ
  の意図に反して全ボタンリリースとなっても問題が発生しないよう設計変更
  していただく、もしくはカードＢ（向かって右）を使用するようお願いしま
  す。


○ デバッギングステーションにおける不具合

・デバッギングステーションにおきまして、libapi.lib中の_card_clear()関数
  の誤動作が確認されています。またこれに関連して、OSD中のdeleteメニュー
  が完全に正常終了しいません。

★対策
  この関数が使用するブートROM中のイベントハンドラのバグです。ゲーム実
  機およびパッチ後のPSボードでは問題ありませんが、タイトル開発への支障
  を最小限にとどめるため、card.objによりバグフィックした_card_clear()
  を供給しています。


○関連関数

＜card.obj中の関連関数＞

・使用イベント

	原因ディスクリプタ:	HwCARD

	イベント種別:		EvSpIOE		処理完了
				EvSpERROR	カード不良
				EvSpTIMOUT	カード無し

	自動的なクリア		この原因ディスクリプタに関するイベント
				は垂直同期割り込み毎に自動的にクリアさ
				れます。よって VSync() など垂直同期を
				待つ関数をはさんでイベント発生のテスト
				を行なうと、イベント発生を検出できない
				状態に陥ります。


【関数】

_card_clear
────────────────────────────────────

        形式    long _card_clear( chan )
                long chan;

	引数	chan	ポート番号＊１６＋カード番号
			ポート番号:	Ａポート→０  Ｂポート→１
			カード番号:	通常０


        解説    ダミー書き込みをカードのシステム管理領域に行ない、「接
		続後書き込みなし」状態をクリアする。
                関数自体は非同期処理のため、直ちに終了する。同一のカー
		ド差し込み口への多重処理登録は行なえない。処理の完了は
		イベントで通知する。

               ===========================================================
                原因ディスクリプタ／イベント種別        内容
               -----------------------------------------------------------
                HwCARD/EvSpIOE                          処理完了
                HwCARD/EvSpTIMOUT                       接続されていない
                HwCARD/EvSpERROR                        通信エラー発生
               -----------------------------------------------------------

        返り値  処理登録に成功すると1を、以外は0を返す。



＜libapi.lib中の関連関数＞

当該ライブラリファイルには_card_clear()が重複して含まれいますが、リン
クしないでください。


・使用イベント

	原因ディスクリプタ:	SwCARD、HwCARD

	イベント種別:		EvSpIOE		処理完了
				EvSpERROR	カード不良
				EvSpTIMOUT	カード無し
				EvSpNEW		新規カードまたは未初期化

【関数】

InitCARD
────────────────────────────────────

        形式    void InitCARD( val )
                long val;

        引数    val     0：コントローラとの併用なし  1：併用

        解説    メモリカードBIOSを初期化し停止状態とする。以降
		StartCARD()で BIOSを稼働状態にすると、_cardで始まる低
		レベルインタフェースが直接使用可能となる。
                メモリカードファイルシステムはこれらのインタフェースを
		内部で使用するので、_bu_init()の前にこの関数を実行する
		必要がある。
                コントローラには影響を与えない。

        返り値  なし


StartCARD
────────────────────────────────────

        形式    void StartCARD( void )

        引数    なし

        解説    InitCARD()で初期化したメモリカードBIOSを稼働状態に移行
		する。
                コントローラには影響を与えない。

        返り値  なし


StopCARD
────────────────────────────────────

        形式    void StopCARD( void )

        引数    なし

        解説    メモリカードBIOSを停止状態（InitCARD()実行直後と同じ状
		態）に移行する。
                コントローラには影響を与えない。

        返り値  なし


_bu_init
────────────────────────────────────

        形式    void _bu_init( void )

        引数    なし

        解説    メモリカードファイルシステムを初期化する。
                ファイルシステムドライバは当パッチモジュール組み込み時
		にカーネルに登録するが、初期化ルーチンは自動実行しない。
		この関数により明示的にファイルシステムを初期化する必要
		がある。

        返り値  なし


_card_info	カードの状態を取得
────────────────────────────────────

	形式	long _card_info( chan )
		long chan;

	引数	chan	ポート番号＊１６＋カード番号
			ポート番号:	Ａポート→０  Ｂポート→１
			カード番号:	通常０

        解説    chanで指定したメモリカードの接続をテストする。
                関数自体は非同期処理のため、直ちに終了する。同一のカード差し
                込み口への多重処理登録は行なえない。処理の完了はイベントで通
                知。

               ===========================================================
                原因ディスクリプタ／イベント種別        内容
               -----------------------------------------------------------
                SwCARD/EvSpIOE                          接続されている
                SwCARD/EvSpTIMOUT                       接続されていない
                SwCARD/EvSpNEW                          接続後書き込みなし
                SwCARD/EvSpERROR                        通信エラー発生
               -----------------------------------------------------------

	注意	_new_card()でEvSpNEWを抑制しないでください。
		デバッギングステーションと他のシステムで挙動が食い違います。

        返り値  処理登録に成功すると1を、以外は0を返します。


_card_load
────────────────────────────────────

        形式    long _card_load( chan )
                long chan;

	引数	chan	ポート番号＊１６＋カード番号
			ポート番号:	Ａポート→０  Ｂポート→１
			カード番号:	通常０

        解説    入出力管理サービスによる非同期アクセスのためにファイル
		システムにファイル管理情報を読み込む。O_NOWAITモードで
		メモリカード上のファイルをオープンする前に必ず実行する
		必要がある。カードが入れ替わらない限り反復して実行する
		必要はない。 関数自体は非同期処理のため、直ちに終了す
		る。同一のカード差し込み口への多重処理登録は行なえない。
		処理の完了はイベントで通知する。所要時間は７２VSYNC。
		O_NOWAITモードのopen()を行なう前に必ず１度実行する。

               ===========================================================
                原因ディスクリプタ／イベント種別        内容
               -----------------------------------------------------------
                SwCARD/EvSpIOE                          読み込み完了
                SwCARD/EvSpTIMOUT                       接続されていない
                SwCARD/EvSpNEW                          未初期化カード
                SwCARD/EvSpERROR                        通信エラー発生
               -----------------------------------------------------------

        返り値  処理登録に成功すると1を、以外は0を返す。


_card_auto	自動初期化設定
────────────────────────────────────

	形式	long _card_auto( val )
		long val;

	引数	val	0:自動初期化禁止  1:自動初期化許可

	解説	自動初期化機能の有無を設定する。

	返り値	なし



_new_card
────────────────────────────────────

        形式    void    _new_card( void )

        引数    なし

        解説    直後の_card_read()または_card_write()でのEvSpNEWイベン
		トの発生をマスクする。
                同期処理関数だが直ちに終了する。

        返り値  なし


_card_status
────────────────────────────────────

        形式    long _card_status( drv )
                long drv;

        引数    drv     差し込み口番号  0：向かって左  1：向かって右

        解説    差し込み口毎のメモリカードBIOSステータスを取得する。
                同期処理関数だが直ちに終了する。

        返り値  メモリカードBIOSが稼働状態にあれば、次のいずれかの値を返す。


                =================================================
                 値      状態
                -------------------------------------------------
                 0x01    登録処理なし
                 0x02    READ処理登録あり
                 0x04    WRITE処理登録あり
                 0x08    接続テスト処理登録あり
                 0x11    登録処理なし（直前にタイムアウト発生）
                 0x21    登録処理なし（直前に通信エラー発生）
                -------------------------------------------------

_card_wait
────────────────────────────────────

        形式    long _card_status( drv )
                long drv;

        引数    drv     差し込み口番号  0：向かって左  1：向かって右

        解説    drvで指定する差し込み口宛の登録処理がなくなるまで待つ。


        返り値  常に1を返す。


_card_chan
────────────────────────────────────

        形式    long _card_chan( void )

        引数    なし

        解説    直前にイベントを発生したメモリカードのデバイス番号を返
		す。オープンやテストの有無に関わらず、何らかのイベント
		が発生すると返り値が変更される。（通常はVBLANKの中頃、
		カードがセットされていないチャネルでは次のVBLANKでの
		BIOS起動後、にそれぞれイベントが発生。）

        返り値  16進2桁のデバイス番号


_card_write     メモリカードの1ブロックへの書き込み
────────────────────────────────────

        形式    long _card_write( chan, block, buf )

        引数    chan    ポート番号＊１６＋カード番号
                        ポート番号:     Ａポート→０  Ｂポート→１
                        カード番号:     通常０
                block   ターゲットブロック番号
                buf     128バイトのデータバッファへのポインタ

        解説    chanで指定したメモリカードのblock番ブロックにbufがポイ
		ントする 128バイトデータを書き込む。
                関数自体は非同期処理のため、直ちに終了する。同一のカー
		ド差し込み口への多重処理登録は行なえない。処理の完了は
		イベントで通知。

		＊低レベルインタフェースです。テストなど特殊な用途にの
		  み使用します。

               ===========================================================
                原因ディスクリプタ／イベント種別        内容
               -----------------------------------------------------------
                HwCARD/EvSpIOE                          処理完了
                HwCARD/EvSpTIMOUT                       カード未接続
                HwCARD/EvSpNEW                          新規カード検出
                HwCARD/EvSpPERROR                       通信エラー発生
                HwCARD/EvSpERROR                        書き込みエラー発生
                HwCARD/EvSpUNKOWN                       原因不明
               -----------------------------------------------------------

        返り値  処理登録に成功すると1を、以外は0を返す。


_card_read      メモリカードの1ブロックの読み込み
────────────────────────────────────

        形式    long _card_read( chan, block, buf )

        引数    chan    ポート番号＊１６＋カード番号
                                ポート番号:     Ａポート→０  Ｂポート→１
                                カード番号:     通常０
                block   ターゲットブロック番号
                buf     128バイトのデータバッファへのポインタ

        解説    chanで指定したメモリカードのblock番ブロックの内容をbuf
		がポイントする128バイトバッファに読み込む。
                関数自体は非同期処理のため、直ちに終了する。同一のカー
		ド差し込み口への多重処理登録は行なえない。処理の完了は
		イベントで通知。

		＊低レベルインタフェースです。テストなど特殊な用途にの
		  み使用します。

               ===========================================================
                原因ディスクリプタ／イベント種別        内容
               -----------------------------------------------------------
                HwCARD/EvSpIOE                          処理完了
                HwCARD/EvSpTIMOUT                       カード未接続
                HwCARD/EvSpNEW                          新規カード検出
                HwCARD/EvSpPERROR                       通信エラー発生
                HwCARD/EvSpUNKOWN                       原因不明
               -----------------------------------------------------------

        返り値  処理登録に成功すると1を、以外は0を返す。


【サンプルプログラム】

・同期型カードアクセス例


#incldue <sys/file.h>

char data[0x1000];
char buf[0x1000];

main()
{
        long fd;

         /* ドライバの初期化*/
        InitCARD(0);    /* コントローラとの共存なし */
        StartCARD();
        _bu_init();


        /* ポートA上のカードのファイルL01を削除 */
        pritf("delete\n");
        delete("bu00:L01");


        /* 2スロット長のファイルL01をポートA上のカードに新規作成 */
        printf("create\n");
        if((fd=open("bu00:L01",O_CREAT|(2<<16)))==-1)
                printf("error\n");
        close(fd);
        /* 生成後は必ず１度クローズしてください */


        /* １０セクタ書き込み */
        printf("write\n");
        if((fd=open("bu00:L01",O_WRONLY))==-1)
                printf("error 1a\n");
        if(write(fd, &data[0] , 10*128)!=10*128)
                printf("error 1b\n");
        close(fd);


        /* ３０セクタ読み込み */
        printf("read\n");
        if((fd=open("bu00:L01",O_RDONLY))==-1)
                printf("error 1a\n");
        if(read(fd, &buf[0] , 30*128)!=30*128)
                printf("error 2b\n");
        close(fd);
}



・セクタチェックサム例

/*
 * test check sum for 128byte block
 * return       1:OK
 *              0:NG
*/
_test_csum(buf)
unsigned char *buf;
{
        long i;
        unsigned char c;

        c = 0x00;
        for(i=0;i<127;i++)

                c ^= *buf++;
        if(*buf==c)
                return 1;
        return 0;
}


/* set check sum to the last byte of 128byte block */
_set_csum(buf)
unsigned char *buf;
{
        long i;
        unsigned char c;

        c = 0x00;
        for(i=0;i<127;i++)
                c ^= *buf++;
        *buf = c;
}


/* sample data strucure */
struct SDB {
        char name[8];
        long size,attr,sector,mode;
}


/* common load buffer */
unsigned char load_buf[1024];


/* get data from memory card with check-sum test */
get(num,data)
long num;
struct SDB *data;
{
        long i,fd;

        if((fd=open("bu00:L01",O_WRONLY))<0)
                return 0;
        memcpy(&load_buf[0],data,sizeof(struct SDB));
        _set_csum(&load_buf[0]);
        i = write(fd,&load_buf[0],128);
        close(fd);

        close(fd);
        return (i==128)?1:0;
}


/* get data from memory card with check-sum test */
get()
{
        long i,fd;

        if((fd=open("bu00:L01",O_RDONLY))<0)
                return 0;
        if(read(fd,&load_buf[0],1024)!=1024) {
                close(fd);
                return 0;
        }

        for(i=0;i<8;i++)
                if(_test_csum(&load_buf[128*i])==1)
                        memcpy(&data[i],&load_buf[128*i],sizeof(struct SDB));
                else
                        memset(&data[i],0xff,sizeof(struct SDB));
        close(fd);
        return 1;
}


** コントローラについて

○ アクセス方法

コントローラには次の２通りのアクセスパスがあります。

	(A) 受信データを直接処理する。
	(B) 従来の周辺機器ライブラリlibetcと互換のインタフェース。

マウスやアナログコントローラなど複数タイプの端末に対応するためには、上
記(A)を採用する必要があります。この場合の初期化手順は次のようになりま
す。なおbuf0とbuf1はそれぞれlen0、len1バイト長のバッファとして確保して
おきます。これ以外の関数呼び出しは不要です。

		/* 初期化手順 */
		InitPAD(buf0,len0,buf1,len1);
		StartPAD();

この処理により垂直同期割り込みをトリガとしたコントローラポートへの自動
アクセスが始まり、buf0とbuf1に受信データが格納されるようになります。受
信バッファの内容を直接テストすることにより、デバイスの有無およびその状
態を知ることができます。


○ バッファデータ形式

アクセス方法(A)を実現するために必要なバッファデータ形式を以下に示します。

バッファの第1バイトの上位4ビットは端末種別、下位4ビットは端末らの受信
データ（バッファの第3バイト以降に格納される。）のバイト数の半分の値、
となります。


	受信バッファデータ形式
       ============================================================
	バイト		内容
       ------------------------------------------------------------
	0		受信結果  0:成功 0xff:失敗
	1		上位4ビット：端末種別
                                     0x1:マウス
		                     0x2:16ボタンアナログ
			             0x4:16ボタン
			             0x8:マルチタップ
			下位4ビット：受信データバイト数／２
	2		             0x01:マルチタップ  0x00:以外
		＜16ボタン＞
	3,4		ボタン状態  1:リリース  0:プッシュ
		＜マウス＞
	3		ボタン状態  1:リリース  0:プッシュ
				    第2ビット：右  第3ビット：左
	4		移動量  X方向  -128〜127
	5		同上    Y方向  同上
	6		同上    Z方向  同上
	7,8,-		同上    ?方向  同上
		＜16ボタンアナログ＞
	3,4		ボタン状態  1:リリース  0:プッシュ
	5,6,-		アナログチャネル値
		＜マルチタップ＞     →現在調整中。
       ------------------------------------------------------------

＊ボタンやチャネルなどの物理的な配置や対応は各端末のドキュメントを参照
  してください。



○ 既存端末の型

標準コントローラは 16 ボタン型端末です。
弊社から商品化されているマウスは、XとYの 2 方向だけをサポートするマウ
ス型端末。また株式会社ナムコ様の「ネジコン」は、4 チャネル、つまりバッ
ファ第 1 バイトの下位 4 ビットが 3（（ボタン分 2 バイト＋4 チャネル分 
4 バイト）÷ 2 ）、の 16 ボタンアナログ型端末です。


○ 使用例

現在マウスに対するアクセス方法(A)の例をサンプルプログラムとして供給し
ています。



** Exec 関連の処理とスタックポインタについて

○ スタックポインタの設定

libsn.lib は PCファイルシステム関連の関数を使用するに当たって有用なだ
けでなく、データ領域のクリアやスタックポインタの設定など、main の前に
行なわれる処理ルーチンを含んでおり、ccpsx を始めとした一連の手続きを
行なって生成されたファイルはかならずこの部分 ( __main)を含むことになり
ます。libsn.lib は H2000 のディップスイッチを読み、可能な限り奥深くに
スタックをとりますのでこれを 2MB,8MB で使い分けることができるようにし
たのが 2MByte.OBJ および 8MByte.OBJ です。

ここで問題になるのは「実行ファイルを呼び出し、その実行が終ると呼び出し
側プロセスに帰ってくる」ような処理をしたい場合です。呼び出される側の実
行プログラムのスタックポインタの値はリンカファイルをちゃんと書かないと
決定できない上、Exec 構造体にその数値を入れたところで main の事前処理
でこの設定が無効になってしまいます。

つまり「呼び出した側のスタック内容を呼び出された側ののプログラムが破壊
してしまうため、呼び出された側のプログラムが終了し、復帰しようとした時
には復帰するためのアドレス情報がないためハングアップしてしまう」のです。
呼び出される側のプログラムは 2MBytes.OBJ,8MBytes.OBJ,libsn.lib のいずれ
にも依存しない main の前処理が必要になります。それは「スタックの設定は
何もしない」という前処理です。

呼び出される側（そして復帰が予定されている）プログラムは NONE.OBJ をリ
ンクすることによって、この条件を満たすことができます。使用方法は 
2MByte.OBJ と全く同じです。
