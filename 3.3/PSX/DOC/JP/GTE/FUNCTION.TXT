$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
============================================================================

			libgte リファレンスマニュアル 

		記号

		RTM:回転マトリックス
		LLM:ローカルライトマトリックス
		LCM:ローカルライトマトリックス
		LLV:ローカルライトベクトル
		LC: ローカルカラー
		BK: バックカラー
		FC: ファーカラー
		BG: ＢＧカラー

============================================================================
*１．初期設定

InitGeom 	GTEの初期化を行なう

    形式	void InitGeom()

    解説	GTEの初期化を行なう。最初に１回コールする。

    返り値	なし
		
		

*２．マトリックス演算

**2.1.
MulMatrix0	２つのマトリクスの積をとる	

    形式	MATRIX* MulMatrix0(m0,m1,m2)
		MATRIX *m0,*m1;		/*入力:マトリックス*/
		MATRIX *m2;		/*出力:マトリックス*/

    解説	２つのマトリクスm0,m1の積をとる。値はm2に格納する。
		<引数フォーマット>
		m0,m1,m2->m[i][j] : (1,3,12)
		<注意>
		回転マトリックスをこわす。

    返り値	m2
		

**2.1.1.
MulRotMatrix0	定数回転マトリクスとマトリクスの積をとる	

    形式	MATRIX* MulRotMatrix0(m0,m1)
		MATRIX *m0;		/*入力:マトリックス*/
		MATRIX *m1;		/*出力:マトリックス*/

    解説	定数回転マトリクスとマトリクスm0の積をとる。値はm1に格納する。
		<引数フォーマット>
		m0,m1->m[i][j] : (1,3,12)

    返り値	m1

**2.2. 
MulMatrix	２つのマトリクスの積をとる

    形式	MATRIX* MulMatrix(m0,m1)
		MATRIX *m0,*m1;	/*入出力:マトリックス*/

    解説	２つのマトリクスの積をとる。値はm0に格納する。
		<引数フォーマット>
		m0,m1->m[i][j] : (1,3,12)
		<注意>
		回転マトリックスをこわす。

    返り値	m0
		

**2.3. 
MulMatrix2	２つのマトリクスの積をとる

    形式	MATRIX* MulMatrix2(m0,m1)
		MATRIX *m0,*m1;	/*入出力:マトリックス*/

    解説	２つのマトリクスの積をとる。値はm1に格納する。
		<引数フォーマット>
		m0,m1->m[i][j] : (1,3,12)
		<注意>
		回転マトリックスをこわす。

    返り値	m1
		

**2.3.1. 
MulRotMatrix	定数回転マトリクスとマトリクスの積をとる

    形式	MATRIX* MulRotMatrix(m0)
		MATRIX *m0;	/*入出力:マトリックス*/

    解説	定数回転マトリクスとマトリクスの積をとる。値はm0に格納する。
		<引数フォーマット>
		m0->m[i][j] : (1,3,12)

    返り値	m0
		

**2.3.2. 
SetMulMatrix	２つのマトリクスの積をとり定数回転マトリクスに設定する

    形式	MATRIX* SetMulMatrix(m0,m1)
		MATRIX *m0,*m1;	/*入力:マトリックス*/

    解説	２つのマトリクスの積をとる。値は定数回転マトリクスに格納する。
		<引数フォーマット>
		m0,m1->m[i][j] : (1,3,12)

    返り値	m0
		

**2.4. 
ApplyMatrix	ベクトルにマトリクスを乗算する

    形式	VECTOR* ApplyMatrix(m,v0,v1)
		MATRIX *m;	/*入力:被乗算マトリックス*/
		SVECTOR *v0;	/*入力:ショートベクトル*/
		VECTOR *v1;	/*出力:ベクトル*/

    解説	マトリクス m にショートベクトル v0 を右側から乗算し、
		結果をベクトル v1 に格納する。
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		v0->vx,vy,vz :(1,15,0)
		v1->vx,vy,vz :(1,31,0)
		<注意>
		回転マトリックスをこわす。

    返り値	v1
		

**2.4.1. 
ApplyRotMatrix	ベクトルに定数回転マトリクスを乗算する

    形式	VECTOR* ApplyRotMatrix(v0,v1)
		SVECTOR *v0;	/*入力:ショートベクトル*/
		VECTOR *v1;	/*出力:ベクトル*/

    解説	定数回転マトリクス にショートベクトル v0 を右側から乗算し、
		結果をベクトル v1 に格納する。
		<引数フォーマット>
		v0->vx,vy,vz :(1,15,0)
		v1->vx,vy,vz :(1,31,0)

    返り値	v1
		

**2.4.2 
ApplyMatrixSV	ベクトルにマトリクスを乗算する

    形式	SVECTOR* ApplyMatrixSV(m,v0,v1)		      
		MATRIX *m;	/*入力:被乗算マトリックス*/
		SVECTOR *v0;	/*入力:ショートベクトル*/     
		SVECTOR *v1;	/*出力:ショートベクトル*/     

    解説	マトリクス m にショートベクトル v0 を右側から乗算し、
		結果をショートベクトル v1 に格納する。
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		v0->vx,vy,vz :(1,15,0)
		v1->vx,vy,vz :(1,15,0)
		<注意>
		回転マトリックスをこわす。

    返り値	v1

**2.4.3 
ApplyMatrixLV	ベクトルにマトリクスを乗算する

    形式	VECTOR* ApplyMatrixLV(m,v0,v1)
		MATRIX *m;	/*入力:被乗算マトリックス*/
		VECTOR *v0;	/*入力:ベクトル*/
		VECTOR *v1;	/*出力:ベクトル*/

    解説	マトリクス m にベクトル v0 を右側から乗算し、
		結果をベクトル v1 に格納する。
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		v0->vx,vy,vz :(1,31,0)
		v1->vx,vy,vz :(1,31,0)
		<注意>
		回転マトリックスをこわす。

    返り値	v1
		

**2.4.4 
ApplyTransposeMatrixLV	ベクトルにマトリクスを乗算する

    形式	VECTOR* ApplyTransposeMatrixLV(m,v0,v1)
		MATRIX *m;	/*入力:被乗算マトリックス*/
		VECTOR *v0;	/*入力:ベクトル*/
		VECTOR *v1;	/*出力:ベクトル*/

    解説	マトリクス m を転値したものにベクトル v0 を右側から乗算し、
		結果をベクトル v1 に格納する。
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		v0->vx,vy,vz :(1,31,0)
		v1->vx,vy,vz :(1,31,0)
		<注意>
		回転マトリックスをこわす。

    返り値	v1
		

**2.5. 
RotMatrix	回転角から回転マトリックスを求める

    形式	MATRIX* RotMatrix(r,m)
		MATRIX *m;	/*出力:回転マトリックス*/
		SVECTOR *r;	/*入力:回転角*/

    解説	マトリックスmに、回転角(r[0],r[1],r[2])による
		回転行列を与える。回転角は 4096 を 360度として
		あたえ、マトリックス成分は 4096 が 1.0 として与えられる。
		マトリックスは次の積を展開したものである。ＧＴＥの
		座標変換関数（RotTransPersなど）では右側からベクトルを
		かけるので、Ｚ軸、Ｙ軸、Ｘ軸まわりの順に回転することになる。
		
		[  1,  0,  0] [ c1,  0, s1] [ c2,-s2,  0]
		[  0, c0,-s0]*[  0,  1,  0]*[ s2, c2,  0]
		[  0, s0, c0] [-s1,  0, c1] [  0,  0,  1]
		
		ただし、c0=cos(r[0]), s0=sin(r[0])
		c1=cos(r[1]), s1=sin(r[1])
		c2=cos(r[2]), s2=sin(r[2])
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		r->vx,vy,vz :(1,3,12) （ただし360度を1.0とする）
		
		<注意>		      
		RotMatrix_C とすると小テーブル、低速となる。		      

    返り値	m
		

**2.5.1.
RotMatrixYXZ	回転角から回転マトリックスを求める

    形式	MATRIX* RotMatrixYXZ(r,m)
		MATRIX *m;	/*出力:回転マトリックス*/
		SVECTOR *r;	/*入力:回転角*/

    解説	マトリックスmに、回転角(r[0],r[1],r[2])による
		回転行列を与える。回転角は 4096 を 360度として
		あたえ、マトリックス成分は 4096 が 1.0 として与えられる。
		マトリックスは次の積を展開したものである。ＧＴＥの
		座標変換関数（RotTransPersなど）では右側からベクトルを
		かけるので、Ｚ軸、Ｘ軸、Ｙ軸まわりの順に回転することになる。
		
		[ c1,  0, s1] [  1,  0,  0] [ c2,-s2,  0]
		[  0,  1,  0]*[  0, c0,-s0]*[ s2, c2,  0]
		[-s1,  0, c1] [  0, s0, c0] [  0,  0,  1]
		
		ただし、c0=cos(r[0]), s0=sin(r[0])
		c1=cos(r[1]), s1=sin(r[1])
		c2=cos(r[2]), s2=sin(r[2])
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		r->vx,vy,vz :(1,3,12) （ただし360度を1.0とする）
		
		<注意>		      
		RotMatrixYXZ_C とすると小テーブル、低速となる。		      

    返り値	m
		

**2.5.2.
RotMatrixX      Ｘ軸まわりの回転マトリックスを求める

    形式	MATRIX* RotMatrixX(r,m)
		long    r;	            /*入力:回転角*/
		MATRIX *m;	            /*入出力:回転マトリックス*/

    解説	マトリックスmに、回転角 r によるＸ軸まわりの
		回転行列をかけたマトリクススを与える。回転角は 4096 を 360度と
		して
		あたえ、マトリックス成分は 4096 が 1.0 として与えられる。
		マトリックスは次のものである。
		
		[  1,  0,  0]*m
		[  0,  c, -s]
		[  0,  s,  c]
		
		ただし、c=cos(r), s=sin(r)
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		r :(1,3,12) （ただし360度を1.0とする）
		
		<注意>		      
		RotMatrixX_C とすると小テーブル、低速となる。		      

    返り値	m
		

**2.5.3.
RotMatrixY      Ｙ軸まわりの回転マトリックスを求める

    形式	MATRIX* RotMatrixY(r,m)
		long    r;	            /*入力:回転角*/
		MATRIX *m;	            /*入出力:回転マトリックス*/

    解説	マトリックスmに、回転角 r によるＹ軸まわりの
		回転行列をかけたマトリクススを与える。回転角は 4096 を 360度と
		して
		あたえ、マトリックス成分は 4096 が 1.0 として与えられる。
		マトリックスは次のものである。
		
		[  c,  0, -s]*m
		[  0,  1,  0]
		[  s,  0,  c]
		
		ただし、c=cos(r), s=sin(r)
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		r :(1,3,12) （ただし360度を1.0とする）
		
		<注意>		      
		RotMatrixY_C とすると小テーブル、低速となる。		      

    返り値	m
		

**2.5.4.
RotMatrixZ      Ｚ軸まわりの回転マトリックスを求める

    形式	MATRIX* RotMatrixZ(r,m)
		long    r;	            /*入力:回転角*/
		MATRIX *m;	            /*出力:回転マトリックス*/

    解説	マトリックスmに、回転角 r によるＺ軸まわりの
		回転行列をかけたマトリクススを与える。回転角は 4096 を 360度と
		して
		あたえ、マトリックス成分は 4096 が 1.0 として与えられる。
		マトリックスは次のものである。
		
		[  c, -s,  0]*m
		[  s,  c,  0]
		[  0,  0,  1]
		
		ただし、c=cos(r), s=sin(r)
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		r :(1,3,12) （ただし360度を1.0とする）
		
		<注意>		      
		RotMatrixZ_C とすると小テーブル、低速となる。		      

    返り値	m
		

**2.5.5.		      
RotMatrixZYX	回転角から回転マトリックスを求める	      

    形式	MATRIX* RotMatrixZYX(r,m)		      
		MATRIX *m;	/*出力:回転マトリックス*/     
		SVECTOR *r;	/*入力:回転角*/	 	      

    解説	マトリックスmに、回転角(r[0],r[1],r[2])による		      
		回転行列を与える。回転角は 4096 を 360度として		      
		あたえ、マトリックス成分は 4096 が 1.0 として与えられる。

		   
		マトリックスは次の積を展開したものである。ＧＴＥの	      
		座標変換関数（RotTransPersなど）では右側からベクトルを	      
		かけるので、Ｘ軸、Ｙ軸、Ｚ軸まわりの順に回転することになる。

		      
		
		[ c2,-s2,  0] [ c1,  0, s1] [  1,  0,  0]		      
		[ s2, c2,  0]*[  0,  1,  0]*[  0, c0,-s0]		      
		[  0,  0,  1] [-s1,  0, c1] [  0, s0, c0]		      
		
		ただし、c0=cos(r[0]), s0=sin(r[0])	      
		c1=cos(r[1]), s1=sin(r[1])	      
		c2=cos(r[2]), s2=sin(r[2])	      
		
		<引数フォーマット>			      
		m->m[i][j] : (1,3,12)			      
		r->vx,vy,vz :(1,3,12) （ただし360度を1.0とする）	      
		
		<注意>		      
		RotMatrixZYX_C とすると小テーブル、低速となる。

    返り値	m		      
		
		

**2.6. 
RotMatrixC	RotMatrixと同じ

    形式	MATRIX* RotMatrixC(r,m)
		MATRIX *m;	/*出力:回転マトリックス*/
		SVECTOR *r;	/*入力:回転角*/

    解説	必要なテーブルメモリがRotMatrix_Cより少ないが、		      
		スピードは遅い。
		

**2.7. 
TransMatrix	平行移動量を与える

    形式	MATRIX* TransMatrix(m,v)
		MATRIX	*m;	/*出力:マトリックス*/
		VECTOR	*v;	/*入力:移動ベクトル*/

    解説	マトリックス m に、vで表される平行移動量を与える。
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		m->t[i]    : (1,31,0)
		v->vx,vy,vz : (1,31,0)

    返り値	m
		

**2.8. 
ScaleMatrix	拡大率を与える

    形式	MATRIX* ScaleMatrix(m,v)
		MATRIX	*m;	/*出力:マトリックス*/
		VECTOR	*v;	/*入力:スケールベクトル*/

    解説	マトリックス m に、v で表される拡大率を与える。
		vの成分は、4096 を 1.0 とする 固定小数点数である。
		
		m =[a00,a01,a02],	v =[sx,sy,sz]
		[a10,a11,a12]
		[a20,a21,a22]		とすると
		
		m=[a00*sx,a01*sy,a02*sz]
		[a10*sx,a11*sy,a12*sz]
		[a20*sx,a21*sy,a22*sz]	となる。
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		v->vx,vy,vz : (1,3,12)

    返り値	m
		

**2.9. 
ScaleMatrixL	拡大率を与える

    形式	MATRIX* ScaleMatrixL(m,v)
		MATRIX	*m;	/*出力:マトリックス*/
		VECTOR	*v;	/*入力:スケールベクトル*/

    解説	マトリックス m に、v で表される拡大率を与える。
		vの成分は、4096 を 1.0 とする 固定小数点数である。
		
		m =[a00,a01,a02],	v =[sx,sy,sz]
		[a10,a11,a12]
		[a20,a21,a22]		とすると
		
		m=[a00*sx,a01*sx,a02*sx]
		[a10*sy,a11*sy,a12*sy]
		[a20*sz,a21*sz,a22*sz]	となる。
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		v->vx,vy,vz : (1,3,12)

    返り値	m
		

**2.10.
TransposeMatrix 転値行列を与える

    形式	MATRIX* TransposeMatrix(m0,m1)
		MATRIX  *m0;	          /*入力:マトリックス*/
		MATRIX  *m1;	          /*出力:マトリックス*/

    解説	マトリックス m0 の転値行列を m1に与える.
		
		<引数フォーマット>
		m0->m[i][j] : (1,3,12)
		m1->m[i][j] : (1,3,12)

    返り値	m1
		

**2.11.
CompMatrix 	座標変換の合成を行なう

    形式	MATRIX*	CompMatrix(m0,m1.m2)
		MATRIX  *m0;	          /*入力:マトリックス*/
		MATRIX  *m1;	          /*入力:マトリックス*/
		MATRIX  *m2;	          /*出力:マトリックス*/

    解説	平行移動を含む座標変換マトリックスの合成を行なう
		[m2->m] = [m0->m] * [m1->m]
		(m2->t) = [m0->m] * (m1->t) + (m0->t)	
		ただしm1->tの成分の値は[-2^15,2^15)の範囲でなければならない
		
		<引数フォーマット>
		m0->m[i][j] : (1,3,12)
		m0->t[i]    : (1,31,0)
		m1->m[i][j] : (1,3,12)
		m1->t[i]    : (1,15,0)
		m2->m[i][j] : (1,3,12)
		m2->t[i]    : (1,31,0)
		
		<注意>
		回転マトリックスをこわす。

    返り値	m2
		

**2.12.
MatrixNormal 	マトリックスの正規化を行なう

    形式	void	MatrixNormal(m,n)
		MATRIX  *m;	          /*入力:マトリックス*/
		MATRIX  *n;	          /*出力:マトリックス*/

    解説	歪んだ回転マトリックスを正規直交した回転マトリックスに
		変換する。 (＊m[2][0],m[2][1],m[2][2]は無視される。)
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		n->m[i][j] : (1,3,12)
		

    返り値	なし
		

**2.12.1
MatrixNormal_1 	マトリックスの正規化を行なう

    形式	void	MatrixNormal(m,n)
		MATRIX  *m;	          /*入力:マトリックス*/
		MATRIX  *n;	          /*出力:マトリックス*/

    解説	歪んだ回転マトリックスを正規直交した回転マトリックスに
		変換する。(＊m[0][0],m[0][1],m[0][2]は無視される。)
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		n->m[i][j] : (1,3,12)
		

    返り値	なし
		

**2.12.2
MatrixNormal_2 	マトリックスの正規化を行なう

    形式	void	MatrixNormal(m,n)
		MATRIX  *m;	          /*入力:マトリックス*/
		MATRIX  *n;	          /*出力:マトリックス*/

    解説	歪んだ回転マトリックスを正規直交した回転マトリックスに
		変換する。(＊m[1][0],m[1][1],m[1][2]は無視される。)
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		n->m[i][j] : (1,3,12)
		

    返り値	なし
		
		

*３．マトリックス設定

**3.1 
SetRotMatrix	回転マトリックスを設定する

    形式	void SetRotMatrix(m) 
		MATRIX *m;	/*入力:マトリックス*/

    解説	mで与えられる回転マトリックスを設定する。
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)

    返り値	なし
		

**3.2. 
SetLightMatrix	ローカルライトマトリックスを設定する

    形式	void SetLightMatrix(m)
		MATRIX *m;	/*入力:マトリックス*/

    解説	mで与えられるローカルライトマトリックスを設定する。
		
		<引数フォーマット>
		m->m[i][j] : (1,3,12)

    返り値	なし
		

**3.3. 
SetColorMatrix	ローカルカラーマトリックスを設定する

    形式	void SetColorMatrix(m)
		MATRIX *m;	/*入力:マトリックス*/

    解説	mで与えられるローカルカラーマトリックスを設定する。
		<引数フォーマット>
		m->m[i][j] : (1,3,12)

    返り値	なし
		

**3.4. 
SetTransMatrix	平行移動ベクトルを設定する

    形式	void SetTransMatrix(m)
		MATRIX *m;	/*入力:マトリックス*/
		

    解説	mで与えられる平行移動ベクトルを設定する。
		<引数フォーマット>
		m->t[i] : (1,31,0)

    返り値	なし
		

**3.5. 
PushMatrix	回転マトリックスをスタックに退避する

    形式	void PushMatrix()

    解説	回転マトリックスをスタックに退避する。
		スタックは２０段まで。

    返り値	なし
		

**3.6. 
PopMatrix	回転マトリックスをスタックから再設定する

    形式	void PopMatrix()

    解説	回転マトリックスをスタックから再設定する。

    返り値	なし
		
		

*４．マトリックス読みだし

**4.1. 
ReadRotMatrix	回転マトリックスを読み出す

    形式	void ReadRotMatrix(m)
		MATRIX *m;	/*出力:マトリックス*/

    解説	設定された回転マトリックスを読みだし m に格納する。
		<引数フォーマット>
		m->m[i][j] : (1,3,12)
		m->t[i] : (1,31,0)

    返り値	なし
		

**4.2. 
ReadLightMatrix	ローカルライトマトリックスを読み出す

    形式	void ReadLightMatrix(m)
		MATRIX *m;	/*出力:マトリックス*/

    解説	設定されたローカルライトマトリックスを読みだし m に格納する。
		<引数フォーマット>
		m->m[i][j] : (1,3,12)

    返り値	なし
		

**4.3. 
ReadColorMatrix	ローカルカラーマトリックスを読み出す

    形式	void ReadColorMatrix(m)
		MATRIX *m;	/*出力:マトリックス*/

    解説	設定されたローカルカラーマトリックスを読みだし m に格納する。
		<引数フォーマット>
		m->m[i][j] : (1,3,12)

    返り値	なし
		
		

*５．ベクトル設定

**5.5.
SetRGBcd        原色ベクトルとＧＰＵコードを設定する

    形式	void SetRGBcd(v)
		CVECTOR *v;	   /*入力:色ベクトル、ＧＰＵコード*/

    解説	原色ベクトルとＧＰＵコード v を設定する。
		<引数フォーマット>
		v->r,g,b,cd : (0,8,0)

    返り値	なし
		

**5.9. 
SetBackColor	バックカラーベクトルを設定する

    形式	void SetBackColor(rbk,gbk,bbk)
		long rbk,gbk,bbk;		/*入力:ベクトル*/

    解説	バックカラーベクトル (rbk,gbk,bbk) を設定する。
		カラー値は０〜２５５（ＭＡＸ）である。
		<引数フォーマット>
		(rbk,gbk,bbk) : (0,32,0) 

    返り値	なし
		

**5.10. 
SetFarColor	ファーカラーベクトルを設定する

    形式	void SetFarColor(rfc,gfc,bfc)
		long rfc,gfc,bfc;		/*入力:ベクトル*/

    解説	ファーカラーベクトル (rfc,gfc,bfc) を設定する。
		カラー値は０〜２５５（ＭＡＸ）である。
		<引数フォーマット>
		(rfc,gfc,bfc) : (0,32,0) 

    返り値	なし
		
		
		

**5.17. 
SetGeomOffset	オフセット値を設定する

    形式	void SetGeomOffset(ofx,ofy)
		long ofx,ofy;	/*入力値*/

    解説	オフセット値 (ofx,ofy) を設定する。
		<引数フォーマット>
		ofx,ofy : (1,31,0)

    返り値	なし
		

**5.18. 
SetGeomScreen	視点からスクリーンまでの距離を設定する

    形式	void SetGeomScreen(h)
		long h;		/*入力値*/

    解説	視点からスクリーンまでの距離 h を設定する。
		<引数フォーマット>
		h : (0,32,0)

    返り値	なし
		
		

*６．ベクトル読みだし



**6.4. 
ReadSZfifo3     ＳＺ値を読みだす	      

    形式	void ReadSZfifo3(sz0,sz1,sz2)		      
		long *sz0,*sz1,*sz2;               /*出力値*/		      

    解説	RotTransPers3などで計算したスクリーンＺ値を読みだす。	      
		RotTransPers3(v0,v1,v2,..)		      
		または		      
		RotTransPers(v0,..)			      
		RotTransPers(v1,..)			      
		RotTransPers(v2,..)			      
		を実行したとき	      
		v0 -> sz0	      
		v1 -> sz1	      
		v2 -> sz2	      
		という対応になる。			      
		
		<引数フォーマット>			      
		(sz0,sz1,sz2) : (0,16,0)		      

    返り値	なし		      
		

**6.5. 
ReadSZfifo4     ＳＺ値を読みだす	      

    形式	void ReadSZfifo4(sz0,sz1,sz2,sz3)	      
		long *sz0,*sz1,*sz2,*sz3;               /*出力値*/	      

    解説	RotTransPers4などで計算したスクリーンＺ値を読みだす。	      
		RotTransPers4(v0,v1,v2,v3,..)		      
		または		      
		RotTransPers(v0,..)			      
		RotTransPers(v1,..)			      
		RotTransPers(v2,..)			      
		RotTransPers(v3,..)			      
		を実行したとき	      
		v0 -> sz0	      
		v1 -> sz1	      
		v2 -> sz2	      
		v3 -> sz3	      
		という対応になる。			      
		
		<引数フォーマット>			      
		(sz0,sz1,sz2,sz3) : (0,16,0)		      

    返り値	なし		      
		

**6.6. 
ReadSXSYfifo	ＳＸＳＹ値を読みだす

    形式	void ReadSXSYfifo(sxy0,sxy1,sxy2)
		long *sxy0,*sxy1,*sxy2;		/*出力値*/

    解説	sx0,sy0,sx1,sy1,sx2,sy2値をsxy0,sxy1,sxy2に読みだす。
		<引数フォーマット>
		(sxy0,sxy1,sxy2) : (1,15,0)

    返り値	なし
		

**6.7. 
ReadRGBfifo	RGBcd値を読みだす

    形式	void ReadRGBfifo(v0,v1,v2)
		CVECTOR *v0,*v1,*v2;		/*出力:ベクトル*/

    解説	RGBcd0,RGBcd1,RGBcd2値を v0,v1,v2 に読みだす。
		<引数フォーマット>
		v0,v1,v2->r,g,b,cd : (0,8,0)

    返り値	なし
		

**6.13.
ReadGeomOffset	ＧＴＥオフセット値を読みだす

    形式	void ReadGeomOffset(ofx,ofy)
		long *ofx,*ofy;

    解説	ＧＴＥオフセット値を読みだす。
		<引数フォーマット>
		ofx,ofy : (0,32,0)

    返り値	なし
		

**6.14. 
ReadGeomScreen	視点からスクリーンまでの距離を読みだす

    形式	long ReadGeomScreen()

    解説	視点からスクリーンまでの距離を読みだす

    返り値	Ｈ値
		
		

*７．シンプルファンクション

**7.1. 
RotTransPers	座標変換と透視変換を行なう

    形式	long RotTransPers(v0,sxy,p,flag)
		SVECTOR *v0;	/*入力:頂点座標ベクトル*/
		long *sxy;	/*出力:スクリーン座標値*/
		long *p;	/*出力:内挿値*/
		long *flag;	/*flag*/

    解説	座標ベクトル v0 を回転マトリックスで
		座標変換したあと透視変換を行ない、スクリーン座標
		sx,syを返す。またデプスキューイング用の内挿値をpに返す。

    		<引数フォーマット>
		v0->vx,vy,vz : (1,15,0)
		sxy : (1,15,0),(1,15,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	sz/4
		

**7.2. 
RotTransPers3	３頂点の座標変換と透視変換を行なう

    形式	long RotTransPers3(v0,v1,v2,sxy0,sxy1,sxy2,p,flag)
		SVECTOR *v0,*v1,*v2;		/*入力:頂点座標ベクトル*/
		long *sxy0,*sxy1,*sxy2;		/*出力:スクリーン座標値*/
		long *p;	/*出力:内挿値*/
		long *flag;	/*flag*/

    解説	３つの座標ベクトル v0,v1,v2 を
		回転マトリックスで座標変換したあと透視変換を行ない、
		３つのスクリーン座標 sxy0,sxy1,sxy2 を返す。
		また v2 に対応するデプスキューイング用の内挿値をpに返す。
		また v2 に対応するスクリーン座標のＺ成分 sz の１／４を

    		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		sxy0,sxy1,sxy2 : (1,15,0),(1,15,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	sz/4
		

**7.3. 
RotTrans	回転マトリックスで座標変換を行なう

    形式	void RotTrans(v0,v1,flag)
		SVECTOR *v0;	/*入力:ベクトル*/	
		VECTOR *v1;	/*出力:ベクトル*/
		long *flag;	/*flag*/

    解説	v1 = RTM*v0
		<引数フォーマット>
		v0->vx,vy,vz : (1,15,0)
		v1->vx,vy,vz : (1,31,0)
		flag : (0,32,0)

    返り値	なし
		

**7.3.1 
RotTransSV	回転マトリックスで座標変換を行なう

    形式	void RotTrans(v0,v1,flag)
		SVECTOR *v0;	/*入力:ベクトル*/	
		SVECTOR *v1;	/*出力:ベクトル*/
		long *flag;	/*flag*/

    解説	RotTransの出力ショートベクトル版
		v1 = RTM*v0
		<引数フォーマット>
		v0->vx,vy,vz : (1,15,0)
		v1->vx,vy,vz : (1,15,0)
		flag : (0,32,0)

    返り値	なし
		

**7.4. 
LocalLight	ローカルライトマトリックスで座標変換を行なう

    形式	void LocalLight(v0,v1)
		SVECTOR *v0;	/*入力:ベクトル*/	
		VECTOR *v1; 	/*出力:ベクトル*/

    解説	v1 = LLM*v0
		v1 の負の成分は０でリミッターがかかる。
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		v1->vx,vy,vz : (0,20,12)

    返り値	なし
		

**7.5. 
LightColor	ローカルカラーマトリックスで座標変換を行なう

    形式	void LightColor(v0,v1)
		VECTOR *v0;	/*入力:ベクトル*/
		VECTOR *v1;	/*出力:ベクトル*/

    解説	v1 = LCM*v0
		v1 の負の成分は０でリミッターがかかる。
		<引数フォーマット>
		v0->vx,vy,vz : (1,19,12)
		v1->vx,vy,vz : (0,20,12)

    返り値	なし
		

**7.6. 
DpqColorLight	ローカルカラーベクトルと原色ベクトルの積と
		ファーカラーとの内挿を行なう

    形式	void DpqColorLight(v0,v1,p,v2)
		VECTOR *v0;		/*入力:ローカルカラーベクトル*/       
		CVECTOR *v1;		/*入力:原色ベクトル*/
		long p;	/*入力:内挿値*/
		CVECTOR *v2;		/*出力:色ベクトル*/
		

    解説	v2 = p*(v1*v0) + (1-p)*FC		      
		v1*v0は項別積	      
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		v1->r,g,b : (0,8,0)
		p : (0,20,12)
		v2->r,g,b : (0,8,0)

    返り値	なし
		

**7.7. 	
DpqColor	原色ベクトルとファーカラーとの内挿を行なう

    形式	void DpqColor(v0,p,v1)
		CVECTOR *v0;	/*入力:原色ベクトル*/
		long p;		/*入力:内挿値*/
		CVECTOR *v1;	/*出力:カラーベクトル*/

    解説	v1 = p*v0 + (1-p)*FC
		<引数フォーマット>
		v0->r,g,b : (0,8,0)
		p : (0,20,12)
		v1->r,g,b : (0,8,0)

    返り値	なし
		

**7.8. 
DpqColor3	３つの原色ベクトルとファーカラーとの内挿を行なう

    形式	void DpqColor3(v0,v1,v2,p,v3,v4,v5)
		CVECTOR *v0,*v1,*v2;		/*入力:原色ベクトル*/
		long p;		/*入力:内挿値*/
		CVECTOR *v3,*v4,*v5;		/*出力:カラーベクトル*/
		

    解説	v3 = p*v0 + (1-p)*FC			      
		v4 = p*v1 + (1-p)*FC			      
		v5 = p*v2 + (1-p)*FC			      
		<引数フォーマット>
		v0,v1,v2->r,g,b : (0,8,0)
		p : (0,20,12)
		v3,v4,v5->r,g,b : (0,8,0)

    返り値	なし
		

**7.9. 
Intpl	ベクトルとファーカラーの内挿を行なう


    形式	void Intpl(v0,p,v1)
		VECTOR *v0;	/*入力:ベクトル*/	      
		long p;		/*入力:内挿値*/
		CVECTOR *v1;	/*出力:ベクトル*/

    解説	v1 = p*v0 + (1-p)*FC
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		p : (0,20,12)
		v1->r,g,b : (0,8,0)

    返り値	なし
		

**7.10. 
Square12	ベクトルの２乗を求める

    形式	VECTOR *Square12(v0,v1)			      
		VECTOR *v0;		/*入力:ベクトル(L1,L2,L3)*/
		VETCOR *v1;		/*出力:ベクトル(L1^2,L2^2,L3^2)*/
		

    解説	ベクトル v0 の各項の２乗を4096で割ったベクトルを v1 に返す。
		<引数フォーマット>
		v0->vx,vy,vz : (1,19,12)
		v1->vx,vy,vz : (1,19,12)

    返り値	v1		      
		

**7.11. 
Square0	ベクトルの２乗を求める

    形式	VECTOR *Square0(v0,v1)			      
		VECTOR *v0;		/*入力:ベクトル(L1,L2,L3)*/
		VETCOR *v1;		/*出力:ベクトル(L1^2,L2^2,L3^2)*/

    解説	ベクトル v0 の各項の２乗のベクトルを v1 に返す。
		<引数フォーマット>
		v0->vx,vy,vz : (1,31,0)
		v1->vx,vy,vz : (1,31,0)

    返り値	v1		      
		

**7.12. 
NormalColor	法線ベクトルからローカルカラーを求める

    形式	void NormalColor(v0,v1)
		SVECTOR *v0;	/*入力:法線ベクトル*/
		CVECTOR *v1;	/*出力:色ベクトル*/

    解説	LLV = LLM*v0
		v1 = BK + LCM*LLV
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		v1->r,g,b : (0,8,0)

    返り値	なし
		

**7.13. 
NormalColor3	３つの法線ベクトルから３つのローカルカラーを求める

    形式	void NormalColor3(v0,v1,v2,v3,v4,v5)
		SVECTOR *v0,*v1,*v2;		/*入力:法線ベクトル*/
		CVETCOR *v3,*v4,*v5;		/*出力:色ベクトル*/
		

    解説	(LLV0,LLV1,LLV2) = LLM*(v0,v1,v2)
		(v3,v4,v5) = BK + LCM*(LLV0,LLV1,LLV2)
		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,3,12)
		v3,v4,v5->r,g,b : (0,8,0)

    返り値	なし
		

**7.14. 
NormalColorDpq	法線ベクトルからローカルカラーを求め
		さらにデプスキューイングを行なう

    形式	void NormalColorDpq(v0,v1,p,v2)
		SVECTOR *v0;	/*入力:法線ベクトル*/
		CVECTOR *v1;	/*入力:原色ベクトル*/
		long p;		/*入力:内挿値*/
		CVECTOR *v2;	/*出力:色ベクトル*/

    解説	LLV = LLM*v0
		LC = BK + LCM*LLV
		v2 = (1-p)*v1*LC + p*FC
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		v1->r,g,b : (0,8,0)
		p : (0,20,12)
		v2->r,g,b : (0,8,0)

    返り値	なし
		

**7.15. 
NormalColorDpq3	３つの法線ベクトルからローカルカラーを求め
		さらにデプスキューイングを行なう

    形式	void NormalColorDpq3(v0,v1,v2,v3,p,v4,v5,v6)
		SVECTOR *v0,*v1,*v2;	/*入力:法線ベクトル*/
		CVETCOR *v3;		/*入力:原色ベクトル*/
		long p;			/*入力:内挿値*/
		CVECTOR *v4,*v5,*v6;	/*出力:色ベクトル*/

    解説	(LLV0,LLV1,LLV2) = LLM*(v0,v1,v2)
		(LC0,LC1,LC2) = BK + LCM*(LLV0,LLV1,LLV2)
		(v4,v5,v6) = p*v3*(LC0,LC1,LC2) + (1-p)*FC
		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,3,12)
		v3->r,g,b : (0,8,0)
		p : (0,20,12)
		v4,v5,v6->r,g,b : (0,8,0)

    返り値	なし
		

**7.16. 
NormalColorCol	法線ベクトルからローカルカラーを求める

    形式	void NormalColorCol(v0,v1,v2)
		SVECTOR *v0;	/*入力:法線ベクトル*/
		CVECTOR *v1;	/*入力:原色ベクトル*/
		CVECTOR *v2;	/*出力:色ベクトル*/

    解説	LLV = LLM*v0
		LC = BK + LCM*LLV
		v2 = v1*LC
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		v1->r,g,b : (0,8,0)
		v2->r,g,b : (0,8,0)

    返り値	なし
		

**7.17. 
NormalColorCol3	３つの法線ベクトルからローカルカラーを求める

    形式	void NormalColorCol3(v0,v1,v2,v3,v4,v5,v6)
		SVECTOR *v0,*v1,*v2;	/*入力:法線ベクトル*/
		CVETCOR *v3;		/*入力:原色ベクトル*/
		CVECTOR *v4,*v5,*v6;	/*出力:色ベクトル*/

    解説	(LLV0,LLV1,LLV2) = LLM*(v0,v1,v2)
		(LC0,LC1,LC2) = BK + LCM*(LLV0,LLV1,LLV2)
		(v4,v5,v6) = v3*(LC0,LC1,LC2)
		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,3,12)
		v3->r,g,b : (0,8,0)
		v4,v5,v6->r,g,b : (0,8,0)

    返り値	なし
		

**7.18. 
ColorDpq	ローカルライトベクトルからローカルカラーを求め
		さらにデプスキューイングを行なう

    形式	void ColorDpq(v0,v1,p,v2)
		VECTOR *v0;	/*入力:ローカルライトベクトル*/
		CVECTOR *v1;	/*入力:原色ベクトル*/
		long p;		/*入力:内挿値*/
		CVECTOR *v2;	/*出力:色ベクトル*/

    解説	LC = BK + LCM*v0
		v2 = p*v1*LC + (1-p)*FC
		<引数フォーマット>
		v0->vx,vy,vz : (1,19,12)
		v1->r,g,b : (0,8,0)
		p : (0,20,12)
		v2->r,g,b : (0,8,0)

    返り値	なし
		

**7.19. 
ColorCol	ローカルライトベクトルからローカルカラーを求める

    形式	void ColorCol(v0,v1,v2)
		VECTOR *v0;	/*入力:ローカルライトベクトル*/
		CVECTOR *v1;	/*入力:原色ベクトル*/
		CVECTOR *v2;	/*出力:色ベクトル*/

    解説	LC = BK + LCM*v0
		v2 = v1*LC
		<引数フォーマット>
		v0->vx,vy,vz : (1,19,12)
		v1->r,g,b : (0,8,0)
		v2->r,g,b : (0,8,0)

    返り値	なし
		

**7.20. 
NormalClip	３点の外積値を求める

    形式	long NormalClip(sxy0,sxy1,sxy2)
		long sxy0,sxy1,sxy2;	/*入力値(sx:LS16bit,sy:MS16bit)*/

    解説	(sx0,sy0),(sx1,sy1),(sx2,sy2)で与えられる３つの点
		の囲む３角形の外積値を返す。
		視点（Ｚ軸負）の方向から見たとき三角形が右周り
		であるとき正の値になる。
		（ただし、Ｘ軸正は右向き、Ｙ軸正は下向きとする）
		<引数フォーマット>
		sxy0,sxy1,sxy2 : (1,15,0),(1,15,0)

    返り値	|sx1-sx0,sy1-sy0|
		|sx2-sx0,sy2-sy0|
		

**7.21. 
AverageZ3	３つの値の平均値を求める

    形式	long AverageZ3(sz0,sz1,sz2)
		long sz0,sz1,sz2;		/*入力値*/

    解説	３つの値 sz0,sz1,sz2 の平均値を返す。
		<引数フォーマット>
		sz0,sz1,sz2 : (0,16,0)

    返り値	(sz0+sz1+sz2)/3
		

**7.22. 
AverageZ4	４つの値の平均値を求める

    形式	long AverageZ4(sz0,sz1,sz2,sz3)
		long sz0,sz1,sz2,sz3;		/*入力値*/

    解説	４つの値 sz0,sz1,sz2,sz3 の平均値を返す。
		<引数フォーマット>
		sz0,sz1,sz2,sz3 : (0,16,0)

    返り値	(sz0+sz1+sz2+sz3)/3
		

**7.23. 
OuterProduct12	２つのベクトルの外積ベクトルを求める

    形式	void OuterProduct12(v0,v1,v2)
		VECTOR *v0,*v1;	/*入力:ベクトル*/
		VECTOR *v2;	/*出力:ベクトル*/
		

    解説	２つのベクトル v0,v1 の外積ベクトルを v2 に返す。
		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,19,12)

    返り値	なし
		

**7.24. 
OuterProduct0	２つのベクトルの外積ベクトルを求める

    形式	void OuterProduct0(v0,v1,v2)
		VECTOR *v0,*v1;	/*入力:ベクトル*/
		VECTOR *v2;	/*出力:ベクトル*/

    解説	２つのベクトル v0,v1 の外積ベクトルを v2 に返す。
		<引数フォーマット>
		v0,v1->vx,vy,vz : (1,31,0)
		v2->vx,vy,vz : (1,31,0)

    返り値	なし
		

**7.25. 
Lzc	Leading Zero Count値を返す

    形式	long Lzc(data)
		long data;	/*入力値*/

    解説	dataで与えられる値のLeading Zero Count値を返す。
		<引数フォーマット>
		data : (1,31,0)

    返り値	ＬＺＣ値
		

**7.26.
TransRotPers	RotTransPersの回転平行移動を逆順に行なう

    形式	long TransRotPers(v0,sxy,p,flag)
		SVECTOR *v0;	/*入力:頂点座標ベクトル*/
		long *sxy;	/*出力:スクリーン座標値*/
		long *p;	/*出力:内挿値*/
		long *flag;	/*flag*/

    解説	座標ベクトル v0 を回転マトリックスで平行移動したあと回転する
		座標変換したあと透視変換を行ない、スクリーン座標
		sx,syを返す。またデプスキューイング用の内挿値をpに返す。

    		<引数フォーマット>
		v0->vx,vy,vz : (1,15,0)
		sxy : (1,15,0),(1,15,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	sz/4
		

**7.27. 
TransRotPers3	RotTransPers3の回転平行移動を逆順に行なう

    形式	long TransRotPers3(v0,v1,v2,sxy0,sxy1,sxy2,p,flag)
		SVECTOR *v0,*v1,*v2;		/*入力:頂点座標ベクトル*/
		long *sxy0,*sxy1,*sxy2;		/*出力:スクリーン座標値*/
		long *p;			/*出力:内挿値*/
		long *flag;			/*flag*/

    解説	３つの座標ベクトル v0,v1,v2 を
		回転マトリックスで平行移動したあと回転する
		座標変換したあと透視変換を行ない、
		３つのスクリーン座標 sxy0,sxy1,sxy2 を返す。
		また v2 に対応するデプスキューイング用の内挿値をpに返す。
		また v2 に対応するスクリーン座標のＺ成分 sz の１／４を

    		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		sxy0,sxy1,sxy2 : (1,15,0),(1,15,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	sz/4
		

**7.28. 
TransRot_32	RotTransの回転平行移動を逆順に行なう

    形式	void TransRot(v0,v1,flag)
		VECTOR *v0;	/*入力:ベクトル*/	
		VECTOR *v1;	/*出力:ベクトル*/
		long *flag;	/*flag*/

    解説	v0に32bitの平行移動量を足したあと定数回転マトリクスで回転
		を行なう。
	
		<引数フォーマット>
		v0->vx,vy,vz : (1,31,0)
		v1->vx,vy,vz : (1,31,0)
		flag : (0,32,0)

    返り値	なし
		
		

*８．コンバインド　ファンクション


**8.1. 
RotTransPers4	４頂点の座標変換と透視変換を行なう

    形式	long RotTransPers4(v0,v1,v2,v3,sxy0,sxy1,sxy2,sxy3,p,flag)
		SVECTOR *v0,*v1,*v2,*v3;	/*入力:ベクトル*/
		long *sxy0,*sxy1,*sxy2,*sxy3;	/*出力:座標値*/
		long *p;			/*出力:内挿値*/
		long *flag;	

    解説	４つの座標ベクトル v0,v1,v2,v3 を回転マトリックスで
		座標変換したあと透視変換を行ない、
		４つのスクリーン座標を sxy0,sxy1,sxy2,sxy3 に返す。
		また v3 に対応するデプスキューイング用の内挿値を p に返す。
		また v3 に対応するスクリーン座標のＺ成分 sz の１／４を

	    	<引数フォーマット>
		v0,v1,v2,v3->vx,vy,vz : (1,15,0)
		sxy0,sxy1,sxy2,sxy3 : (1,15,0),(1,15,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	sz/4
		

**8.1.1.
RotTransPersN    座標変換と透視変換を行なう

    形式	void RotTransPersN(v0,v1,sz,p,flag,n)
		SVECTOR *v0;	    /*入力:頂点座標ベクトル*/
		DVECTOR *v1;	    /*出力:頂点座標ベクトル*/
		u_short *sz;	    /*出力:SZ値*/	      
		u_short *p;	    /*出力:p値*/	      
		u_short *flag;	    /*出力:フラグ*/	      
		long    n;	    /*頂点数*/

    解説	n個の頂点に対してRotTRansPersを行なう
		<引数および内部データフォーマット>
		v0->vx,vy,vz : (1,15,0)
		v1->vx,vy : (1,15,0)
		sz : (0,16,0)
		flag : (0,16,0)

    返り値	なし
	
    注意	flagは通常の３２ビットflagの２７ビット目から１２ビット目まで
		

**8.1.2.
RotTransPers3N    座標変換と透視変換を行なう

    形式	void RotTransPers3N(v0,v1,sz,flag,n)
		SVECTOR *v0;	        /*入力:頂点座標ベクトル*/
		DVECTOR *v1;	        /*出力:頂点座標ベクトル*/
		u_short *sz;	        /*出力:SZ値*/	      
		u_short *flag;	        /*出力:フラグ*/	      
		long    n;	        /*頂点数*/

    解説	n個の三角形に対してRotTRansPers3を行なう
		<引数および内部データフォーマット>
		v0->vx,vy,vz : (1,15,0)
		v1->vx,vy : (1,15,0)
		sz : (0,16,0)
		flag : (0,16,0)

    返り値	なし
	
    注意	flagは通常の３２ビットflagの２７ビット目から１２ビット目まで
		

**8.1.3.
RotMeshH    座標変換と透視変換を行なう

    形式	void RotMeshH(Yheight,Vo,sz,flag,Xoffset,Zoffset,m,n,base)
		short   *Yheight;	/*入力:頂点Ｙ座標*/
		DVECTOR *Vo;	        /*出力:スクリーン座標*/
		u_short *sz;		/*出力:SZ値*/		      
		u_short *flag;		/*出力:フラグ*/		      
		short   Xoffset,Zoffset;/*入力:ＸＺオフセット */
		short   m,n;	        /*入力:頂点数*/
		DVECTOR *base;	        /*base address*/

    解説	m x n個の四角形メッシュ頂点に対して座標変換と透視変換を行なう
		<引数および内部データフォーマット>
		*Yheight : (1,15,0)
		Vo->vx,vy : (1,15,0)
		sz : (0,16,0)
		flag : (0,16,0)
		Xoffset,Zoffset: (1,15,0)
		m,n: (1,15,0)
		base:   (1,15,0)

    返り値	なし
	
    注意	flagは通常の３２ビットflagの２７ビット目から１２ビット目まで
		
		

**8.2. 
RotAverage3	３点の座標変換と透視変換を行ない
		デプスキューイング用の内挿値とＺ値の平均値を求める

    形式	long RotAverage3(v0,v1,v2,sxy0,sxy1,sxy2,p,flag)
		SVECTOR *v0,*v1,*v2;		/*入力:ベクトル*/
		long *sxy0,*sxy1,*sxy2;		/*出力:座標*/
		long *p;			/*出力:内挿値*/
		long *flag;		

    解説	ローカル座標ベクトル v0,v1,v2 を回転マトリックスで
		座標変換したあと透視変換を行ない、
		３つのスクリーン座標を sxy0,sxy1,sxy2 に返す。
		また v2 に対応するデプスキューイング用の内挿値を p に返す。
		また３つのスクリーン座標のＺ値の平均値を otz に返す。
		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		sxy0,sxy1,sxy2 : (1,15,0),(1,15,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	OTZ値
		

**8.3. 
RotAverage4	４点の座標変換と透視変換を行ない
		デプスキューイング用の内挿値とＺ値の平均値を求める

    形式	long RotAverage4(v0,v1,v2,v3,sxy0,sxy1,sxy2,sxy3,p,flag)
		SVECTOR *v0,*v1,*v2,*v3;	/*入力:ベクトル*/
		long *sxy0,*sxy1,*sxy2,*sxy3;	/*出力:座標値*/
		long *p;			/*出力:内挿値*/
		long *flag;	

    解説	４点 v0,v1,v2,v3 を回転マトリックスで座標変換したあと
		透視変換を行ない、４つのスクリーン座標を
		sxy0,sxy1,sxy2,sxy3 に返す。
		また v3 に対応するデプスキューイング用の内挿値を p に返す。
		また４つのスクリーン座標のＺ値の平均値を otz に返す。
		<引数フォーマット>
		v0,v1,v2,v3->vx,vy,vz : (1,15,0)
		sxy0,sxy1,sxy2,sxy3 : (1,15,0),(1,15,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	OTZ値
		

**8.4. 
RotNclip3	３点の座標変換と透視変換を行ない
		デプスキューイング用の内挿値と外積値を求める

    形式	long RotNclip3(v0,v1,v2,sxy0,sxy1,sxy2,p,otz,flag)
		SVECTOR *v0,*v1,*v2;		/*入力:ベクトル*/
		long *sxy0,*sxy1,*sxy2;		/*出力:座標値*/
		long *p;	/*出力:内挿値*/
		long *otz;	/*出力:sz/4*/
		long *flag;	

    解説	３点 v0,v1,v2 を回転マトリックスで座標変換したあと
		透視変換を行ない、３つのスクリーン座標を
		sxy0,sxy1,sxy2 に返す。
		また v2 に対応するデプスキューイング用の内挿値を p に返す。
		また v2 に対応するスクリーン座標のＺ値の１／４を otz に返す。

    		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		sxy0,sxy1,sxy2 : (1,15,0),(1,15,0)
		p : (0,20,12)
		otz : (0,32,0)
		flag : (0,32,0)
	
    注意	どんな場合でもSX,SY等が必要な場合はRotTransPers3を使う。

    返り値	外積値
		

**8.5. 
RotNclip4	４点の座標変換と透視変換を行ない
		デプスキューイング用の内挿値と外積値を求める

    形式	long RotNclip4(v0,v1,v2,v3,sxy0,sxy1,sxy2,sxy3,p,otz,flag)
		SVECTOR *v0,*v1,*v2,*v3;	/*入力:ベクトル*/
		long *sxy0,*sxy1,*sxy2,*sxy3;	/*出力:座標値*/
		long *p;			/*出力:内挿値*/
		long *otz;			/*出力:sz/4*/
		long *flag;	

    解説	４点 v0,v1,v2,v3 を回転マトリックスで座標変換したあと
		透視変換を行ない、４つのスクリーン座標を
		sxy0,sxy1,sxy2,sxy3 に返す。
		また v3 に対応するデプスキューイング用の内挿値を p に返す。
		また v3 に対応するスクリーン座標のＺ値の１／４を otz に返す。

   		<引数フォーマット>
		v0,v1,v2,v3->vx,vy,vz : (1,15,0)
		sxy0,sxy1,sxy2,sxy3 : (1,15,0),(1,15,0)
		p : (0,20,12)
		otz : (0,32,0)
		flag : (0,32,0)

    返り値	外積値
	
    注意	どんな場合でもSX,SY等が必要な場合はRotTransPers4を使う。

		

**8.6. 
RotAverageNclip3	３点の座標変換と透視変換を行ない
			内挿値とＺ値の平均値と外積値を求める

    形式	long RotAverageNclip3(v0,v1,v2,sxy0,sxy1,sxy2,p,otz,flag)
		SVECTOR *v0,*v1,*v2;		/*入力:ベクトル*/
		long *sxy0,*sxy1,*sxy2;		/*出力:座標値*/
		long *p;	/*出力:内挿値*/
		long *otz;	/*出力:ＯＴＺ値*/
		long *flag;		

    解説	３点 v0,v1,v2 を回転マトリックスで座標変換したあと
		透視変換を行ない、３つのスクリーン座標を 
		sxy0,sxy1,sxy2に返す。
		また v2 に対応するデプスキューイング用の内挿値を p に返す。
		またスクリーン座標の３つのＺ値の平均値の1/4を otz に返す。	  
    		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		sxy0,sxy1,sxy2 : (1,15,0),(1,15,0)
		p : (0,20,12)
		otz : (0,32,0)
		flag : (0,32,0)
	
    返り値	外積値
	
    注意	どんな場合でもSX,SY等が必要な場合はRotAverage3を使う。

		

**8.7 
RotAverageNclip4	４点の座標変換と透視変換を行ない
			内挿値とＺ値の平均値と外積値を求める

    形式	long RotAverageNclip4(v0,v1,v2,v3,sxy0,sxy1,sxy2,sxy3,p,otz,flag)
		SVECTOR *v0,*v1,*v2,*v3;	/*入力:ベクトル*/
		long *sxy0,*sxy1,*sxy2,*sxy3;	/*出力:座標値*/
		long *p;			/*出力:内挿値*/
		long *otz;			/*出力:ＯＴＺ値*/
		long *flag;	

    解説	４点 v0,v1,v2,v3 を回転マトリックスで座標変換したあと
		透視変換を行ない、４つのスクリーン座標を
		sxy0,sxy1,sxy2,sxy3 に返す。
		また v3 に対応するデプスキューイング用の内挿値を p に返す。
		またスクリーン座標の４つのＺ値の平均値を otz に返す。

    		<引数フォーマット>
		v0,v1,v2,v3->vx,vy,vz : (1,15,0)
		sxy0,sxy1,sxy2,sxy3 : (1,15,0),(1,15,0)
		p : (0,20,12)
		otz : (0,32,0)
		flag : (0,32,0)
	
    返り値	外積値
	
    注意	どんな場合でもSX,SY等が必要な場合はRotAverage4を使う。
	

**8.8 
RotColorDpq	座標変換と透視変換とデプスキューイングを行なう

    形式	long RotColorDpq(v0,v1,v2,sxy,v3,flag)
		SVECTOR *v0;	/*入力:ベクトル*/
		SVECTOR *v1;	/*入力:法線ベクトル*/
		CVECTOR *v2;	/*入力:原色ベクトル*/
		long *sxy;	/*出力:座標値*/
		CVECTOR *v3;	/*出力:色ベクトル*/
		long *flag;	

    解説	点 v0 を回転マトリックスで座標変換したあと透視変換を行ない、
		スクリーン座標を sxy に返す。またこのとき求められる
		デプスキューイング用内挿値 p を以下の計算で使う。
		
		LLV = LLM*v1
		LC = BK + LCM*LLV
		v3 = p*v2*LC + (1-p)*FC
	
		<引数フォーマット>
		v0->vx,vy,vz : (1,15,0)
		v1->vx,vy,vz : (1,3,12)
		v2->r,g,b : (0,8,0)
		sxy : (1,15,0),(1,15,0)
		v3->r,g,b : (0,8,0)
		flag : (0,32,0)

    返り値	sz/4
		

**8.9. 
RotColorDpq3	３点の座標変換と透視変換とデプスキューイングを行なう


    形式	long RotColorDpq3(v0,v1,v2,v3,v4,v5,v6,sxy0,sxy1,sxy2,v7,v8,v9,flag)
		SVECTOR *v0,*v1,*v2;		/*入力:ベクトル*/
		SVECTOR *v3,*v4,*v5;		/*入力:法線ベクトル*/
		CVECTOR *v6;			/*入力:原色ベクトル*/
		long *sxy0,*sxy1,*sxy2;		/*出力:座標値*/
		CVECTOR *v7,*v8,*v9;		/*出力:色ベクトル*/
		long *flag;	

    解説	３点 v0,v1,v2 を回転マトリックスで座標変換したあと
		透視変換を行ない、スクリーン座標を sxy0,sxy1,sxy2 に返す。
		またこのとき求められるデプスキューイング用内挿値 p を
		以下の計算で使う。
		
		(LLV0,LLV1,LLV2) = LLM*(v3,v4,v5)
		(LC0,LC1,LC2) = BK + LCM*(LLV0,LLV1,LLV2)
		(v7,v8,v9) = p*v6*(LC0,LC1,LC2) + (1-p)*FC
		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		v3,v4,v5->vx,vy,vz : (1,3,12)
		v6->r,g,b : (0,8,0)
		sxy0,sxy1,sxy2 : (1,15,0),(1,15,0)
		v7,v8,v9->r,g,b : (0,8,0)
		flag : (0,32,0)

    返り値	sz/4
		

**8.10. 
RotAverageNclipColorDpq3	３点の座標変換と透視変換と
				デプスキューイングを行なう

    形式	long RotAverageNclipColorDpq3(	 	   	      
		v0,v1,v2,v3,v4,v5,v6,sxy0,sxy1,sxy2,v7,v8,v9,otz,flag)
		SVECTOR *v0,*v1,*v2;		/*入力:ベクトル*/
		SVECTOR *v3,*v4,*v5;		/*入力:法線ベクトル*/
		CVECTOR *v6		;	/*入力:原色ベクトル*/
		long *sxy0,*sxy1,*sxy2;		/*出力:座標値*/
		CVECTOR *v7,*v8,*v9;		/*出力:カラーベクトル*/
		long *otz;			/*出力:ＯＴＺ値*/
		long *flag;

    解説	３点 v0,v1,v2 を回転マトリックスで座標変換したあと
		透視変換を行ない、スクリーン座標を sxy0,sxy1,sxy2 に返す。
		またこのとき求められるデプスキューイング用内挿値 p を
		以下の計算で使う。
		
		(LLV0,LLV1,LLV2) = LLM*(v3,v4,v5)
		(LC0,LC1,LC2) = BK + LCM*(LLV0,LLV1,LLV2)
		(v7,v8,v9) = p*v6*(LC0,LC1,LC2) + (1-p)*FC
		
		また３つのスクリーン座標のＺ値の平均値を otz に返す。

    		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		v3,v4,v5->vx,vy,vz : (1,3,12)
		v6->r,g,b : (0,8,0)
		sxy0,sxy1,sxy2 : (1,15,0),(1,15,0)
		v7,v8,v9->r,g,b : (0,8,0)
		otz : (0,32,0)
		flag : (0,32,0)

    返り値	外積値
	
    注意	どんな場合でもSX,SY等が必要な場合はRotAverage3を使う。
		

**8.11. 
RotAverageNclipColorCol3	３点の座標変換と透視変換を行ない
				カラーを求める

    形式	long RotAverageNclipColorCol3( 
		v0,v1,v2,v3,v4,v5,v6,sxy0,sxy1,sxy2,v7,v8,v9,otz,flag)
		SVECTOR *v0,*v1,*v2;		/*入力:ベクトル*/
		SVECTOR *v3,*v4,*v5;		/*入力:法線ベクトル*/
		CVECTOR *v6;	/*入力:原色ベクトル*/
		long *sxy0,*sxy1,*sxy2;		/*出力:座標値*/
		CVECTOR *v7,*v8,*v9;		/*出力:色ベクトル*/
		long *otz;	/*出力:ＯＴＺ値*/
		long *flag;	

    解説	３点 v0,v1,v2 を回転マトリックスで座標変換したあと
		透視変換を行ない、スクリーン座標を sxy0,sxy1,sxy2 に返す。
		
		(LLV0,LLV1,LLV2) = LLM*(v3,v4,v5)
		(LC0,LC1,LC2) = BK + LCM*(LLV0,LLV1,LLV2)
		(v7,v8,v9) = v6*(LC0,LC1,LC2)
		
		また３つのスクリーン座標のＺ値の平均値を otz に返す。

    		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		v3,v4,v5->vx,vy,vz : (1,3,12)
		v6->r,g,b : (0,8,0)
		sxy0,sxy1,sxy2 : (1,15,0),(1,15,0)
		v7,v8,v9->r,g,b : (0,8,0)
		otz : (0,32,0)
		flag : (0,32,0)

    返り値	外積値
		
    注意	どんな場合でもSX,SY等が必要な場合はRotAverage4を使う。


**8.12 
RotColorMatDpq	座標変換と透視変換とデプスキューイングを行なう	

    形式	long RotColorMatDpq(v0,v1,v2,sxy,v3,matc,flag)
		SVECTOR *v0;	/*入力:ベクトル*/
		SVECTOR *v1;	/*入力:法線ベクトル*/
		CVECTOR *v2;	/*入力:原色ベクトル*/
		long *sxy;	/*出力:座標値*/
		CVECTOR *v3;	/*出力:色ベクトル*/
		long matc;	/*入力:材質*/
		long flag;

    解説	点 v0 を回転マトリックスで座標変換したあと
		透視変換を行ない、スクリーン座標を sxy に返す。
		またこのとき求められるデプスキューイング用内挿値 p を
		以下の計算で使う。
		
		LLV = LLM*v1
		LLV = LLV^(2^matc)
		LC = BK + LCM*LLV
		v3 = p*v2*LC + (1-p)*FC
		<引数フォーマット>
		v0->vx,vy,vz : (1,15,0)
		v1->vx,vy,vz : (1,3,12)
		v2->r,g,b : (0,8,0)
		sxy : (1,15,0),(1,15,0)
		v3->r,g,b : (0,8,0)
		matc : (0,32,0)
		flag : (0,32,0)

    返り値	sz/4
		

**8.13. 
ColorMatDpq	デプスキューイングを行なう

    形式	void ColorMatDpq(v0,v1,p,v2,matc)
		SVECTOR *v0;	/*入力:法線ベクトル*/
		CVECTOR *v1;	/*入力:原色ベクトル*/
		long p;		/*出力:内挿値*/
		CVECTOR *v2;	/*出力:色ベクトル*/
		long matc;	/*出力:材質*/

    解説	LLV = LLM*v0
		LLV = LLV^(2^matc)
		LC = BK + LCM*LLV
		v2 = p*v1*LC + (1-p)*FC
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		v1->r,g,b : (0,8,0)
		p : (0,20,12)
		v2->r,g,b : (0,8,0)
		matc : (0,32,0)

    返り値	なし
		

**8.14. 
ColorMatCol	カラーを求める

    形式	void ColorMatCol(v0,v1,v2,matc)
		SVECTOR *v0;	/*入力:法線ベクトル*/
		CVECTOR *v1;	/*入力:原色ベクトル*/
		CVECTOR *v2;	/*出力:色ベクトル*/
		long matc;	/*出力:材質*/

    解説	LLV = LLM*v0
		LLV = LLV^(2^matc)
		LC = BK + LCM*LLV
		v2 = v1*LC
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		v1->r,g,b : (0,8,0)
		v2->r,g,b : (0,8,0)
		matc : (0,32,0)

    返り値	なし
		

**8.15. 
LoadAverage12	２つのベクトルの荷重平均を求める

    形式	void LoadAverage12(v0,v1,p0,p1,v2)
		VECTOR *v0,*v1;	/*入力:ベクトル*/
		long p0,p1;	/*入力:重み*/
		VECTOR *v2; 	/*出力:ベクトル*/

    解説	２つのベクトル v0,v1 の重み p0,p1 による
		荷重平均を４０９６で割り v2 に返す。
		<引数フォーマット>
		v0,v1->vx,vy,vz : (1,31,0)
		p0,p1 : (1,3,12)
		v2->vx,vy,vz : (1,31,0)

    返り値	なし
		

**8.16. 
LoadAverageShort12	２つのベクトルの荷重平均を求める


    形式	void LoadAverageShort12(v0,v1,p0,p1,v2)
		SVECTOR *v0,*v1;	/*入力:ベクトル*/
		long p0,p1;		/*入力:重み*/
		SVECTOR *v2; 		/*出力:ベクトル*/

    解説	２つのベクトル v0,v1 の重み p0,p1 による
		荷重平均を４０９６で割り v2 に返す。
		<引数フォーマット>
		v0,v1->vx,vy,vz : (1,15,0)
		p0,p1 : (1,3,12)
		v2->vx,vy,vz : (1,15,0)

    返り値	なし
		

**8.17. 
LoadAverage0	２つのベクトルの荷重平均を求める

    形式	void LoadAverage0(v0,v1,p0,p1,v2)
		VECTOR *v0,*v1;		/*入力:ベクトル*/
		long p0,p1;		/*入力:重み*/	
		VECTOR *v2; 		/*出力:ベクトル*/

    解説	２つのベクトル v0,v1 の重み p0,p1 による荷重平均を v2 に返す。
		<引数フォーマット>
		v0,v1->vx,vy,vz : (1,31,0)
		p0,p1 : (1,15,0)
		v2->vx,vy,vz : (1,46,0)

    返り値	なし
		

**8.18. 
LoadAverageShort0	２つのベクトルの荷重平均を求める

    形式	void LoadAverageShort0(v0,v1,p0,p1,v2)
		SVECTOR *v0,*v1;	/*入力:ベクトル*/
		long p0,p1;		/*入力:重み*/	
		SVECTOR *v2; 		/*出力:ベクトル*/

    解説	２つのベクトル v0,v1 の重み p0,p1 による荷重平均を v2 に返す。
		<引数フォーマット>
		v0,v1->vx,vy,vz : (1,15,0)
		p0,p1 : (1,15,0)
		v2->vx,vy,vz : (1,30,0)

    返り値	なし
		

**8.18.1.
LoadAverageByte	２つのベクトルの荷重平均を求める

    形式	void LoadAverageByte(v0,v1,p0,p1,v2)
		u_char v0[2],v1[2];	/*入力:ベクトル*/
		long p0,p1;		/*入力:重み*/
		u_char v2[2]; 		/*出力:ベクトル*/

    解説	２つのベクトル v0,v1 の重み p0,p1 による
		荷重平均を４０９６で割り v2 に返す。
		<引数フォーマット>
		v0,v1->vx,vy,vz : (0,8,0)
		p0,p1 : (1,3,12)
		v2->vx,vy,vz : (0,8,0)

    返り値	なし
		

**8.18.2.
LoadAverageCol	２つのベクトルの荷重平均を求める

    形式	void LoadAverageCol(v0,v1,p0,p1,v2)
		u_char v0[3],v1[3];	/*入力:ベクトル*/
		long p0,p1;		/*入力:重み*/
		u_char v2[3]; 		/*出力:ベクトル*/

    解説	２つのベクトル v0,v1 の重み p0,p1 による
		荷重平均を４０９６で割り v2 に返す。
		<引数フォーマット>
		v0,v1->vx,vy,vz : (0,8,0)
		p0,p1 : (1,3,12)
		v2->vx,vy,vz : (0,8,0)

    返り値	なし
		
		

**8.19. 
VectorNormal	ベクトルを正規化する

    形式	long VectorNormal(v0,v1)		      
		VECTOR *v0;	/*入力:ベクトル*/
		VECTOR *v1;	/*出力:ベクトル*/

    解説	ベクトル v0 を正規化し v1 に返す。
		<引数フォーマット>
		v0->vx,vy,vz : (1,31,0)
		v1->vx,vy,vz : (1,19,12)
		注意]
		v0の成分の２乗和が 2^31-1 を超えると正しく計算できない

    返り値	v0の成分の２乗和
		

**8.19.1. 
VectorNormalS	ベクトルを正規化する

    形式	long VectorNormalS(v0,v1)		      
		VECTOR *v0;	/*入力:ベクトル*/
		SVECTOR *v1;	/*出力:ベクトル*/

    解説	ベクトル v0 を正規化し v1 に返す。
		<引数フォーマット>
		v0->vx,vy,vz : (1,31,0)
		v1->vx,vy,vz : (1,3,12)
		注意]
		v0の成分の２乗和が 2^31-1 を超えると正しく計算できない

    返り値	v0の成分の２乗和
		

**8.19.2. 
VectorNormalSS	ベクトルを正規化する

    形式	long VectorNormalSS(v0,v1)		      
		SVECTOR *v0;	/*入力:ベクトル*/
		SVECTOR *v1;	/*出力:ベクトル*/

    解説	ベクトル v0 を正規化し v1 に返す。
		<引数フォーマット>
		v0->vx,vy,vz : (1,16,0)
		v1->vx,vy,vz : (1,3,12)
		注意]
		v0の成分の２乗和が 2^31-1 を超えると正しく計算できない

    返り値	v0の成分の２乗和
		

**8.20. 
SquareRoot0	平方根を求める

    形式	long SquareRoot0(a)
		long a;		/*入力値*/

    解説	値 a の平方根を返す。
		<引数フォーマット>
		a : (0,32,0)

    返り値	平方根
		

**8.21. 
SquareRoot12	平方根を求める

    形式	long SquareRoot12(a)
		long a;		/*入力値*/

    解説	(0,20,12)フォーマットの値 a の値の平方根を
		(0,20,12)フォーマットで返す。
		<引数フォーマット>
		a : (0,20,12)

    返り値	平方根
		

**8.22.  
InvSquareRoot	１／平方根を求める

    形式	void InvSquareRoot(a,b,c)
		long a;		/*入力値*/
		long *b;	/*出力:仮数部*/
		long *c;	/*出力:指数部*/

    解説	値 a の１／平方根を返す。
		<引数フォーマット>
		a : (0,32,0)
		b : (0,20,12)
		c : (0,32,0)

    返り値	なし
		

**8.23.  
gteMIMefunc	頂点データ配列に係数を掛けた差分データ配列を足す

    形式	void gteMIMefunc(otp,dfp, n, p)
		SVECTOR *otp;		/* 頂点配列のポインタ */ 
		SVECTOR *dfp;		/* 差分配列のポインタ */
		long n;			/* 頂点(差分)データ数 */
		long p;			/* MIMe の重み(制御)係数　*/

    解説	多重内挿法 (MIMe) 演算の中で使用する頂点データ配列と
		差分データ配列を用いた内挿演算を実行するサブルーチン。
		p は小数部12 bit の固定小数点データ。
		
		以下のプログラムと同様の作業を高速に実行する。
		
		void gteMIMefunc(otp,dfp,n,p)
		SVECTOR *otp,*dfp;
		long n,p;
		{
			int i;
			for( i = 0; i < n; i++){
				(otp+i)->x += ( (int)((dfp+i)->x) * p )>>12;
				(otp+i)->y += ( (int)((dfp+i)->y) * p )>>12;
				(otp+i)->z += ( (int)((dfp+i)->z) * p )>>12;
			}
		}

		<引数フォーマット>
		p : (1,19,12)	
		otp,dfpは任意

    返り値	なし
		

**8.24. 
SetFogFar	フォグパラメータを設定する

    形式	void SetFogFar(a,h)
		long	a,h;

    解説	視点とスクリーンの距離がhのとき、
		フォグ１００％となるＺ値を a に設定する。
		フォグ０％となるＺ値は 0.2*a に自動設定される。
		0<a<65536
		<引数フォーマット>
		a : (0,32,0)
		h : (0,32,0)

    返り値	なし
		

**8.25. 
SetFogNear	フォグパラメータを設定する

    形式	void SetFogNear(a,h)
		long	a.h;

    解説	視点とスクリーンの距離がhのとき、
		フォグ０％となるＺ値を a に設定する。
		フォグ１００％となるＺ値は 5*a に自動設定される。
		0<a<65536*0.2
		<引数フォーマット>
		a : (0,32,0)
		h : (0,32,0)

    返り値	なし
		

**8.26. 		      
SetFogNearFar	フォグパラメータを設定する		      

    形式	void SetFogNearFar(a,b,h)		      
		long	a.b,h;	      

    解説	視点とスクリーンの距離がhのとき、	      
		フォグ０％となるＺ値を a に設定する。	      
		フォグ１００％となるＺ値を b に設定する。		      
		0<a,b<65536	      
		(b-a)>=100	      
		<引数フォーマット>			      
		a : (0,32,0)	      
		b : (0,32,0)	      
		h : (0,32,0)	      

    返り値	なし		      
		

**8.27 
SubPol4	４頂点ポリゴンを細分割する

    形式	void SubPol4(p,sp,ndiv)
		POL4    *p;		/*４頂点ポリゴン*/
		SPOL    *sp;		/*細分割頂点配列*/
		int     ndiv;		/*分割数(0:分割なし、1:2x2、2:4x4)

    解説	４頂点ポリゴン p を分割数 2**ndiv で細分割し
		その細分割頂点座標やテクスチャー座標やＲＧＢ値をspのさす
		配列に返す。
		
		p[0]-------p[1]		sp[0],sp[1],sp[2],
		|	     |	-->     sp[3],sp[4],sp[5],
		p[2]-------p[3]		sp[6],sp[7],sp[8]
		
		<引数フォーマット>
		p->sxy : (1,15,0),(1,15,0)
		p->sz : (0,16,0)
		p->uv : (1,15,0),(1,15,0)
		p->rgb : (0,8,0),(0,8,0),(0,8,0)
		p->code : (0,32,0)
		sp->xy : (1,15,0),(1,15,0)
		sp->uv : (1,15,0),(1,15,0)
		sp->rgb : (0,8,0),(0,8,0),(0,8,0)

    返り値	なし
		

**8.28. 
SubPol3	３頂点ポリゴンを細分割する

    形式	void SubPol3(p,sp,ndiv)
		POL3    *p;		/*３頂点ポリゴン*/
		SPOL    *sp;		/*細分割頂点配列*/
		int     ndiv;		/*分割数(0:分割なし、1:2x2、2:4x4)

    解説	pで与えられる３頂点ポリゴンを分割数 2**ndiv で細分割し
		その細分割頂点座標やテクスチャー座標やＲＧＢ値をspのさす
		配列の上左三角形に返す。
		
		p[0]-------p[1]		sp[0],sp[1],sp[2],
		|    _  -	-->     sp[3],sp[4]
		p[2]-	sp[6]
		
		<引数フォーマット>
		p->sxy : (1,15,0),(1,15,0)
		p->sz : (0,16,0)
		p->uv : (1,15,0),(1,15,0)
		p->rgb : (0,8,0),(0,8,0),(0,8,0)
		p->code : (0,32,0)
		sp->xy : (1,15,0),(1,15,0)
		sp->uv : (1,15,0),(1,15,0)
		sp->rgb : (0,8,0),(0,8,0),(0,8,0)

    返り値	なし
		

**8.29. 
rcos	

    形式	rcos(a)
		int a;

    解説	PSX format の角度（4096=2pai）のcosを固定小数点（4096=1.0）
		で求める。
		
		<フォーマット>
		a:PSX format (4096=2pai radian)
		返り値:(1,19,12)
	
    返り値	cos(a)
		

**8.30. 
rsin	

    形式	rsin(a)
		int a;

    解説	PSX format の角度（4096=2pai）のsinを固定小数点（4096=1.0）
		で求める。
		<フォーマット>
		a:PSX format (4096=2pai radian)
		返り値:(1,19,12)

    返り値	sin(a)
		

**8.31. 
ccos	

    形式	ccos(a)
		int a;

    解説	PSX format の角度（4096=2pai）のcosを固定小数点（4096=1.0）
		で求める。
		
		<フォーマット>
		a:PSX format (4096=2pai radian)
		返り値:(1,19,12)

    返り値	cos(a)
		

**8.32. 
csin	

    形式	csin(a)
		int a;

    解説	PSX format の角度（4096=2pai）のsinを固定小数点（4096=1.0）
		で求める。
		<フォーマット>
		a:PSX format (4096=2pai radian)
		返り値:(1,19,12)

    返り値	sin(a)
		

**8.33. 
cln	

    形式	cln(a)
		int a;

    解説	固定小数点（4096=1.0）の自然対数を固定小数点（4096=1.0）
		で求める。
		<フォーマット>
		a:(1,19,12)
		返り値:(1,19,12)

    返り値	ln(a)
		

**8.34. 
csqrt

    形式	csqrt(a)
		int a;

    解説	固定小数点（4096=1.0）の平方根を固定小数点（4096=1.0）
		で求める。
		SquareRoot12と同じ機能で必要なテーブルが小さい
		<フォーマット>
		a:(1,19,12)
		返り値:(1,19,12)

    返り値	sqrt(a)
		

**8.35. 
catan		逆正接をもとめる(１引数、小テーブル使用、中速)

    形式	catan(a)
		int a;

    解説	固定小数点（4096=1.0）のarctanの主値(-pai/2...pai/2)を
		PSX format(4096=2pai)でもとめる。
		<フォーマット>
		a:(1,19,12)
	
		返り値:(1,19,12)

    返り値	atan(a)
		

**8.36.
ratan2		逆正接をもとめる(２引数、大テーブル使用、高速)

    形式	long ratan2(y, x)
		long x,y;

    解説	arctan (-pai...pai) を PSX format (4096=2pai) で求める
		<フォーマット>
		返り値:(1,19,12)

    返り値	atan2(y,x)
	
    備考	x か y のどちらかが -2147483648 (0x80000000 =long の負の最大値)
		は返り値が不定になる


*９．ＰＭＤ関数

**9.1.
RotPMD_F3	独立頂点型フラット三角形用ＰＭＤ関数
RotPMD_G3	独立頂点型グーロー三角形用ＰＭＤ関数
RotPMD_FT3	独立頂点型フラットテクスチャ三角形用ＰＭＤ関数
RotPMD_GT3	独立頂点型グーローテクスチャ三角形用ＰＭＤ関数
RotPMD_F4	独立頂点型フラット四角形用ＰＭＤ関数
RotPMD_G4	独立頂点型グーロー四角形用ＰＭＤ関数
RotPMD_FT4	独立頂点型フラットテクスチャ四角形用ＰＭＤ関数
RotPMD_GT4	独立頂点型グーローテクスチャ四角形用ＰＭＤ関数

    形式	void RotPMD_F3(pa,ot,otlen,id,backc)
		void RotPMD_G3(pa,ot,otlen,id,backc)
		void RotPMD_FT3(pa,ot,otlen,id,backc)
		void RotPMD_GT3(pa,ot,otlen,id,backc)
		void RotPMD_F4(pa,ot,otlen,id,backc)
		void RotPMD_G4(pa,ot,otlen,id,backc)
		void RotPMD_FT4(pa,ot,otlen,id,backc)
		void RotPMD_GT4(pa,ot,otlen,id,backc)
		long *pa;		/*PRIMITIVE Gpの先頭アドレス*/
		u_long *ot;		/*OTの先頭アドレス*/
		int otlen;		/*OTの長さ（ビット数）*/
		int id;	/*ダブルバッファのID*/
		int backc;		/*backface clip ON/OFF flag(0=ON)*/

    解説	独立頂点型タイプのPRIMITIVE Gpにふくまれる
		三角形または四角形のすべてについて
		座標変換、透視変換を行ない、ＧＰＵパケットを完成し
		ＯＴにリンクする。
		SZ値が[h/2,2^16)の間に含まれるポリゴンのみリンクされる。

    返り値	なし
		
		
		

**9.9.
RotPMD_SV_F3	共有頂点型フラット三角形用ＰＭＤ関数
RotPMD_SV_G3	共有頂点型グーロー三角形用ＰＭＤ関数
RotPMD_SV_FT3	共有頂点型フラットテクスチャ三角形用ＰＭＤ関数
RotPMD_SV_GT3	共有頂点型グーローテクスチャ三角形用ＰＭＤ関数
RotPMD_SV_F4	共有頂点型フラット四角形用ＰＭＤ関数
RotPMD_SV_G4	共有頂点型グーロー四角形用ＰＭＤ関数
RotPMD_SV_FT4	共有頂点型フラットテクスチャ四角形用ＰＭＤ関数
RotPMD_SV_GT4	共有頂点型グーローテクスチャ四角形用ＰＭＤ関数

    形式	void RotPMD_SV_F3(pa,va,ot,otlen,id,backc)
		void RotPMD_SV_G3(pa,va,ot,otlen,id,backc)
		void RotPMD_SV_FT3(pa,va,ot,otlen,id,backc)
		void RotPMD_SV_GT3(pa,va,ot,otlen,id,backc)
		void RotPMD_SV_F4(pa,va,ot,otlen,id,backc)
		void RotPMD_SV_G4(pa,va,ot,otlen,id,backc)
		void RotPMD_SV_FT4(pa,va,ot,otlen,id,backc)
		void RotPMD_SV_GT4(pa,va,ot,otlen,id,backc)
		long *pa;		/*PRIMITIVE Gpの先頭アドレス*/
		long *va;		/*VERTEX Gpの先頭アドレス*/
		u_long *ot;		/*OTの先頭アドレス*/
		int otlen;		/*OTの長さ（ビット数）*/
		int id;	/*ダブルバッファのID*/
		int backc;		/*backface clip ON/OFF flag(0=ON)*/

    解説	共有頂点型タイプのPRIMITIVE Gpにふくまれる
		三角形または四角形のすべてについて
		座標変換、透視変換を行ない、ＧＰＵパケットを完成し
		ＯＴにリンクする。
		SZ値が[h/2,2^16)の間に含まれるポリゴンのみリンクされる。

    返り値	なし
		
		
		
		

*１０．クリップ演算


**10.1.
InitClip	クリップパラメータの初期化

    形式	void InitClip(evbfad,hw,vw,h,near,far)
		EVECTOR *evbfad;/* クリップベクトル情報の配列（16個）address */
		long hw,vw;	/* hw: 窓の幅 vw: 窓の高さ */
		long h;		/* h: 視点からスクリーンまでの距離 */
		long near,far;	/* near: NEARCLIP位置、far: FARCLIP位置、*/

    解説	クリップ演算に使用するパラメータを設定する。
		クリップベクトル情報の配列は16個分（176word=704byte）確保する。

    返り値	なし
		

**10.2.
Clip3F		 ３頂点のクリッピング（透視変換なし）

    形式	long Clip3F(v0,v1,v2,evmx)
		SVECTOR *v0,*v1,*v2;	/* 入力:頂点座標ベクトル 	*/
		EVECTOR **evmx;	 	/* 出力クリップベクトル情報の	*/
					/* ポインタ配列（20個）		*/

    解説	v0,v1,v2で表される３角形をInitClipで定義される６面でクリップし
		クリップ後の多角形情報をクリップベクトル情報のポインタ配列と
		頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.3.
Clip3FP		 ３頂点のクリッピング（透視変換あり） 

    形式	long Clip3FP(v0,v1,v2,evmx)
		SVECTOR *v0,*v1,*v2;	/* 入力:頂点座標ベクトル 	*/
		EVECTOR **evmx;	 	/* 出力クリップベクトル情報の	*/
					/* ポインタ配列（20個）		*/

    解説	v0,v1,v2で表される３角形をInitClipで定義される６面でクリップし

		クリップ後の多角形情報をクリップベクトル情報のポインタ配列と
		頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->sxyz.pad	/* FOG効果用内挿値(p)	*/
		evmx[i]->sxy	/* Screen 2D Vertex		*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.4.
Clip4F		 ４頂点のクリッピング（透視変換なし）

    形式	long Clip4F(v0,v1,v2,v3,evmx)
		SVECTOR *v0,*v1,*v2,*v3; /* 入力:頂点座標ベクトル	*/
		EVECTOR **evmx;		 /* 出力クリップベクトル	*/
					  * 情報のポインタ配列（20個)	*/

    解説	v0,v1,v2,v3で表される４角形(連結３角形)をInitClipで定義される
		６面でクリップし、クリップ後の多角形情報をクリップベクトル情
		報のポインタ配列と頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.5.
Clip4FP		 ４頂点のクリッピング（透視変換あり） 

    形式	long Clip4FP(v0,v1,v2,v3,evmx)
		SVECTOR *v0,*v1,*v2,*v3;	/* 入力:頂点座標ベクトル */
		EVECTOR **evmx;		  	/* 出力クリップベクトル情報 */
						/* のポインタ配列（20個） */

    解説	v0,v1,v2,v3で表される４角形(連結３角形)をInitClipで定義さ
		れる６面でクリップし、クリップ後の多角形情報をクリップベク
		トル情報のポインタ配列と頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->sxyz.pad	/* FOG効果用内挿値(p)	*/
		evmx[i]->sxy	/* Screen 2D Vertex		*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
    返り値	n: 出力頂点数。
		

**10.6.
Clip3FT		 ３頂点のクリッピング（透視変換なし）

    形式	long Clip3FT(v0,v1,v2,uv0,uv1,uv2,evmx)
		SVECTOR *v0,*v1,*v2;	/* 入力: 頂点座標ベクトル */
		short *uv0,*uv1,*uv2;	/* 入力: テクスチャ座標ベクトル */
		EVECTOR **evmx;	  	/* 出力クリップベクトル情報の	*/
					 * ポインタ配列（20個）		*/

    解説	v0,v1,v2で表される３角形をInitClipで定義される６面でクリップし
		クリップ後の多角形情報をクリップベクトル情報のポインタ配列と
		頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->txuv	/* Texture Mapping Data 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.7.
Clip3FTP	 ３頂点のクリッピング（透視変換あり） 

    形式	long Clip3FTP(v0,v1,v2,uv0,uv1,uv2,evmx)
		SVECTOR *v0,*v1,*v2;	/* 入力:頂点座標ベクトル */
		short *uv0,*uv1,*uv2;	/* 入力: テクスチャ座標ベクトル */
		EVECTOR **evmx;	  	/* 出力クリップベクトル情報の	*/
					/*ポインタ配列（20個）		*/

    解説	v0,v1,v2で表される３角形をInitClipで定義される６面でクリップし
		クリップ後の多角形情報をクリップベクトル情報のポインタ配列と
		頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->sxyz.pad	/* FOG効果用内挿値(p)	*/
		evmx[i]->sxy	/* Screen 2D Vertex		*/
		evmx[i]->txuv	/* Texture Mapping Data 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.8.
Clip4FT		 ４頂点のクリッピング（透視変換なし）

    形式	long Clip4FT(v0,v1,v2,v3,uv0,uv1,uv2,uv3,evmx)
		SVECTOR *v0,*v1,*v2,*v3;   /* 入力:頂点座標ベクトル */
		short *uv0,*uv1,*uv2,*uv3; /* 入力: テクスチャ座標ベクトル */
		EVECTOR **evmx;	  	   /* 出力クリップベクトル情報の */
					    * ポインタ配列（20個）	 */

    解説	v0,v1,v2,v3で表される４角形(連結３角形)をInitClipで定義
		される６面でクリップし、クリップ後の多角形情報をクリップ
		ベクトル情報のポインタ配列と頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->txuv	/* Texture Mapping Data 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.9.
Clip4FTP	 ４頂点のクリッピング（透視変換あり） 

    形式	long Clip4FTP(v0,v1,v2,v3,uv0,uv1,uv2,uv3,evmx)
		SVECTOR *v0,*v1,*v2,*v3;   /* 入力:頂点座標ベクトル */
		short *uv0,*uv1,*uv2,*uv3; /* 入力: テクスチャ座標ベクトル */
		EVECTOR **evmx;	  	   /* 出力クリップベクトル情報	*/
					    * のポインタ配列（20個）    */

    解説	v0,v1,v2,v3で表される４角形(連結３角形)をInitClipで定義
		される６面でクリップし、クリップ後の多角形情報をクリップ
		ベクトル情報のポインタ配列と頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->sxyz.pad	/* FOG効果用内挿値(p)	*/
		evmx[i]->sxy	/* Screen 2D Vertex		*/
		evmx[i]->txuv	/* Texture Mapping Data 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.10.
Clip3G		 ３頂点のクリッピング（透視変換なし）

    形式	long Clip3G(v0,v1,v2,rgb0,rgb1,rgb2,evmx)
		SVECTOR *v0,*v1,*v2;		/* 入力: 頂点座標ベクトル */
		CVECTOR *rgb0,*rgb1,*rgb2;	/* 入力: 頂点色情報 */
		EVECTOR **evmx;	  		/* 出力クリップベクトル情報 */
						 * のポインタ配列（20個）   */

    解説	v0,v1,v2で表される３角形をInitClipで定義される６面で
		クリップし、クリップ後の多角形情報をクリップベクトル
		情報のポインタ配列と頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->rgb	/* Vertex Color Data	 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.11.
Clip3GP		 ３頂点のクリッピング（透視変換あり） 

    形式	long Clip3GP(v0,v1,v2,rgb0,rgb1,rgb2,evmx)
		SVECTOR *v0,*v1,*v2;		/* 入力:頂点座標ベクトル */
		CVECTOR *rgb0,*rgb1,*rgb2;	/* 入力: 頂点色情報 */
		EVECTOR **evmx;	  		/* 出力クリップベクトル情報 */
						 * のポインタ配列（20個）   */

    解説	v0,v1,v2で表される３角形をInitClipで定義される６面で
		クリップし、クリップ後の多角形情報をクリップベクトル
		情報のポインタ配列と頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->sxyz.pad	/* FOG効果用内挿値(p)	*/
		evmx[i]->sxy	/* Screen 2D Vertex		*/
		evmx[i]->rgb	/* Vertex Color Data	 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.12.
Clip4G		 ４頂点のクリッピング（透視変換なし）

    形式	long Clip4G(v0,v1,v2,v3,rgb0,rgb1,rgb2,rgb3,evmx)
		SVECTOR *v0,*v1,*v2,*v3;	/* 入力:頂点座標ベクトル */
		CVECTOR *rgb0,*rgb1,*rgb2,*rgb3;/* 入力: 頂点色情報 */
		EVECTOR **evmx;	  	/* 出力クリップベクトル情報の 	*/
					/* ポインタ配列（20個		*/

    解説	v0,v1,v2,v3で表される４角形(連結３角形)をInitClipで定義
		される６面でクリップし、クリップ後の多角形情報をクリップ
		ベクトル情報のポインタ配列と頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->rgb	/* Vertex Color Data	 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.13.
Clip4GP		 ４頂点のクリッピング（透視変換あり） 

    形式	long Clip4GP(v0,v1,v2,v3,rgb0,rgb1,rgb2,rgb3,evmx)
		SVECTOR *v0,*v1,*v2,*v3;	 /* 入力:頂点座標ベクトル */
		CVECTOR *rgb0,*rgb1,*rgb2,*rgb3; /* 入力: 頂点色情報 */
		EVECTOR **evmx;	  		 /* 出力クリップベクトル情報 */
						  * のポインタ配列（20個）   */

    解説	v0,v1,v2,v3で表される４角形(連結３角形)をInitClipで定義
		される６面でクリップし、クリップ後の多角形情報をクリップ
		ベクトル情報のポインタ配列と頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->sxyz.pad	/* FOG効果用内挿値(p)	*/
		evmx[i]->sxy	/* Screen 2D Vertex		*/
		evmx[i]->rgb	/* Vertex Color Data	 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.14.
Clip3GT		 ３頂点のクリッピング（透視変換なし）

    形式	long Clip3GT(v0,v1,v2,uv0,uv1,uv2,rgb0,rgb1,rgb2,evmx)
		SVECTOR *v0,*v1,*v2;	/* 入力: 頂点座標ベクトル */
		short *uv0,*uv1,*uv2;	/* 入力: テクスチャ座標ベクトル */
		CVECTOR *rgb0,*rgb1,*rgb2;	/* 入力: 頂点色情報 */
		EVECTOR **evmx;	  /* 出力クリップベクトル情報のポインタ配列（
		20個） */

    解説	v0,v1,v2で表される３角形をInitClipで定義される６面でクリップし、
		クリップ後の多角形情報をクリップベクトル情報のポインタ配列と頂
		点数で
		出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->rgb	/* Vertex Color Data	 	*/
		evmx[i]->txuv	/* Texture Mapping Data 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.15.
Clip3GTP	 ３頂点のクリッピング（透視変換あり） 

    形式	long Clip3GTP(v0,v1,v2,uv0,uv1,uv2,rgb0,rgb1,rgb2,evmx)
		SVECTOR *v0,*v1,*v2;	/* 入力:頂点座標ベクトル */
		short *uv0,*uv1,*uv2;	/* 入力: テクスチャ座標ベクトル */
		CVECTOR *rgb0,*rgb1,*rgb2;	/* 入力: 頂点色情報 */
		EVECTOR **evmx;	  /* 出力クリップベクトル情報のポインタ配列（
		20個） */

    解説	v0,v1,v2で表される３角形をInitClipで定義される６面でクリップし、
		クリップ後の多角形情報をクリップベクトル情報のポインタ配列と
		頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->sxyz.pad	/* FOG効果用内挿値(p)	*/
		evmx[i]->sxy	/* Screen 2D Vertex		*/
		evmx[i]->rgb	/* Vertex Color Data	 	*/
		evmx[i]->txuv	/* Texture Mapping Data 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.16.
Clip4GT		 ４頂点のクリッピング（透視変換なし）

    形式	long Clip4GT(v0,v1,v2,v3,uv0,uv1,uv2,uv3,rgb0,rgb1,rgb2,rgb3,evmx)
		SVECTOR *v0,*v1,*v2,*v3;   /* 入力:頂点座標ベクトル */
		short *uv0,*uv1,*uv2,*uv3; /* 入力: テクスチャ座標ベクトル */
		CVECTOR *rgb0,*rgb1,*rgb2,*rgb3; /* 入力: 頂点色情報 */
		EVECTOR **evmx;		/* 出力クリップベクトル情報の	*/
					 * ポインタ配列（20個）		*/

    解説	v0,v1,v2,v3で表される４角形(連結３角形)をInitClipで定義
		される６面でクリップし、クリップ後の多角形情報をクリップ
		ベクトル情報のポインタ配列と頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->rgb	/* Vertex Color Data	 	*/
		evmx[i]->txuv	/* Texture Mapping Data 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		

**10.17.
Clip4GTP	 ４頂点のクリッピング（透視変換あり） 

    形式	long Clip4GTP(v0,v1,v2,v3,uv0,uv1,uv2,uv3,rgb0,rgb1,rgb2,rgb3,evmx)
		SVECTOR *v0,*v1,*v2,*v3;   /* 入力:頂点座標ベクトル */
		short *uv0,*uv1,*uv2,*uv3; /* 入力: テクスチャ座標ベクトル */
		CVECTOR *rgb0,*rgb1,*rgb2,*rgb3; /* 入力: 頂点色情報 */
		EVECTOR **evmx;	  		/* 出力クリップベクトル情報 */
						 * のポインタ配列（20個） */

    解説	v0,v1,v2,v3で表される４角形(連結３角形)をInitClipで定義
		される６面でクリップし、クリップ後の多角形情報をクリップ
		ベクトル情報のポインタ配列と頂点数で出力する。
		有効な出力クリップベクトル情報：
		
		evmx[i]->v	/* Object(Local) 3D Vertex 	*/
		evmx[i]->sxyz	/* Screen 3D Vertex		*/
		evmx[i]->sxyz.pad	/* FOG効果用内挿値(p)	*/
		evmx[i]->sxy	/* Screen 2D Vertex		*/
		evmx[i]->rgb	/* Vertex Color Data	 	*/
		evmx[i]->txuv	/* Texture Mapping Data 	*/
		evmx[i]->chx	/* chx = vz*(hw/2)/h　 		*/
		evmx[i]->chy	/* chy = vz*(vw/2)/h　 		*/
		
		* ポインタ配列はワークエリアを含めて（20個＝80byte）確保する。
		
		

    返り値	n: 出力頂点数。
		
		

*１１．マクロ用関数

**11.1.
RotTransPers_nom    座標変換と透視変換を行なう

    形式	void RotTransPers_nom(v0)
		SVECTOR *v0;	          /*入力:頂点座標ベクトル*/

    解説	座標ベクトル v0 を回転マトリックスで
		座標変換したあと透視変換を行ない、スクリーン座標
		sx,sy,sz、デプスキューイング用の内挿値pを
		をGTE内部レジスターに保持する。
		<引数および内部データフォーマット>
		v0->vx,vy,vz : (1,15,0)
		sx : (1,15,0)
		sy : (1,15,0)
		sz : (0,16,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	なし
		注意
		sz はマクロ read_sz2 で、
		(sx,sy)はマクロ read_sxsy2 で、
		p はマクロ read_p で、
		flagはマクロ read_flag で読む。
		

**11.2.
RotTransPers3_nom   ３頂点の座標変換と透視変換を行なう

    形式	void RotTransPers3_nom(v0,v1,v2)
		SVECTOR *v0,*v1,*v2;	  /*入力:頂点座標ベクトル*/

    解説	３つの座標ベクトル v0,v1,v2 を
		回転マトリックスで座標変換したあと透視変換を行ない、
		３つのスクリーン座標 sx0,sy0,sz0,sx1,sy1,sz1,sx2,sy2,sz2
		v2 に対応するデプスキューイング用の内挿値pを
		をGTE内部レジスターに保持する。
		<引数および内部データフォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		sx0,sy0,sz0 : (1,15,0),(1,15,0),(0,16,0)
		sx1,sy1,sz1 : (1,15,0),(1,15,0),(0,16,0)
		sx2,sy2,sz2 : (1,15,0),(1,15,0),(0,16,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	なし
		注意
		(sz0,sz1,sz2)はマクロ read_sz_fifo3 で、
		((sx0,sy0),(sx1,sy1),(sx2,sy2))はマクロ read_sxsy_fifo3 で、
		p はマクロ read_p で、
		flagはマクロ read_flag で読む。
		
		

**11.2.1.
RotTransPers4_nom   ３頂点の座標変換と透視変換を行なう

    形式	void RotTransPers4_nom(v0,v1,v2,v3)
		SVECTOR *v0,*v1,*v2,*v3;	/*入力:頂点座標ベクトル*/

    解説	３つの座標ベクトル v0,v1,v2,v3 を
		回転マトリックスで座標変換したあと透視変換を行ない、
		３つのスクリーン座標 (sz0),(sx1,sy1,sz1),(sx2,sy2,sz2),(sx3,s
		y3,sz3)
		v3 に対応するデプスキューイング用の内挿値pを
		をGTE内部レジスターに保持する。
		<引数および内部データフォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		sx0,sy0,sz0 : (1,15,0),(1,15,0),(0,16,0)
		sx1,sy1,sz1 : (1,15,0),(1,15,0),(0,16,0)
		sx2,sy2,sz2 : (1,15,0),(1,15,0),(0,16,0)
		sx3,sy3,sz3 : (1,15,0),(1,15,0),(0,16,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	flag
		注意
		(sz0,sz1,sz2,sz3)はマクロ read_sz_fifo4 で、
		((sx1,sy1),(sx2,sy2),(sx3,sy3))はマクロ read_sxsy_fifo3 で、
		p はマクロ read_p で読む。
		(sx0,sy0)はレジスターv1 に返る。
		flagはレジスターv0 に返る。
		

**11.3.
RotTrans_nom        回転マトリックスで座標変換を行なう

    形式	void RotTrans_nom(v0)
		SVECTOR *v0;	          /*入力:ベクトル*/

    解説	v1 = RTM*v0
		<引数フォーマットおよび内部データフォーマット>
		v0->vx,vy,vz : (1,15,0)
		v1->vx,vy,vz : (1,31,0)
		flag : (0,32,0)

    返り値	なし
		注意
		(v1->vx,v1->vy,v1->vz)はマクロ read_mt で、
		flagはマクロ read_flag で読む。
		

**11.4.
RotAverage3_nom	３点の座標変換と透視変換を行ない
		デプスキューイング用の内挿値とＺ値の平均値を求める

    形式	void RotAverage3_nom(v0,v1,v2)
		SVECTOR *v0,*v1,*v2;	  /*入力:ベクトル*/

    解説	ローカル座標ベクトル v0,v1,v2 を回転マトリックスで
		座標変換したあと透視変換を行ない、
		３つのスクリーン座標 sx0,sy0,sz0,sx1,sy1,sz1,sx2,sy2,sz2
		v2 に対応するデプスキューイング用の内挿値 p 
		３つのスクリーン座標のＺ値の平均値 otz 
		をGTE内部レジスターに保持する。
		<引数および内部データフォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		sx0,sy0,sz0 : (1,15,0),(1,15,0),(0,16,0)
		sx1,sy1,sz1 : (1,15,0),(1,15,0),(0,16,0)
		sx2,sy2,sz2 : (1,15,0),(1,15,0),(0,16,0)
		p : (0,20,12)
		flag : (0,32,0)

    返り値	なし
		注意
		(sz0,sz1,sz2)はマクロ read_sz_fifo3 で、
		((sx0,sy0),(sx1,sy1),(sx2,sy2))はマクロ read_sxsy_fifo3 で、
		p はマクロ read_p で、
		otz はマクロ read_otz で読む。
		flagは v0 に返る。
		

**11.5.
RotNclip3_nom 	３点の座標変換と透視変換を行ない
		デプスキューイング用の内挿値と外積値を求める

    形式	void RotNclip3_nom(v0,v1,v2)
		SVECTOR *v0,*v1,*v2;	  /*入力:ベクトル*/

    解説	ローカル座標ベクトル v0,v1,v2 を回転マトリックスで
		座標変換したあと透視変換を行ない、
		３つのスクリーン座標 sx0,sy0,sz0,sx1,sy1,sz1,sx2,sy2,sz2
		v2 に対応するデプスキューイング用の内挿値 p 
		(sx0,sy0),(sx1,sy1),(sx2,sy2)の外積値 opz
		をGTE内部レジスターに保持する。
		<引数および内部データフォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		sx0,sy0,sz0 : (1,15,0),(1,15,0),(0,16,0)
		sx1,sy1,sz1 : (1,15,0),(1,15,0),(0,16,0)
		sx2,sy2,sz2 : (1,15,0),(1,15,0),(0,16,0)
		p : (0,20,12)
		otz : (0,32,0)
		flag : (0,32,0)

    返り値	なし
		注意
		(sz0,sz1,sz2)はマクロ read_sz_fifo3 で、
		((sx0,sy0),(sx1,sy1),(sx2,sy2))はマクロ read_sxsy_fifo3 で、
		p はマクロ read_p で、
		opz はマクロ read_opz で読む。
		flagは v0 に返る。
		

**11.6.
RotAverageNclip3_nom 	３点の座標変換と透視変換を行ない
			内挿値とＺ値の平均値と外積値を求める

    形式	void RotAverageNclip3_nom(v0,v1,v2)
		SVECTOR *v0,*v1,*v2;	  /*入力:ベクトル*/

    解説	ローカル座標ベクトル v0,v1,v2 を回転マトリックスで
		座標変換したあと透視変換を行ない、
		３つのスクリーン座標 sx0,sy0,sz0,sx1,sy1,sz1,sx2,sy2,sz2
		v2 に対応するデプスキューイング用の内挿値 p
		スクリーン座標の３つのＺ値の平均値 otz 
		(sx0,sy0),(sx1,sy1),(sx2,sy2)の外積値 opz
		をGTE内部レジスターに保持する。
		<引数および内部データフォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		sx0,sy0,sz0 : (1,15,0),(1,15,0),(0,16,0)
		sx1,sy1,sz1 : (1,15,0),(1,15,0),(0,16,0)
		sx2,sy2,sz2 : (1,15,0),(1,15,0),(0,16,0)
		p : (0,20,12)
		otz : (0,32,0)
		flag : (0,32,0)

    返り値	なし
		注意
		(sz0,sz1,sz2)はマクロ read_sz_fifo3 で、
		((sx0,sy0),(sx1,sy1),(sx2,sy2))はマクロ read_sxsy_fifo3 で、
		p はマクロ read_p で、
		otz はマクロ read_otz で、
		opz はマクロ read_opz で読む。
		flagは v0 に返る。
		

**11.7.
RotAverageNclipColorDpq3_nom	３点の座標変換と透視変換と
				デプスキューイングを行なう

    形式	void RotAverageNclipColorDpq3_nom(v0,v1,v2,v3,v4,v5,v6)
		SVECTOR *v0,*v1,*v2;	  /*入力:ベクトル*/
		SVECTOR *v3,*v4,*v5;	  /*入力:法線ベクトル*/
		CVECTOR *v6;	          /*入力:原色ベクトル*/

    解説	ローカル座標ベクトル v0,v1,v2 を回転マトリックスで
		座標変換したあと透視変換を行ない、
		３つのスクリーン座標 sx0,sy0,sz0,sx1,sy1,sz1,sx2,sy2,sz2
		３つのスクリーン座標のＺ値の平均値 otz
		(sx0,sy0),(sx1,sy1),(sx2,sy2)の外積値 opz
		をGTE内部レジスターに保持する。
		またこのとき求められるデプスキューイング用内挿値 p を
		以下の計算で使う。
		
		(LLV0,LLV1,LLV2) = LLM*(v3,v4,v5)
		(LC0,LC1,LC2) = BK + LCM*(LLV0,LLV1,LLV2)
		(v7,v8,v9) = p*v6*(LC0,LC1,LC2) + (1-p)*FC
		
		<引数および内部データフォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		v3,v4,v5->vx,vy,vz : (1,3,12)
		v6->r,g,b : (0,8,0)
		sx0,sy0,sz0 : (1,15,0),(1,15,0),(0,16,0)
		sx1,sy1,sz1 : (1,15,0),(1,15,0),(0,16,0)
		sx2,sy2,sz2 : (1,15,0),(1,15,0),(0,16,0)
		v7,v8,v9->r,g,b : (0,8,0)
		otz : (0,32,0)
		flag : (0,32,0)

    返り値	なし
		注意
		(sz0,sz1,sz2)はマクロ read_sz_fifo3 で、
		((sx0,sy0),(sx1,sy1),(sx2,sy2))はマクロ read_sxsy_fifo3 で、
		((r0,g0,b0),(r1,g1,b1),(r2,g2,b2))はマクロ read_rgb_fifo で、
		p はマクロ read_p で、
		otz はマクロ read_otz で、
		opz はマクロ read_opz で読む。
		flagは v0 に返る。
		

**11.8.
RotAverageNclipColorCol3_nom    ３点の座標変換と透視変換を行ない
				カラーを求める

    形式	void RotAverageNclipColorCol3_nom(v0,v1,v2,v3,v4,v5,v6)
		SVECTOR *v0,*v1,*v2;	  /*入力:ベクトル*/
		SVECTOR *v3,*v4,*v5;	  /*入力:法線ベクトル*/
		CVECTOR *v6;	          /*入力:原色ベクトル*/

    解説	ローカル座標ベクトル v0,v1,v2 を回転マトリックスで
		座標変換したあと透視変換を行ない、
		３つのスクリーン座標 sx0,sy0,sz0,sx1,sy1,sz1,sx2,sy2,sz2
		３つのスクリーン座標のＺ値の平均値 otz
		(sx0,sy0),(sx1,sy1),(sx2,sy2)の外積値 opz
		をGTE内部レジスターに保持する。
		
		(LLV0,LLV1,LLV2) = LLM*(v3,v4,v5)
		(LC0,LC1,LC2) = BK + LCM*(LLV0,LLV1,LLV2)
		(v7,v8,v9) = v6*(LC0,LC1,LC2)
		
		<引数および内部データフォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		v3,v4,v5->vx,vy,vz : (1,3,12)
		sx0,sy0,sz0 : (1,15,0),(1,15,0),(0,16,0)
		sx1,sy1,sz1 : (1,15,0),(1,15,0),(0,16,0)
		sx2,sy2,sz2 : (1,15,0),(1,15,0),(0,16,0)
		v6->r,g,b : (0,8,0)
		v7,v8,v9->r,g,b : (0,8,0)
		otz : (0,32,0)
		flag : (0,32,0)

    返り値	なし
		注意
		(sz0,sz1,sz2)はマクロ read_sz_fifo3 で、
		((sx0,sy0),(sx1,sy1),(sx2,sy2))はマクロ read_sxsy_fifo3 で、
		((r0,g0,b0),(r1,g1,b1),(r2,g2,b2))はマクロ read_rgb_fifo で、
		p はマクロ read_p で、
		otz はマクロ read_otz で、
		opz はマクロ read_opz で読む。
		flagはレジスター v0 に返る。
		
		

**11.9.
RotColorDpq_nom     座標変換と透視変換とデプスキューイングを行なう

    形式	void RotColorDpq_nom(v0,v1,v2)
		SVECTOR *v0;	          /*入力:ベクトル*/
		SVECTOR *v1;	          /*入力:法線ベクトル*/
		CVECTOR *v2;	          /*入力:原色ベクトル*/

    解説	点 v0 を回転マトリックスで座標変換したあと透視変換を行ない、
		スクリーン座標 (sx,sy,sz) をGTE内部レジスターに保持する。
		またこのとき求められるデプスキューイング用内挿値 p を以下の計
		算で使い
		求められる色ベクトル v3 を内部レジスターに保持する。
		
		LLV = LLM*v1
		LC = BK + LCM*LLV
		v3 = p*v2*LC + (1-p)*FC
		
		<引数および内部データフォーマット>
		v0->vx,vy,vz : (1,15,0)
		v1->vx,vy,vz : (1,3,12)
		sx,sy,sz : (1,15,0),(1,15,0),(0,16,0)
		v2->r,g,b : (0,8,0)
		v3->r,g,b : (0,8,0)
		flag : (0,32,0)

    返り値	なし
		注意
		sz はマクロ read_sz2 で、
		(sx,sy)はマクロ read_sxsy2 で、
		p はマクロ read_p で、
		v3 はマクロ read_rgb2 で読む。
		flagはレジスター v0 に返る。
		

**11.10.
RotColorDpq3_nom  ３点の座標変換と透視変換とデプスキューイングを行なう


    形式	long RotColorDpq3_nom(v0,v1,v2,v3,v4,v5,v6)
		SVECTOR *v0,*v1,*v2;	  /*入力:ベクトル*/
		SVECTOR *v3,*v4,*v5;	  /*入力:法線ベクトル*/
		CVECTOR *v6;	          /*入力:原色ベクトル*/

    解説	３点 v0,v1,v2 を回転マトリックスで座標変換したあと
		透視変換を行ない、
		３つのスクリーン座標 sx0,sy0,sz0,sx1,sy1,sz1,sx2,sy2,sz2
		をGTE内部レジスターに保持する。
		またこのとき求められるデプスキューイング用内挿値 p を
		以下の計算で使い、求められる色ベクトルを内部レジスタに保持する
		。
		
		(LLV0,LLV1,LLV2) = LLM*(v3,v4,v5)
		(LC0,LC1,LC2) = BK + LCM*(LLV0,LLV1,LLV2)
		(v7,v8,v9) = p*v6*(LC0,LC1,LC2) + (1-p)*FC
		
		<引数および内部データフォーマット>
		v0,v1,v2->vx,vy,vz : (1,15,0)
		v3,v4,v5->vx,vy,vz : (1,3,12)
		v6->r,g,b : (0,8,0)
		sxy0,sxy1,sxy2 : (1,15,0),(1,15,0)
		v7,v8,v9->r,g,b : (0,8,0)
		flag : (0,32,0)

    返り値	なし
		注意
		(sz0,sz1,sz2) はマクロ read_sz_fifo3 で、
		((sx0,sy0),(sx2,sy2),(sx2,sy2))はマクロ read_sxsy_fifo3 で、
		p はマクロ read_p で、
		v7,v8,v9 はマクロ read_rgb_fifo で読む。
		flagはレジスター v0 に返る。
		

**11.11. 
NormalColor_nom	法線ベクトルからローカルカラーを求める

    形式	void NormalColor_nom(v0)
		SVECTOR *v0;	/*入力:法線ベクトル*/

    解説	LLV = LLM*v0
		v1 = BK + LCM*LLV
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		v1->r,g,b : (0,8,0)

    返り値	なし
		注意
		(v1->r,v1->g,v1->b)はマクロ read_rgb2 で読む。
		

**11.12. 
NormalColor3_nom    ３つの法線ベクトルから３つのローカルカラーを求める

    形式	void NormalColor3_nom(v0,v1,v2)
		SVECTOR *v0,*v1,*v2;		/*入力:法線ベクトル*/
		

    解説	(LLV0,LLV1,LLV2) = LLM*(v0,v1,v2)
		(v3,v4,v5) = BK + LCM*(LLV0,LLV1,LLV2)
		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,3,12)
		v3,v4,v5->r,g,b : (0,8,0)

    返り値	なし
		注意
		(v3,v4,v5)はマクロ read_rgb_fifo で読む。
		

**11.13. 
NormalColorDpq_nom	法線ベクトルからローカルカラーを求め
			さらにデプスキューイングを行なう

    形式	void NormalColorDpq_nom(v0,v1,p)
		SVECTOR *v0;	/*入力:法線ベクトル*/
		CVECTOR *v1;	/*入力:原色ベクトル*/
		long p;		/*入力:内挿値*/

    解説	LLV = LLM*v0
		LC = BK + LCM*LLV
		v2 = (1-p)*v1*LC + p*FC
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		v1->r,g,b : (0,8,0)
		p : (0,20,12)
		v2->r,g,b : (0,8,0)

    返り値	なし
		注意
		(v2->r,v2->g,v2->b)はマクロ read_rgb2 で読む。
		

**11.14. 
NormalColorDpq3_nom	３つの法線ベクトルからローカルカラーを求め
			さらにデプスキューイングを行なう

    形式	void NormalColorDpq3_nom(v0,v1,v2,v3,p)
		SVECTOR *v0,*v1,*v2;		/*入力:法線ベクトル*/
		CVETCOR *v3;			/*入力:原色ベクトル*/
		long p;				/*入力:内挿値*/

    解説	(LLV0,LLV1,LLV2) = LLM*(v0,v1,v2)
		(LC0,LC1,LC2) = BK + LCM*(LLV0,LLV1,LLV2)
		(v4,v5,v6) = p*v3*(LC0,LC1,LC2) + (1-p)*FC
		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,3,12)
		v3->r,g,b : (0,8,0)
		p : (0,20,12)
		v4,v5,v6->r,g,b : (0,8,0)

    返り値	なし
		注意
		(v4,v5,v6)はマクロ read_rgb_fifo で読む。
		

**11.15. 
NormalColorCol_nom	法線ベクトルからローカルカラーを求める

    形式	void NormalColorCol_nom(v0,v1)
		SVECTOR *v0;	/*入力:法線ベクトル*/
		CVECTOR *v1;	/*入力:原色ベクトル*/

    解説	LLV = LLM*v0
		LC = BK + LCM*LLV
		v2 = v1*LC
		<引数フォーマット>
		v0->vx,vy,vz : (1,3,12)
		v1->r,g,b : (0,8,0)
		v2->r,g,b : (0,8,0)

    返り値	なし
		注意
		(v2->r,v2->g,v2->b)はマクロ read_rgb2 で読む。
		

**11.16. 
NormalColorCol3_nom	３つの法線ベクトルからローカルカラーを求める

    形式	void NormalColorCol3_nom(v0,v1,v2,v3)
		SVECTOR *v0,*v1,*v2;		/*入力:法線ベクトル*/
		CVETCOR *v3;			/*入力:原色ベクトル*/

    解説	(LLV0,LLV1,LLV2) = LLM*(v0,v1,v2)
		(LC0,LC1,LC2) = BK + LCM*(LLV0,LLV1,LLV2)
		(v4,v5,v6) = v3*(LC0,LC1,LC2)
		<引数フォーマット>
		v0,v1,v2->vx,vy,vz : (1,3,12)
		v3->r,g,b : (0,8,0)
		v4,v5,v6->r,g,b : (0,8,0)

    返り値	なし
		注意
		(v4,v5,v6)はマクロ read_rgb_fifo で読む。
		

*１２．デバイド関数


**12.1.
DivideF3	フラット３角形の分割

    形式	u_long *DivideF3(v0,v1,v2,rgbc,s,ot,divp)
		SVECTOR *v0,*v1,*v2;	/*入力:頂点座標ベクトル*/
		CVECTOR *rgbc;		/*入力:色ベクトル(+code)*/
		POLY_F3 *s;		/*GPUパケットバッファのアドレス*/
		u_long *ot;		/*ＯＴエントリ*/
		DIVPOLYGON3 *divp;	/*入力:デバイド用ワークエリア*/  

    解説	フラット３角形の分割処理プログラム。
		頂点座標ベクトルと色ベクトルで表されるフラット３角形を
		divp->ndivの値のもとに分割し、OTへ登録する。
	
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割
	
    返り値	更新されたGPUパケットバッファのアドレス
		注意
		divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		otはＯＴエントリ（libgpu参照）
		

**12.2.
DivideF4	フラット４角形の分割

    形式	u_long *DivideF4(v0,v1,v2,v3,rgbc,s,ot,divp)
		SVECTOR *v0,*v1,*v2,*v3;/*入力:頂点座標ベクトル*/
		CVECTOR *rgbc;		/*入力:色ベクトル(+code)*/
		POLY_F4 *s;		/*GPUパケットバッファのアドレス*/
		u_long *ot;		/*ＯＴエントリ*/
		DIVPOLYGON4 *divp;	/*入力:デバイド用ワークエリア*/  

    解説	フラット４角形の分割処理プログラム。
		頂点座標ベクトルと色ベクトルで表されるフラット４角形を
		divp->ndivの値のもとに分割し、OTへ登録する。
	
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
		注意
		divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		otはＯＴエントリ（libgpu参照）
		

**12.3.
DivideFT3	フラットテクスチャ３角形の分割

    形式	u_long *DivideFT3(v0,v1,v2,uv0,uv1,uv2,rgbc,s,ot,divp)
		SVECTOR *v0,*v1,*v2;	/*入力:頂点座標ベクトル*/
		u_long *uv0,*uv1,*uv2;	/* 入力: テクスチャ座標ベクトル	*/ 
		/* uv0:uv0+clut,uv1:uv1+tpage	*/
		CVECTOR *rgbc;		/*入力:色ベクトル(+code)*/
		POLY_FT3 *s;		/*GPUパケットバッファのアドレス*/
		u_long *ot;		/*ＯＴエントリ*/
		DIVPOLYGON3 *divp;	/*入力:デバイド用ワークエリア*/  

    解説	フラットテクスチャ３角形の分割処理プログラム。
		頂点座標ベクトルとテクスチャ座標ベクトルと色ベクトルで表される
		
		フラットテクスチャ３角形をdivp->ndivの値のもとに分割し、OTへ登
		録する。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
		注意
		divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		otはＯＴエントリ（libgpu参照）
		

**12.4.
DivideFT4	フラットテクスチャ４角形の分割

    形式	u_long *DivideFT4(v0,v1,v2,v3,uv0,uv1,uv2,uv3,rgbc,s,ot,divp)
		SVECTOR *v0,*v1,*v2,*v3;    /*入力:頂点座標ベクトル*/
		u_long *uv0,*uv1,*uv2,*uv3; /* 入力: テクスチャ座標ベクトル*/
					/* uv0:uv0+clut,uv1:uv1+tpage	*/
		CVECTOR *rgbc;		/*入力:色ベクトル(+code)*/
		POLY_FT4 *s;		/*GPUパケットバッファのアドレス*/
		u_long *ot;		/*ＯＴエントリ*/
		DIVPOLYGON4 *divp;	/*入力:デバイド用ワークエリア*/  

    解説	フラットテクスチャ４角形の分割処理プログラム。
		頂点座標ベクトルとテクスチャ座標ベクトルと色ベクトルで表される
		
		フラットテクスチャ４角形をdivp->ndivの値のもとに分割し、OTへ登
		録する。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
		注意
		divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		otはＯＴエントリ（libgpu参照）
		

**12.5.
DivideG3	グーロー３角形の分割

    形式	u_long *DivideG3(v0,v1,v2,rgb0,rgb1,rgb2,s,ot,divp)
		SVECTOR *v0,*v1,*v	2;	/*入力:頂点座標ベクトル*/
		CVECTOR *rgb0,*rgb1,*rgb2;	/*入力:色ベクトル*/
						/* rgb0:rgb0+code */
		POLY_G3 *s;		/*GPUパケットバッファのアドレス*/
		u_long *ot;		/*ＯＴエントリ*/
		DIVPOLYGON3 *divp;	/*入力:デバイド用ワークエリア*/  

    解説	グーロー３角形の分割処理プログラム。
		頂点座標ベクトルと色ベクトルで表されるグーロー３角形を
		divp->ndivの値のもとに分割し、OTへ登録する。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
		注意
		divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		otはＯＴエントリ（libgpu参照）

**12.6.
DivideG4	グーロー４角形の分割

    形式	u_long *DivideG4(v0,v1,v2,v3,rgb0,rgb1,rgb2,rgb3,s,ot,divp)
		SVECTOR *v0,*v1,*v2,*v3;	/*入力:頂点座標ベクトル*/
		CVECTOR *rgb0,*rgb1,*rgb2,*rgb3;/*入力:色ベクトル*/
		/* rgb0:rgb0+code */
		POLY_G4 *s;		/*GPUパケットバッファのアドレス*/
		u_long *ot;		/*ＯＴエントリ*/
		DIVPOLYGON4 *divp;	/*入力:デバイド用ワークエリア*/  

    解説	グーロー４角形の分割処理プログラム。
		頂点座標ベクトルと色ベクトルで表されるグーロー４角形を
		divp->ndivの値のもとに分割し、OTへ登録する。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
		注意
		divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		otはＯＴエントリ（libgpu参照）
		

**12.7.
DivideGT3	グーローテクスチャ３角形の分割

    形式	u_long *DivideGT3(v0,v1,v2,uv0,uv1,uv2,rgb0,rgb1,rgb2,s,ot,divp)
		SVECTOR *v0,*v1,*v2;	/*入力:頂点座標ベクトル*/
		u_long *uv0,*uv1,*uv2;	/* 入力: テクスチャ座標ベクトル	*/
					/* uv0:uv0+clut,uv1:uv1+tpage	*/
		CVECTOR *rgb0,*rgb1,*rgb2;	/*入力:色ベクトル*/
						/* rgb0:rgb0+code */
		POLY_GT3 *s;		/*GPUパケットバッファのアドレス*/
		u_long *ot;		/*ＯＴエントリ*/
		DIVPOLYGON3 *divp;	/*入力:デバイド用ワークエリア*/  

    解説	グーローテクスチャ３角形の分割処理プログラム。
		頂点座標ベクトルとテクスチャ座標ベクトルと色ベクトルで表される
		
		グーローテクスチャ３角形をdivp->ndivの値のもとに分割し、OTへ登
		録する。
	
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
		注意
		divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		otはＯＴエントリ（libgpu参照）
		

**12.8.
DivideGT4	グーローテクスチャ４角形の分割

    形式	u_long *DivideGT4(v0,v1,v2,v3,uv0,uv1,uv2,uv3,rgb0,rgb1,rgb2,rgb3,s,ot,divp)
		SVECTOR *v0,*v1,*v2,*v3;   /*入力:頂点座標ベクトル*/
		u_long *uv0,*uv1,*uv2,*uv3;/* 入力: テクスチャ座標ベクトル */
					   /* uv0:uv0+clut,uv1:uv1+tpage */
		CVECTOR *rgb0,*rgb1,*rgb2,*rgb3;	/*入力:色ベクトル*/
							/* rgb0:rgb0+code */
		POLY_GT4 *s;		/*GPUパケットバッファのアドレス*/
		u_long *ot;		/*ＯＴエントリ*/
		DIVPOLYGON4 *divp;	/*入力:デバイド用ワークエリア*/  

    解説	グーローテクスチャ４角形の分割処理プログラム。
		頂点座標ベクトルとテクスチャ座標ベクトルと色ベクトルで表される
		
		グーローテクスチャ４角形をdivp->ndivの値のもとに分割し、OTへ登
		録する。
	
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
		注意
		divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		otはＯＴエントリ（libgpu参照）
		

**12.9.
RCpolyF3	フラット３角形の分割

    形式	u_long *RCpolyF3(s,divp)
		POLY_F3 *s;		/* GPUパケットバッファのアドレス*/
		DIVPOLYGON3 *divp;	/* デバイド用ワークエリア*/  

    解説	フラット３角形の分割処理を行なう再帰プログラム。
		デバイド用ワークエリアに以下のデータの設定がなされているものと
		する。
		u_long 	ndiv：	 	/* 分割数 */		
		u_long 	pih,piv： 	/* 表示画面の解像度(クリップ用) */
		u_short clut,tpage：	/* CBA & TSB */
		CVECTOR	rgbc：		/* 色ベクトル(+code) */
		u_long	*ot;		/* ＯＴエントリ */
		RVECTOR r0,r1,r2; /* 分割頂点ベクトル情報（RVECTOR参照）*/
		 		  /* 各頂点の2D,3D,Texture座標や色 */
		divp->cr[0].r0 = &divp->r0;	
		divp->cr[0].r1 = &divp->r1;	
		divp->cr[0].r2 = &divp->r2;	
		

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	otはＯＴエントリ（libgpu参照）
		

**12.10.
RCpolyF4	フラット３角形の分割

    形式	u_long *RCpolyF4(s,divp)
		POLY_F4 *s;		/* GPUパケットバッファのアドレス*/
		DIVPOLYGON4 *divp;	/* デバイド用ワークエリア*/  

    解説	フラット４角形の分割処理を行なう再帰プログラム。
		デバイド用ワークエリアに以下のデータの設定がなされているものと
		する。
		
		u_long 	ndiv： 		/* 分割数 */		
		u_long 	pih,piv： 	/* 表示画面の解像度(クリップ用) */
		u_short clut,tpage：	/* CBA & TSB */
		CVECTOR	rgbc：		/* 色ベクトル(+code) */
		u_long	*ot;		/* ＯＴエントリ */
		RVECTOR r0,r1,r2,r3;	/* 分割頂点ベクトル情報（RVECTOR参照)*/
					/* 各頂点の2D,3D,Texture座標や色 */
		divp->cr[0].r0 = &divp->r0;	
		divp->cr[0].r1 = &divp->r1;	
		divp->cr[0].r2 = &divp->r2;	
		divp->cr[0].r3 = &divp->r3;	
		

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	otはＯＴエントリ（libgpu参照）

**12.11.
RCpolyFT3	フラット３角形の分割

    形式	u_long *RCpolyFT3(s,divp)
		POLY_FT3 *s;		/* GPUパケットバッファのアドレス*/
		DIVPOLYGON3 *divp;	/* デバイド用ワークエリア*/  

    解説	フラット３角形の分割処理を行なう再帰プログラム。
		デバイド用ワークエリアに以下のデータの設定がなされているものと
		する。
		u_long 	ndiv： 		/* 分割数 */		
		u_long 	pih,piv： 	/* 表示画面の解像度(クリップ用) */

		u_short clut,tpage：	/* CBA & TSB */
		CVECTOR	rgbc：		/* 色ベクトル(+code) */
		u_long	*ot;		/* ＯＴエントリ */
		RVECTOR r0,r1,r2;	/* 分割頂点ベクトル情報（RVECTOR参照)*/
					/* 各頂点の2D,3D,Texture座標や色 */
		divp->cr[0].r0 = &divp->r0;	
		divp->cr[0].r1 = &divp->r1;	
		divp->cr[0].r2 = &divp->r2;	
		

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	otはＯＴエントリ（libgpu参照）
		

**12.12.
RCpolyFT4	フラット３角形の分割

    形式	u_long *RCpolyFT4(s,divp)
		POLY_FT4 *s;		/* GPUパケットバッファのアドレス*/
		DIVPOLYGON4 *divp;	/* デバイド用ワークエリア*/  

    解説	フラット４角形の分割処理を行なう再帰プログラム。
		デバイド用ワークエリアに以下のデータの設定がなされているものと
		する。
		u_long 	ndiv： 		/* 分割数 */		
		u_long 	pih,piv： 	/* 表示画面の解像度(クリップ用) */
		u_short clut,tpage：	/* CBA & TSB */
		CVECTOR	rgbc：		/* 色ベクトル(+code) */
		u_long	*ot;		/* ＯＴエントリ */
		RVECTOR r0,r1,r2,r3;	/* 分割頂点ベクトル情報（RVECTOR参照)*/
					/* 各頂点の2D,3D,Texture座標や色 */
		divp->cr[0].r0 = &divp->r0;	
		divp->cr[0].r1 = &divp->r1;	
		divp->cr[0].r2 = &divp->r2;	
		divp->cr[0].r3 = &divp->r3;	
		

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	otはＯＴエントリ（libgpu参照）

**12.13.
RCpolyG3	フラット３角形の分割

    形式	u_long *RCpolyG3(s,divp)
		POLY_G3 *s;		/* GPUパケットバッファのアドレス*/
		DIVPOLYGON3 *divp;	/* デバイド用ワークエリア*/  

    解説	フラット３角形の分割処理を行なう再帰プログラム。
		デバイド用ワークエリアに以下のデータの設定がなされているものと
		する。
		u_long 	ndiv： 		/* 分割数 */		
		u_long 	pih,piv： 	/* 表示画面の解像度(クリップ用) */

		u_short clut,tpage：	/* CBA & TSB */
		CVECTOR	rgbc：		/* 色ベクトル(+code) */
		u_long	*ot;		/* ＯＴエントリ */
		RVECTOR r0,r1,r2;	/* 分割頂点ベクトル情報（RVECTOR参照)*/
					/* 各頂点の2D,3D,Texture座標や色 */
		divp->cr[0].r0 = &divp->r0;	
		divp->cr[0].r1 = &divp->r1;	
		divp->cr[0].r2 = &divp->r2;	
		

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	otはＯＴエントリ（libgpu参照）
		

**12.14.
RCpolyG4	フラット３角形の分割

    形式	u_long *RCpolyG4(s,divp)
		POLY_G4 *s;		/* GPUパケットバッファのアドレス*/
		DIVPOLYGON4 *divp;	/* デバイド用ワークエリア*/  

    解説	フラット４角形の分割処理を行なう再帰プログラム。
		デバイド用ワークエリアに以下のデータの設定がなされているものと
		する。
		
		u_long 	ndiv：	 	/* 分割数 */		
		u_long 	pih,piv： 	/* 表示画面の解像度(クリップ用) */
		u_short clut,tpage：	/* CBA & TSB */
		CVECTOR	rgbc：		/* 色ベクトル(+code) */
		u_long	*ot;		/* ＯＴエントリ */
		RVECTOR r0,r1,r2,r3;	/* 分割頂点ベクトル情報（RVECTOR参照)*/
					/* 各頂点の2D,3D,Texture座標や色 */
		divp->cr[0].r0 = &divp->r0;	
		divp->cr[0].r1 = &divp->r1;	
		divp->cr[0].r2 = &divp->r2;	
		divp->cr[0].r3 = &divp->r3;	
		

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	otはＯＴエントリ（libgpu参照）

**12.15.
RCpolyGT3	フラット３角形の分割

    形式	u_long *RCpolyGT3(s,divp)
		POLY_GT3 *s;		/* GPUパケットバッファのアドレス*/
		DIVPOLYGON3 *divp;	/* デバイド用ワークエリア*/  

    解説	フラット３角形の分割処理を行なう再帰プログラム。
		デバイド用ワークエリアに以下のデータの設定がなされているものと
		する。
	
		u_long 	ndiv： 		/* 分割数 */		
		u_long 	pih,piv： 	/* 表示画面の解像度(クリップ用) */
		u_short clut,tpage：	/* CBA & TSB */
		CVECTOR	rgbc：		/* 色ベクトル(+code) */
		u_long	*ot;		/* ＯＴエントリ */
		RVECTOR r0,r1,r2;	/* 分割頂点ベクトル情報（RVECTOR参照)*/
					/* 各頂点の2D,3D,Texture座標や色 */
		divp->cr[0].r0 = &divp->r0;	
		divp->cr[0].r1 = &divp->r1;	
		divp->cr[0].r2 = &divp->r2;	
		

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	otはＯＴエントリ（libgpu参照）
		

**12.16.
RCpolyGT4	フラット３角形の分割

    形式	u_long *RCpolyGT4(s,divp)
		POLY_GT4 *s;		/* GPUパケットバッファのアドレス*/
		DIVPOLYGON4 *divp;	/* デバイド用ワークエリア*/  

    解説	フラット４角形の分割処理を行なう再帰プログラム。
		デバイド用ワークエリアに以下のデータの設定がなされているものと
		する。
		u_long 	ndiv：	 	/* 分割数 */		
		u_long 	pih,piv： 	/* 表示画面の解像度(クリップ用) */
		u_short clut,tpage：	/* CBA & TSB */
		CVECTOR	rgbc：		/* 色ベクトル(+code) */
		u_long	*ot;		/* ＯＴエントリ */
		RVECTOR r0,r1,r2,r3;	/* 分割頂点ベクトル情報（RVECTOR参照)*/
					/* 各頂点の2D,3D,Texture座標や色 */
		divp->cr[0].r0 = &divp->r0;	
		divp->cr[0].r1 = &divp->r1;	
		divp->cr[0].r2 = &divp->r2;	
		divp->cr[0].r3 = &divp->r3;	
		

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	otはＯＴエントリ（libgpu参照）
		

*１３．libgs用関数


**13.1.
GsTMDfastF3L	フラット３角形 (光源計算)
GsTMDfastF3LFG	フラット３角形 (光源計算＋FOG)
GsTMDfastF3NL	フラット３角形 (光源計算なし)
GsTMDfastNF3	フラット３角形 (光源計算なし)

    形式	u_long *GsTMDfastF3L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastF3LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastF3NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastNF3(primtop,vertop,s,n,shift,otp)
		
		TMD_P_F3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NF3 *primtop;)	/* GsTMDfastNF3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_F3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のフラット３角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		（GsSortObject4で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.2.
GsTMDfastF4L	フラット４角形 (光源計算)
GsTMDfastF4LFG	フラット４角形 (光源計算＋FOG)
GsTMDfastF4NL	フラット４角形 (光源計算なし)
GsTMDfastNF4	フラット４角形 (光源計算なし)

    形式	u_long *GsTMDfastF4L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastF4LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastF4NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastNF4(primtop,vertop,s,n,shift,otp)
		
		TMD_P_F4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NF4 *primtop;)	/* GsTMDfastNF4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_F4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のフラット４角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		（GsSortObject4で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.3.
GsTMDfastTF3L	フラットテクスチャ３角形 (光源計算)
GsTMDfastTF3LFG	フラットテクスチャ３角形 (光源計算＋FOG)
GsTMDfastTF3NL	フラットテクスチャ３角形 (光源計算なし)
GsTMDfastTNF3	フラットテクスチャ３角形 (光源計算なし)

    形式	u_long *GsTMDfastTF3L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTF3LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTF3NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTNF3(primtop,vertop,s,n,shift,otp)
		
		TMD_P_TF3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNF3 *primtop;)	/* GsTMDfastTNF3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_FT3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のフラットテクスチャ３角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		（GsSortObject4で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.4.
GsTMDfastTF4L	フラットテクスチャ４角形 (光源計算)
GsTMDfastTF4LFG	フラットテクスチャ４角形 (光源計算＋FOG)
GsTMDfastTF4NL	フラットテクスチャ４角形 (光源計算なし)
GsTMDfastTNF4	フラットテクスチャ４角形 (光源計算なし)

    形式	u_long *GsTMDfastTF4L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTF4LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTF4NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTNF4(primtop,vertop,s,n,shift,otp)
		
		TMD_P_TF4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNF4 *primtop;)	/* GsTMDfastTNF4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_FT4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のフラットテクスチャ４角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		（GsSortObject4で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.5.
GsTMDfastG3L	グーロー３角形 (光源計算)
GsTMDfastG3LFG	グーロー３角形 (光源計算＋FOG)
GsTMDfastG3NL	グーロー３角形 (光源計算なし)
GsTMDfastNG3	グーロー３角形 (光源計算なし)

    形式	u_long *GsTMDfastG3L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastG3LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastG3NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastNG3(primtop,vertop,s,n,shift,otp)
		
		TMD_P_G3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NG3 *primtop;)	/* GsTMDfastNG3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_G3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のグーロー３角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		（GsSortObject4で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.6.
GsTMDfastG4L	グーロー４角形 (光源計算)
GsTMDfastG4LFG	グーロー４角形 (光源計算＋FOG)
GsTMDfastG4NL	グーロー４角形 (光源計算なし)
GsTMDfastNG4	グーロー４角形 (光源計算なし)

    形式	u_long *GsTMDfastG4L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastG4LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastG4NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastNG4(primtop,vertop,s,n,shift,otp)
		
		TMD_P_G4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NG4 *primtop;)	/* GsTMDfastNG4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_G4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のグーロー４角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		（GsSortObject4で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.7.
GsTMDfastTG3L	グーローテクスチャ３角形 (光源計算)
GsTMDfastTG3LFG	グーローテクスチャ３角形 (光源計算＋FOG)
GsTMDfastTG3NL	グーローテクスチャ３角形 (光源計算なし)
GsTMDfastTNG3	グーローテクスチャ３角形 (光源計算なし)

    形式	u_long *GsTMDfastTG3L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTG3LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTG3NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTNG3(primtop,vertop,s,n,shift,otp)
		
		TMD_P_TG3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNG3 *primtop;)	/* GsTMDfastTNG3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_GT3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のグーローテクスチャ３角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		（GsSortObject4で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.8.
GsTMDfastTG4L	グーローテクスチャ４角形 (光源計算)
GsTMDfastTG4LFG	グーローテクスチャ４角形 (光源計算＋FOG)
GsTMDfastTG4NL	グーローテクスチャ４角形 (光源計算なし)
GsTMDfastTNG4	グーローテクスチャ４角形 (光源計算なし)

    形式	u_long *GsTMDfastTG4L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTG4LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTG4NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsTMDfastTNG4(primtop,vertop,s,n,shift,otp)
		
		TMD_P_TG4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNG4 *primtop;)	/* GsTMDfastTNG4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_GT4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のグーローテクスチャ４角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		（GsSortObject4で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照

**13.9.
GsPrstF3L	フラット３角形 (光源計算)
GsPrstF3LFG	フラット３角形 (光源計算＋FOG)
GsPrstF3NL	フラット３角形 (光源計算なし)
GsPrstNF3	フラット３角形 (光源計算なし)

    形式	u_long *GsPrstF3L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstF3LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstF3NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstNF3(primtop,vertop,s,n,shift,otp)
		
		TMD_P_F3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NF3 *primtop;)	/* GsPrstNF3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_F3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のフラット３角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		バッファ上には１ポリゴンにつき２つのパケットがプリセット
		されているものとする。（libgs: GsPresetObject参照）
		（GsSortObject5で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.10.
GsPrstF4L	フラット４角形 (光源計算)
GsPrstF4LFG	フラット４角形 (光源計算＋FOG)
GsPrstF4NL	フラット４角形 (光源計算なし)
GsPrstNF4	フラット４角形 (光源計算なし)

    形式	u_long *GsPrstF4L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstF4LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstF4NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstNF4(primtop,vertop,s,n,shift,otp)
		
		TMD_P_F4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NF4 *primtop;)	/* GsPrstNF4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_F4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のフラット４角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		バッファ上には１ポリゴンにつき２つのパケットがプリセット
		されているものとする。（libgs: GsPresetObject参照）
		（GsSortObject5で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.11.
GsPrstTF3L	フラットテクスチャ３角形 (光源計算)
GsPrstTF3LFG	フラットテクスチャ３角形 (光源計算＋FOG)
GsPrstTF3NL	フラットテクスチャ３角形 (光源計算なし)
GsPrstTNF3	フラットテクスチャ３角形 (光源計算なし)

    形式	u_long *GsPrstTF3L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTF3LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTF3NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTNF3(primtop,vertop,s,n,shift,otp)
		
		TMD_P_TF3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNF3 *primtop;)	/* GsPrstTNF3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_FT3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のフラットテクスチャ３角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		バッファ上には１ポリゴンにつき２つのパケットがプリセット
		されているものとする。（libgs: GsPresetObject参照）
		（GsSortObject5で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.12.
GsPrstTF4L	フラットテクスチャ４角形 (光源計算)
GsPrstTF4LFG	フラットテクスチャ４角形 (光源計算＋FOG)
GsPrstTF4NL	フラットテクスチャ４角形 (光源計算なし)
GsPrstTNF4	フラットテクスチャ４角形 (光源計算なし)

    形式	u_long *GsPrstTF4L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTF4LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTF4NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTNF4(primtop,vertop,s,n,shift,otp)
		
		TMD_P_TF4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNF4 *primtop;)	/* GsPrstTNF4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_FT4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のフラットテクスチャ４角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		バッファ上には１ポリゴンにつき２つのパケットがプリセット
		されているものとする。（libgs: GsPresetObject参照）
		（GsSortObject5で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.13.
GsPrstG3L	グーロー３角形 (光源計算)
GsPrstG3LFG	グーロー３角形 (光源計算＋FOG)
GsPrstG3NL	グーロー３角形 (光源計算なし)
GsPrstNG3	グーロー３角形 (光源計算なし)

    形式	u_long *GsPrstG3L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstG3LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstG3NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstNG3(primtop,vertop,s,n,shift,otp)
		
		TMD_P_G3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NG3 *primtop;)	/* GsPrstNG3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_G3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のグーロー３角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		バッファ上には１ポリゴンにつき２つのパケットがプリセット
		されているものとする。（libgs: GsPresetObject参照）
		（GsSortObject5で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.14.
GsPrstG4L	グーロー４角形 (光源計算)
GsPrstG4LFG	グーロー４角形 (光源計算＋FOG)
GsPrstG4NL	グーロー４角形 (光源計算なし)
GsPrstNG4	グーロー４角形 (光源計算なし)

    形式	u_long *GsPrstG4L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstG4LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstG4NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstNG4(primtop,vertop,s,n,shift,otp)
		
		TMD_P_G4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NG4 *primtop;)	/* GsPrstNG4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_G4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のグーロー４角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		バッファ上には１ポリゴンにつき２つのパケットがプリセット
		されているものとする。（libgs: GsPresetObject参照）
		（GsSortObject5で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.15.
GsPrstTG3L	グーローテクスチャ３角形 (光源計算)
GsPrstTG3LFG	グーローテクスチャ３角形 (光源計算＋FOG)
GsPrstTG3NL	グーローテクスチャ３角形 (光源計算なし)
GsPrstTNG3	グーローテクスチャ３角形 (光源計算なし)

    形式	u_long *GsPrstTG3L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTG3LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTG3NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTNG3(primtop,vertop,s,n,shift,otp)
		
		TMD_P_TG3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNG3 *primtop;)	/* GsPrstTNG3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_GT3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のグーローテクスチャ３角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		バッファ上には１ポリゴンにつき２つのパケットがプリセット
		されているものとする。（libgs: GsPresetObject参照）
		（GsSortObject5で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.16.
GsPrstTG4L	グーローテクスチャ４角形 (光源計算)
GsPrstTG4LFG	グーローテクスチャ４角形 (光源計算＋FOG)
GsPrstTG4NL	グーローテクスチャ４角形 (光源計算なし)
GsPrstTNG4	グーローテクスチャ４角形 (光源計算なし)

    形式	u_long *GsPrstTG4L(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTG4LFG(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTG4NL(primtop,vertop,nortop,s,n,shift,otp)
		u_long *GsPrstTNG4(primtop,vertop,s,n,shift,otp)
		
		TMD_P_TG4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNG4 *primtop;)	/* GsPrstTNG4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_GT4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/

    解説	TMDファイル上の連続する n 個のグーローテクスチャ４角形について
		座標変換、透視変換、backface clip、(光源計算)を行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		バッファ上には１ポリゴンにつき２つのパケットがプリセット
		されているものとする。（libgs: GsPresetObject参照）
		（GsSortObject5で使用）

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	libgs 参照
		

**13.17.
GsTMDdivF3L	フラット３角形 (光源計算)
GsTMDdivF3LFG	フラット３角形 (光源計算＋FOG)
GsTMDdivF3NL	フラット３角形 (光源計算なし)
GsTMDdivNF3	フラット３角形 (光源計算なし)

    形式	u_long *GsTMDdivF3L(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivF3LFG(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivF3NL(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivNF3(primtop,vertop,s,n,shift,otp,divp)
		
		TMD_P_F3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NF3 *primtop;)	/* GsTMDdivNF3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_F3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/
		DIVPOLYGON3 *divp;	/* デバイド用ワークエリア*/  

    解説	TMDファイル上の連続する n 個のフラット３角形について
		divp->ndivの値のもとに分割し,分割ポリゴンに対し、
		座標変換、透視変換、backface clip、表示画面clip、(光源計算)を
		行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		libgs 参照
		

**13.18.
GsTMDdivF4L	フラット４角形 (光源計算)
GsTMDdivF4LFG	フラット４角形 (光源計算＋FOG)
GsTMDdivF4NL	フラット４角形 (光源計算なし)
GsTMDdivNF4	フラット４角形 (光源計算なし)

    形式	u_long *GsTMDdivF4L(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivF4LFG(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivF4NL(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivNF4(primtop,vertop,s,n,shift,otp,divp)
		
		TMD_P_F4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NF4 *primtop;)	/* GsTMDdivNF4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_F4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/
		DIVPOLYGON4 *divp;	/* デバイド用ワークエリア*/  

    解説	TMDファイル上の連続する n 個のフラット４角形について
		divp->ndivの値のもとに分割し,分割ポリゴンに対し、
		座標変換、透視変換、backface clip、表示画面clip、(光源計算)を
		行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		libgs 参照
		

**13.19.
GsTMDdivTF3L	フラットテクスチャ３角形 (光源計算)
GsTMDdivTF3LFG	フラットテクスチャ３角形 (光源計算＋FOG)
GsTMDdivTF3NL	フラットテクスチャ３角形 (光源計算なし)
GsTMDdivTNF3	フラットテクスチャ３角形 (光源計算なし)

    形式	u_long *GsTMDdivTF3L(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivTF3LFG(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivTF3NL(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivTNF3(primtop,vertop,s,n,shift,otp,divp)
		
		TMD_P_TF3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNF3 *primtop;)	/* GsTMDdivTNF3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_FT3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/
		DIVPOLYGON3 *divp;	/* デバイド用ワークエリア*/  

    解説	TMDファイル上の連続する n 個のフラットテクスチャ３角形について
		divp->ndivの値のもとに分割し,分割ポリゴンに対し、
		座標変換、透視変換、backface clip、表示画面clip、(光源計算)を
		行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		libgs 参照
		

**13.20.
GsTMDdivTF4L	フラットテクスチャ４角形 (光源計算)
GsTMDdivTF4LFG	フラットテクスチャ４角形 (光源計算＋FOG)
GsTMDdivTF4NL	フラットテクスチャ４角形 (光源計算なし)
GsTMDdivTNF4	フラットテクスチャ４角形 (光源計算なし)

    形式	u_long *GsTMDdivTF4L(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivTF4LFG(primtop,vertop,nortop,s,n,shift,otp,di
		vp)
		u_long *GsTMDdivTF4NL(primtop,vertop,nortop,s,n,shift,otp,div
		p)
		u_long *GsTMDdivTNF4(primtop,vertop,s,n,shift,otp,divp)
		
		TMD_P_TF4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNF4 *primtop;)	/* GsTMDdivTNF4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_FT4 *s;	/* GPUパケットバッファのアドレス*/
		u_long  n;	/* 処理ポリゴン数*/
		u_long  shift;	/* OTへの割り付け時にZの値を何ビット*/
		/* 右にシフトさせるかを設定します。 */
		GsOT *otp;	/* OTへのポインタ*/
		DIVPOLYGON4 *divp;	/* デバイド用ワークエリア*/  

    解説	TMDファイル上の連続する n 個のフラットテクスチャ４角形について
		divp->ndivの値のもとに分割し,分割ポリゴンに対し、
		座標変換、透視変換、backface clip、表示画面clip、(光源計算)を
		行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、	ndiv=3: 8x8分割、
		ndiv=4: 16x16分割、	ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		libgs 参照
		

**13.21.
GsTMDdivG3L	グーロー３角形 (光源計算)
GsTMDdivG3LFG	グーロー３角形 (光源計算＋FOG)
GsTMDdivG3NL	グーロー３角形 (光源計算なし)
GsTMDdivNG3	グーロー３角形 (光源計算なし)

    形式	u_long *GsTMDdivG3L(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivG3LFG(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivG3NL(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivNG3(primtop,vertop,s,n,shift,otp,divp)
		
		TMD_P_G3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NG3 *primtop;)	/* GsTMDdivNG3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_G3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/
		DIVPOLYGON3 *divp;	/* デバイド用ワークエリア*/  

    解説	TMDファイル上の連続する n 個のグーロー３角形について
		divp->ndivの値のもとに分割し,分割ポリゴンに対し、
		座標変換、透視変換、backface clip、表示画面clip、(光源計算)を
		行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
	
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		libgs 参照
		

**13.22.
GsTMDdivG4L	グーロー４角形 (光源計算)
GsTMDdivG4LFG	グーロー４角形 (光源計算＋FOG)
GsTMDdivG4NL	グーロー４角形 (光源計算なし)
GsTMDdivNG4	グーロー４角形 (光源計算なし)

    形式	u_long *GsTMDdivG4L(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivG4LFG(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivG4NL(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivNG4(primtop,vertop,s,n,shift,otp,divp)
		
		TMD_P_G4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_NG4 *primtop;)	/* GsTMDdivNG4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_G4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/
		DIVPOLYGON4 *divp;	/* デバイド用ワークエリア*/  

    解説	TMDファイル上の連続する n 個のグーロー４角形について
		divp->ndivの値のもとに分割し,分割ポリゴンに対し、
		座標変換、透視変換、backface clip、表示画面clip、(光源計算)を
		行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		libgs 参照
		

**13.23.
GsTMDdivTG3L	グーローテクスチャ３角形 (光源計算)
GsTMDdivTG3LFG	グーローテクスチャ３角形 (光源計算＋FOG)
GsTMDdivTG3NL	グーローテクスチャ３角形 (光源計算なし)
GsTMDdivTNG3	グーローテクスチャ３角形 (光源計算なし)

    形式	u_long *GsTMDdivTG3L(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivTG3LFG(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivTG3NL(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivTNG3(primtop,vertop,s,n,shift,otp,divp)
		
		TMD_P_TG3  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNG3 *primtop;)	/* GsTMDdivTNG3は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_GT3 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/
		DIVPOLYGON3 *divp;	/* デバイド用ワークエリア*/  

    解説	TMDファイル上の連続する n 個のグーローテクスチャ３角形について
		divp->ndivの値のもとに分割し,分割ポリゴンに対し、
		座標変換、透視変換、backface clip、表示画面clip、(光源計算)を
		行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		libgs 参照
		

**13.24.
GsTMDdivTG4L	グーローテクスチャ４角形 (光源計算)
GsTMDdivTG4LFG	グーローテクスチャ４角形 (光源計算＋FOG)
GsTMDdivTG4NL	グーローテクスチャ４角形 (光源計算なし)
GsTMDdivTNG4	グーローテクスチャ４角形 (光源計算なし)

    形式	u_long *GsTMDdivTG4L(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivTG4LFG(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivTG4NL(primtop,vertop,nortop,s,n,shift,otp,divp)
		u_long *GsTMDdivTNG4(primtop,vertop,s,n,shift,otp,divp)
		
		TMD_P_TG4  *primtop;	/* TMD PRIMITIVE のスタートアドレス*/
		(TMD_P_TNG4 *primtop;)	/* GsTMDdivTNG4は法線なしパケット*/
		SVECTOR *vertop;	/* TMD VERTEX の先頭アドレス*/
		SVECTOR *nortop;	/* TMD NORMAL の先頭アドレス*/
		POLY_GT4 *s;		/* GPUパケットバッファのアドレス*/
		u_long  n;		/* 処理ポリゴン数*/
		u_long  shift;		/* OTへの割り付け時にZの値を何ビット*/
					/* 右にシフトさせるかを設定します。 */
		GsOT *otp;		/* OTへのポインタ*/
		DIVPOLYGON4 *divp;	/* デバイド用ワークエリア*/  

    解説	TMDファイル上の連続する n 個のグーローテクスチャ４角形について
		divp->ndivの値のもとに分割し,分割ポリゴンに対し、
		座標変換、透視変換、backface clip、表示画面clip、(光源計算)を
		行ない、
		ＧＰＵパケットをバッファ上に完成し、ＯＴにリンクする。
		ndiv=1: 2x2分割、	ndiv=2: 4x4分割、
		ndiv=3: 8x8分割、	ndiv=4: 16x16分割、
		ndiv=5: 32x32分割

    返り値	更新されたGPUパケットバッファのアドレス
	
    注意	divp->ndiv:分割数、 
		divp->pih,piv:表示画面の解像度(クリップ用)、
		は設定されているものとする。
		libgs 参照
		
		

*１４．ＳＭＤ関数

**14.1.
RotSMD_F3	独立頂点型フラット三角形用ＳＭＤ関数
RotSMD_G3	独立頂点型グーロー三角形用ＳＭＤ関数
RotSMD_FT3	独立頂点型フラットテクスチャ三角形用ＳＭＤ関数
RotSMD_GT3	独立頂点型グーローテクスチャ三角形用ＳＭＤ関数
RotSMD_F4	独立頂点型フラット四角形用ＳＭＤ関数
RotSMD_G4	独立頂点型グーロー四角形用ＳＭＤ関数
RotSMD_FT4	独立頂点型フラットテクスチャ四角形用ＳＭＤ関数
RotSMD_GT4	独立頂点型グーローテクスチャ四角形用ＳＭＤ関数

    形式	void RotSMD_F3(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_G3(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_FT3(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_GT3(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_F4(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_G4(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_FT4(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_GT4(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		long *pa;	/*PRIMITIVE Gpの先頭アドレス*/
		u_long *ot;	/*OTの先頭アドレス*/
		int otlen;	/*OTの長さ（ビット数）*/
		int id;		/*ダブルバッファのID*/
		int sclip;	/*スクリーンクリップON/OFF(ON=1)*/
		int hclip;	/*Ｈ方向クリップ領域（[0,hclip]=表示）*/
		int vclip;	/*Ｖ方向クリップ領域（[0,vclip]=表示）*/
		int nclipmode;	/*near Z clip モード(0=0,SCRZ/2=1) */

    解説	独立頂点型タイプのPRIMITIVE Gpにふくまれる
		三角形または四角形のすべてについて
		座標変換、透視変換を行ない、ＧＰＵパケットを完成し
		ＯＴにリンクする。
		sclip=0のときはスクリーン上の位置に関係なくリンクされる。
		sclip=1のときは３つまたは４つの頂点のうち少なくともひとつが
		[0,hclip],[0,vclip]の矩形のなかに含まれているときのみリンクさ
		れる。
		nclipmode=0のときは
		SZ値が[0,2^16)の間に含まれるポリゴンのみリンクされる。
		nclipmode=1のときは
		SZ値が[h/2,2^16)の間に含まれるポリゴンのみリンクされる。
		必ずbackface clipされる。

    返り値	なし
		
		

**14.9.
RotSMD_SV_F3	共有頂点型フラット三角形用ＳＭＤ関数
RotSMD_SV_G3	共有頂点型グーロー三角形用ＳＭＤ関数
RotSMD_SV_FT3	共有頂点型フラットテクスチャ三角形用ＳＭＤ関数
RotSMD_SV_GT3	共有頂点型グーローテクスチャ三角形用ＳＭＤ関数
RotSMD_SV_F4	共有頂点型フラット四角形用ＳＭＤ関数
RotSMD_SV_G4	共有頂点型グーロー四角形用ＳＭＤ関数
RotSMD_SV_FT4	共有頂点型フラットテクスチャ四角形用ＳＭＤ関数
RotSMD_SV_GT4	共有頂点型グーローテクスチャ四角形用ＳＭＤ関数

    形式	void RotSMD_SV_F3(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_SV_G3(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_SV_FT3(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_SV_GT3(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_SV_F4(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_SV_G4(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_SV_FT4(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotSMD_SV_GT4(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		long *pa;	/*PRIMITIVE Gpの先頭アドレス*/
		long *va;	/*VERTEX Gpの先頭アドレス*/
		u_long *ot;	/*OTの先頭アドレス*/
		int otlen;	/*OTの長さ（ビット数）*/
		int id;		/*ダブルバッファのID*/
		int sclip;	/*スクリーンクリップON/OFF(ON=1)*/
		int hclip;	/*Ｈ方向クリップ領域（[0,hclip]=表示）*/
		int vclip;	/*Ｖ方向クリップ領域（[0,vclip]=表示）*/
		int nclipmode;	/*near Z clip モード(0=0,SCRZ/2=1) */

    解説	共有頂点型タイプのPRIMITIVE Gpにふくまれる
		三角形または四角形のすべてについて
		座標変換、透視変換を行ない、ＧＰＵパケットを完成し
		ＯＴにリンクする。
		sclip=0のときはスクリーン上の位置に関係なくリンクされる。
		sclip=1のときは３つまたは４つの頂点のうち少なくともひとつが
		[0,hclip],[0,vclip]の矩形のなかに含まれているときのみリンクさ
		れる。
		nclipmode=0のときは
		SZ値が[0,2^16)の間に含まれるポリゴンのみリンクされる。
		nclipmode=1のときは
		SZ値が[h/2,2^16)の間に含まれるポリゴンのみリンクされる。
		必ずbackface clipされる。

    返り値	なし
		
		
		

*１５．ＲＭＤ関数

**15.1.
RotRMD_F3	独立頂点型フラット三角形用ＲＭＤ関数
RotRMD_G3	独立頂点型グーロー三角形用ＲＭＤ関数
RotRMD_FT3	独立頂点型フラットテクスチャ三角形用ＲＭＤ関数
RotRMD_GT3	独立頂点型グーローテクスチャ三角形用ＲＭＤ関数
RotRMD_F4	独立頂点型フラット四角形用ＲＭＤ関数
RotRMD_G4	独立頂点型グーロー四角形用ＲＭＤ関数
RotRMD_FT4	独立頂点型フラットテクスチャ四角形用ＲＭＤ関数
RotRMD_GT4	独立頂点型グーローテクスチャ四角形用ＲＭＤ関数

    形式	void RotRMD_F3(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_G3(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_FT3(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_GT3(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_F4(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_G4(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_FT4(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_GT4(pa,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		long *pa;	/*PRIMITIVE Gpの先頭アドレス*/
		u_long *ot;	/*OTの先頭アドレス*/
		int otlen;	/*OTの長さ（ビット数）*/
		int id;		/*ダブルバッファのID*/
		int sclip;	/*スクリーンクリップON/OFF(ON=1)*/
		int hclip;	/*Ｈ方向クリップ領域（[0,hclip]=表示）*/
		int vclip;	/*Ｖ方向クリップ領域（[0,vclip]=表示）*/
		int nclipmode;	/*near Z clip モード(0=0,SCRZ/2=1) */

    解説	独立頂点型タイプのPRIMITIVE Gpにふくまれる
		三角形または四角形のすべてについて
		座標変換、透視変換を行ない、ＧＰＵパケットを完成し
		ＯＴにリンクする。
		sclip=0のときはスクリーン上の位置に関係なくリンクされる。
		sclip=1のときは３つまたは４つの頂点のうち少なくともひとつが
		[0,hclip],[0,vclip]の矩形のなかに含まれているときのみリンクさ
		れる。
		nclipmode=0のときは
		SZ値が[0,2^16)の間に含まれるポリゴンのみリンクされる。
		nclipmode=1のときは
		SZ値が[h/2,2^16)の間に含まれるポリゴンのみリンクされる。
		必ずbackface clipされない。

    返り値	なし
		
		
		

**15.9.
RotRMD_SV_F3	共有頂点型フラット三角形用ＲＭＤ関数
RotRMD_SV_G3	共有頂点型グーロー三角形用ＲＭＤ関数
RotRMD_SV_FT3	共有頂点型フラットテクスチャ三角形用ＲＭＤ関数
RotRMD_SV_GT3	共有頂点型グーローテクスチャ三角形用ＲＭＤ関数
RotRMD_SV_F4	共有頂点型フラット四角形用ＲＭＤ関数
RotRMD_SV_G4	共有頂点型グーロー四角形用ＲＭＤ関数
RotRMD_SV_FT4	共有頂点型フラットテクスチャ四角形用ＲＭＤ関数
RotRMD_SV_GT4	共有頂点型グーローテクスチャ四角形用ＲＭＤ関数

    形式	void RotRMD_SV_F3(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_SV_G3(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_SV_FT3(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_SV_GT3(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_SV_F4(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_SV_G4(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_SV_FT4(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		void RotRMD_SV_GT4(pa,va,ot,otlen,id,sclip,hclip,vclip,nclipmode)
		long *pa;	/*PRIMITIVE Gpの先頭アドレス*/
		long *va;	/*VERTEX Gpの先頭アドレス*/
		u_long *ot;	/*OTの先頭アドレス*/
		int otlen;	/*OTの長さ（ビット数）*/
		int id;		/*ダブルバッファのID*/
		int sclip;	/*スクリーンクリップON/OFF(ON=1)*/
		int hclip;	/*Ｈ方向クリップ領域（[0,hclip]=表示）*/
		int vclip;	/*Ｖ方向クリップ領域（[0,vclip]=表示）*/
		int nclipmode;	/*near Z clip モード(0=0,SCRZ/2=1) */

    解説	共有頂点型タイプのPRIMITIVE Gpにふくまれる
		三角形または四角形のすべてについて
		座標変換、透視変換を行ない、ＧＰＵパケットを完成し
		ＯＴにリンクする。
		sclip=0のときはスクリーン上の位置に関係なくリンクされる。
		sclip=1のときは３つまたは４つの頂点のうち少なくともひとつが
		[0,hclip],[0,vclip]の矩形のなかに含まれているときのみリンクさ
		れる。
		nclipmode=0のときは
		SZ値が[0,2^16)の間に含まれるポリゴンのみリンクされる。
		nclipmode=1のときは
		SZ値が[h/2,2^16)の間に含まれるポリゴンのみリンクされる。
		必ずbackface clipされない。

    返り値	なし
		
		
		
		
		

*１６．その他の関数

**16.1.
pers_map	透視変換テクスチャマッピング

    形式	void pers_map(abuf,vertex,tex,dtext)
		int     abuf;		/*active buffer*/
		SVECTOR **vertex;	/*４頂点*/
		int     tex[4][2];      /*texture address*/
		u_short *dtext;         /*direct texture save area*/
		

    解説	歪みのないテクスチャマッピングを行なう。
		abuf: 表示している方のバッファＩＤ
		vertex: ４頂点の３次元座標
		tex: ４頂点のテクスチャアドレス
		dtext: ダイレクトカラーに変換されたテクスチャの格納場所
		
		注意
		フラットテクスチャ、光源計算なしのみ
		４頂点は正方形、長方形、平行四辺形の位置のみ
		ＯＴによるＺソートはできない

    返り値	なし
		

**16.2.
PhongLine	フォンシェーディング

    形式	PhongLine(istart_x,iend_x,p,q,&pixx,fs,ft,i4,det)
		int     istart_x,iend_x;/*start X and end X coordinates*/
		int     p,q;		/*differential of fs and ft by X*/
		u_short *pixx;		/*pixel pointer*/
		int     fs,ft;		/*interpolation coeff. at start*/
		int     i4;		/*(line number)%4 for Dithering*/
		int     det;		/*determinant of 2 edge matrix*/

    解説	１ラインのフォンシェーディングを行なう
		注意
		サンプルプログラム参照

    返り値	なし
		

**16.3.
p2otz		デプスキューイング用の内挿値 p から otz を求める

    形式	long p2otz(long p, long projection)
		

    解説	デプスキューイング用の内挿値 p からおおよそのスクリーン座標の
		Ｚ成分 sz の 1/4 の値 otz を求める
		
		
		引数
		0 ≦ p ≦ 4096
		
		注意
		フォグの設定によって誤差が大きくなることがあり、必ずしも 
		RotTransPers 系の関数と同じ結果にはならない。
		p=0 もしくは p=4096 となる otz は原理的には一意に決まらないが
		、
		この関数では便宜的な値を返す。
		

    返り値	OTZ値
		
		

**16.4.
otz2p		otz 値から デプスキューイング用の内挿値 p を求める

    形式	long otz2p(long otz, long projection)
		

    解説	スクリーン座標のＺ成分 sz の 1/4 の値 otz からおおよそのデプス
		キューイング用の内挿値 p を求める
		
		引数
		OTZ 値
		
		注意
		フォグの設定によって誤差が大きくなることがあり、必ずしも 
		RotTransPers 系の関数と同じ結果にはならない。
		

    返り値	デプスキューイング用の内挿値 p (0 : 0%, 4096 : 100%)
		
		

*１７．メッシュ関数

**17.1.
RotMeshPrimS_F3		F3 ストリップメッシュ
RotMeshPrimS_G3		G3 ストリップメッシュ
RotMeshPrimS_FC3	FC3 ストリップメッシュ
RotMeshPrimS_GC3	GC3 ストリップメッシュ
RotMeshPrimS_FT3	FT3 ストリップメッシュ
RotMeshPrimS_GT3	GT3 ストリップメッシュ
RotMeshPrimS_FCT3	FCT3 ストリップメッシュ
RotMeshPrimS_GCT3	GCT3 ストリップメッシュ
RotMeshPrimS_T3		T3 ストリップメッシュ

    形式	RotMeshPrimS_F3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimS_G3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimS_FC3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimS_GC3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimS_FT3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimS_GT3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimS_FCT3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimS_GCT3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimS_T3(msh,prim,ot,otlen,dpq,backc)
		
		TMESH *msh;	/*メッシュ型データへのポインタ*/
		POLY_?3 *prim;	/*prim は生成すべきGPUパケットへのポインタ*/
		u_long *ot;	/*ot はオーダリングテーブルのポインタ*/
		u_long otlen;	/*otlen はオーダリングテーブルの長さ*/
		long dpq;	/*dpq はデプスキューイングをするかしないか*/
		long backc;	/*backc はバッククリップをするかしないか*/
		

    解説	下記のようなストリップ型メッシュ(smesh)データの
		座標変換、透視変換、ＯＴへのリンクを行なう
		
		1-----3-----5
		/ \   / \   /
		/   \ /   \ /
		0-----2-----4
		
		処理できる描画モードは次の９種類である。
		
		フラット	 		...F
		グーロー	     		...G
		フラットカラー			...FC
		グーローカラー			...GC
		フラットテクスチャ              ...FT
		グーローテクスチャ              ...GT
		フラットカラーテクスチャ        ...FCT
		グーローカラーテクスチャ        ...GCT
		テクスチャ	   		...T
		
		フラット：頂点色の一つでフラットシェーディングを行なう（光源計
		算する）
		グーロー：頂点色でグーローシェーディングを行なう（光源計算する
		）
		フラットカラー：頂点色の一つで塗りつぶす（光源計算しない）
		グーローカラー：頂点色でグーロー塗りつぶしを行なう（光源計算し
		ない）
		フラットテクスチャ：頂点色の一つでフラットシェーディングしたも
		のと
		テクスチャを掛け合わせる（光源計算する）
		グーローテクスチャ：頂点色でグーローシェーディングしたものと
		テクスチャを掛け合わせる（光源計算する）
		フラットカラーテクスチャ：頂点色の一つと
		テクスチャを掛け合わせる（光源計算しない）
		グーローカラーテクスチャ：頂点色でグーロー塗りつぶししたものと
		
		テクスチャを掛け合わせる（光源計算しない）　
		テクスチャ：テクスチャをそのまま書き込む（光源計算しない）
		
		注意
		FCT,GCTはデプスキューイングも行なわない
		

    返り値	なし
		

**17.2.
RotMeshPrimR_F3		F3 ラウンドメッシュ	
RotMeshPrimR_G3		G3 ラウンドメッシュ	
RotMeshPrimR_FC3	FC3 ラウンドメッシュ	
RotMeshPrimR_GC3	GC3 ラウンドメッシュ	
RotMeshPrimR_FT3	FT3 ラウンドメッシュ	
RotMeshPrimR_GT3	GT3 ラウンドメッシュ	
RotMeshPrimR_FCT3	FCT3 ラウンドメッシュ	
RotMeshPrimR_GCT3	GCT3 ラウンドメッシュ	
RotMeshPrimR_T3		T3 ラウンドメッシュ	

    形式	RotMeshPrimR_F3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimR_G3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimR_FC3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimR_GC3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimR_FT3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimR_GT3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimR_FCT3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimR_GCT3(msh,prim,ot,otlen,dpq,backc)
		RotMeshPrimR_T3(msh,prim,ot,otlen,dpq,backc)
		
		TMERH *msh;	/*メッシュ型データへのポインタ*/
		POLY_?3 *prim;	/*prim は生成すべきGPUパケットへのポインタ*/
		u_long *ot;	/*ot はオーダリングテーブルのポインタ*/
		u_long otlen;	/*otlen はオーダリングテーブルの長さ*/
		long dpq;	/*dpq はデプスキューイングをするかしないか*/
		long backc;	/*backc はバッククリップをするかしないか*/
		

    解説	下記のようなラウンド型メッシュ(rmesh)データの
		座標変換、透視変換、ＯＴへのリンクを行なう
		
		2-----3
		/ \   / \
		/   \ /   \
		1-----0-----4
		
		処理できる描画モードは次の９種類である。
		
		フラット	    		...F
		グーロー	      		...G
		フラットカラー			...FC
		グーローカラー			...GC
		フラットテクスチャ              ...FT
		グーローテクスチャ              ...GT
		フラットカラーテクスチャ        ...FCT
		グーローカラーテクスチャ        ...GCT
		テクスチャ			...T
		
		フラット：頂点色の一つでフラットシェーディングを行なう（光源計
		算する）
		グーロー：頂点色でグーローシェーディングを行なう（光源計算する
		）
		フラットカラー：頂点色の一つで塗りつぶす（光源計算しない）
		グーローカラー：頂点色でグーロー塗りつぶしを行なう（光源計算し
		ない）
		フラットテクスチャ：頂点色の一つでフラットシェーディングしたも
		のと
		テクスチャを掛け合わせる（光源計算する）
		グーローテクスチャ：頂点色でグーローシェーディングしたものと
		テクスチャを掛け合わせる（光源計算する）
		フラットカラーテクスチャ：頂点色の一つと
		テクスチャを掛け合わせる（光源計算しない）
		グーローカラーテクスチャ：頂点色でグーロー塗りつぶししたものと
		
		テクスチャを掛け合わせる（光源計算しない）　
		テクスチャ：テクスチャをそのまま書き込む（光源計算しない）
		
		注意
		FCT,GCTはデプスキューイングも行なわない
		

    返り値	なし
		

**17.3.
RotMeshPrimQ_T	２次元メッシュ

    形式	RotMeshPrimQ_T(msh,prim,ot,otlen,dpq,backc)
		
		TMERH *msh;	/*メッシュ型データへのポインタ*/
		POLY_FT4 *prim;	/*prim は生成すべきGPUパケットへのポインタ*/
		u_long *ot;	/*ot はオーダリングテーブルのポインタ*/
		u_long otlen;	/*otlen はオーダリングテーブルの長さ*/
		long dpq;	/*dpq はデプスキューイングをするかしないか*/
		long backc;	/*backc はバッククリップをするかしないか*/
		SCLIP *SCLIP;	/*スクリーンクリップ領域*/
		LINE_BUF *line_sxy; /*内部処理のための１ライン分のバッファ*/

    解説	下記のような２次元メッシュ(qmesh)データの
		座標変換、透視変換、法線クリップ
		スクリーン座標によるクリッピング(X,Y,Z)、ＯＴへのリンクを行な
		う。
		Ｈ方向の頂点の数は３の倍数でなければならない。(msh->lenh=3*n)
		
		1-----2-----3
		|     |     |
		|     |     |
		4-----5-----6
		|     |     |
		|     |     |
		7-----8-----9
		
		
		処理できる描画モードは次の１種類である。
		
		テクスチャ	    ...T
		
		テクスチャ：テクスチャをそのまま書き込む（フォグはかかるが
		光源計算しない）
		テクスチャ座標は設定されているものとする。
		
		<注意>
		以下の構造体を使う。ラインバッファは(１Ｈ＋３頂点)以上確保する
		。
		ラインバッファとしてスクラッチパッドを使うと高速である。
		
		typedef struct {
			long    sminX;
			long    smaxX;
			long    sminY;
			long    smaxY;
			long    sminZ;
			long    smaxZ;
		} SCLIP;
		
		typedef struct {
			long    sxy;
			long    code;
		} LINE_BUF;
		

    返り値	なし
