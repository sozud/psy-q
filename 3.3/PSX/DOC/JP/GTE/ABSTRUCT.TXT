$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
*libgteとは
	
============================================================================
PSXでポリゴンの描画を行なうには

	ジオメトリ演算 --> 描画

というポリゴン単位のパイプライン処理ではなく、

	ジオメトリ演算 --> ソーティング --> 描画

というように１画面分のポリゴン（複数）を単位として処理しなければなりません。

そのため、１個のポリゴンのジオメトリ演算から描画までを全部行なう
関数はなく、別々の関数を組み合わせて
ジオメトリ演算から描画までを行なう必要があります。

ＧＴＥはジオメトリ演算を高速に行なうためのコプロセッサであり、
ＧＴＥの機能を呼びだす関数及びその他のジオメトリ演算に有用な関数群
を集めたものが libgte です。

----------------------------------------------------------------------------
*libgteで想定しているジオメトリ演算
	
============================================================================
ＰＳＸでは libgte を使うことにより座標変換演算等を
高速に実行することができます。

ＧＴＥのジオメトリ演算は座標計算と光源計算に分けられます。
座標計算とはポリゴンの頂点の３次元座標からスクリーン（ディスプレイ画面）上
の２次元座標を求める計算で座標変換と透視変換からなります。
光源計算とは光源の方向、色、強さとポリゴンの向き、色からスクリーン上での
ポリゴンの光り方を求める計算です。

----------------------------------------------------------------------------
**座標計算
----------------------------------------------------------------------------
ここでは説明を簡単にするため座標系として

	ローカル座標系	... オブジェクトに固定の座標系
	ワールド座標系  ... オブジェクトが置かれる世界に固定の座標系
	スクリーン座標系... スクリーンに固定の座標系

の三種類を想定します。
オブジェクトとは複数のポリゴンが集まって構成している物体で、複数の
オブジェクトが１画面を構成します。従ってローカル座標系は複数個になる
可能性があります。各ポリゴンの頂点データは通常、ローカル座標系の座標値で
与えられるので、これをスクリーン上の座標値に変換するためには

	ローカル座標系 -------------------------------> ワールド座標系 
	  (Vx,Vy,Vz)					  (Wx,Wy,Wz)

	ワールド座標系 -------------------------------> スクリーン座標系
	  (Wx,Wy,Wz)					  (Sx,Sy,Sz)


	(Wx,Wy,Wz)^ = [WLij]*(Vx,Vy,Vz)^ + (WLx,WLy,WLz)^
	(Sx,Sy,Sz)^ = [SWij]*(Wx,Wy,Wz)^ + (SWx,SWy,SWz)^

という座標変換が必要です。ここで

	[WLij]はワールド/ローカルの変換マトリックス
	(WLx,WLy,WLz)はワールド/ローカルの平行移動ベクトル
	[SWij]はスクリーン/ワールドの変換マトリックス
	(SWx,SWy,SWz)はスクリーン/ワールドの平行移動ベクトル

であるとします。 ^ は転置を表します。 
これを合成すると

	(Sx,Sy,Sz)^ = [SWij]*([WLij]*(Vx,Vy,Vz)^ + (WLx,WLy,WLz)^)
					+ (SWx,SWy,SWz)^

	(Sx,Sy,Sz)^ = [SWij]*[WLij]*(Vx,Vy,Vz)^ + [SWij]*(WLx,WLy,WLz)^
					+ (SWx,SWy,SWz)^

となります。
座標系間の座標変換マトリックスと平行移動ベクトルを
前もってすべて合成したものを

	回転マトリックス(RTM)	[Rij] = [SWij]*[WLij]

	平行移動ベクトル(TRV)	(TRx,TRy,TRz)^
				 = [SWij]*(WLx,WLy,WLz)^ + (SWx,SWy,SWz)^

とよびます。回転マトリックスを使えばローカル座標値は
スクリーン座標値に１回のマトリックス乗算とベクトルの加算で計算できます。

			  
	ローカル座標系 ------------------------------> スクリーン座標系
	 (Vx,Vy,Vz)	 				(Sx,Sy,Sz)

	(Sx,Sy,Sz)^ = [Rij]*(Vx,Vy,Vz)^ + (TRx,TRy,TRz)^   ........(1)

ＧＴＥは回転マトリックスと平行移動ベクトルを１つずつ定数として
持つことができます。回転マトリックス、平行移動ベクトルはそれぞれ

	SetRotMatrix
	SetTransMatrix 

という関数で設定でき座標系の位置、向きを
変えないかぎり変更する必要がありませんが、オブジェクトごとに
異なったローカル座標系を使った場合それぞれに応じた回転マトリックス、
平行移動ベクトルを設定する必要があります。

[注意]ローカル座標系の持ちかたはユーザーの自由です。

libgte にはローカル座標値からスクリーン座標値を求める計算(1)を行なう関数
として

	RotTrans

があります。これを呼べば前もって設定された回転マトリックス、平行移動ベクトル
による座標変換が行なえます。

RotTrans により求められたスクリーン座標値を使ってスクリーン上に描画すると
物体がスクリーンに平行投影されたような画像が得られます。実際の視覚では
遠くのものが小さく見える「透視変換」がかかります。

	スクリーン座標系 ---------------------> スクリーン座標系
	 (Sx,Sy,Sz)		透視変換	 (SSx,SSy)

	SSx = Sx * (h/Sz)
	SSy = Sy * (h/Sz)

ここで h は視点からスクリーンまでの距離を表します。
このように透視変換はスクリーン座標のＸ、Ｙ成分に h/SZ を乗算することにより
得られますが、libgte には RotTrans と透視変換を一度に行なう関数

	RotTransPers

があります。


----------------------------------------------------------------------------
**光源計算
----------------------------------------------------------------------------
ＧＴＥの想定している光源計算モデルは平行光源の完全散乱反射モデルです。
つまり視点の位置に依存せず、光源の属性とポリゴンの属性だけで決まります。

ここではポリゴンの一つの頂点について光源計算をする場合を説明します。
ポリゴンの一つの頂点の属性は

	法線ベクトル			(Nx,Ny,Nz)
	頂点の色			(R,G,B)

の二つです。ここで法線ベクトルは通常ローカル座標系で与えられます。
一方、光源の属性とは、

	光源ベクトル(方向と強さ)	(Lx,Ly,Lz)
	光源の色			(LR,LG,LB)
	アンビエント色			(RBK,GBK,BBK)

の三つです。光源は平行光源ですから位置の情報はありません。また光源は
各オブジェクトに共通ですからワールド座標系で与えられます。
背景色とは光源の影響以外にすべての頂点にかけられる光の色です。

これらから頂点がスクリーン上で何色(RR,GG,BB)に描かれるかは次のようにして
計算されます。

	1)法線ベクトルをワールド座標系に座標変換する。

		法線ベクトル(ローカル) -----> 法線ベクトル(ワールド)
		 (Nx,Ny,NZ)^			[WLij]*(Nx,Ny,Nz)^

	2)光源ベクトルと法線ベクトル（ワールド）の内積をとる。

		法線ベクトル(ワールド)・光源ベクトル -----> 光源の影響
		 [WLij]*(Nx,Ny,Nz)^	 (Lx,Ly,Lz)	        L

		L = (Lx,Ly,Lz)*[WLij]*(Nx,Ny,Nz)^

	3)この内積と光源の色を項別に乗算する。これにより頂点に対する光源の
	影響色が求める。

		光源の影響 * 光源の色 -----> 光源の影響色
		     L       (LR,LG,LB)	     (L*LR,L*LG,L*LB)

	4)光源の影響色とアンビエント色を足してすべての環境からの
	影響色を求める。

		光源の影響色     + アンビエント色 -----> 影響色
		(L*LR,L*LG,L*LB)   (RBK,GBK,BBK)  	(RLT,GLT,BLT)

		RLT = RBK + L*LR
		GLT = GBK + L*LG
		BLT = BBK + L*LB

	5)頂点の色に影響色を項別に乗算して頂点のスクリーン上の色が
	求められます。

		RR = R*RLT
		GG = G*GLT
		BB = B*BLT
		
３つの光源があるとすると1)2)は

	L1 = (Lx1,Ly1,Lz1)*[WLij]*(Nx,Ny,Nz)^
	L2 = (Lx2,Ly2,Lz2)*[WLij]*(Nx,Ny,Nz)^
	L3 = (Lx3,Ly3,Lz3)*[WLij]*(Nx,Ny,Nz)^
	
のようになります。

	(Lx1,Ly1,Lz1)*[WLij]
	(Lx2,Ly2,Lz2)*[WLij]
	(Lx3,Ly3,Lz3)*[WLij]

を前もって乗算しておいたものを[Lij]と書くと1)2)は

	(L1,L2,L3)^ = [Lij]*(Nx,Ny,Nz)^

と一回のマトリックス演算で実現できます。
このマトリックス[Lij]をＧＴＥでは

	ローカルライトマトリックス(LLM)

とよびます。
このようにlibgteではポリゴンごとに与えられる法線ベクトルを
ワールド座標系に変換する必要がありません。オブジェクトごとに
ローカルライトマトリックス[Lij]を計算すれば済みます。

一方、光源の色も３個存在することになりますから3)は

	(LR1*L1,LG1*L1,LB1*L1)^ = (LR1,LG1,LB1)^*L1
	(LR2*L2,LG2*L2,LB2*L2)^ = (LR2,LG2,LB2)^*L2
	(LR3*L3,LG3*L3,LB3*L3)^ = (LR3,LG3,LB3)^*L3

となります。この

	(LR1,LG1,LB1)^
	(LR2,LG2,LB2)^
	(LR2,LG2,LB2)^

というマトリックスを[LRi]とかくと３光源のときの3)4)は

	(RLT,GLT,BLT)^ = (RBK,GBK,BBK)^ + [LRi]*(L1,L2,L3)^  

となります。[LRi]をＧＴＥでは

	ローカルカラーマトリックス(LCM)

とよびます。ローカルライトマトリックス、ローカルカラーマトリックスも
回転マトリックスと同様にＧＴＥの定数マトリックスです。
それぞれ SetLightMatrix、SetColorMatrix で設定できます。
また、アンビエント色は

	バックカラー(BK)

とよばれ SetBackColor で設定できます。

以上をまとめるとＧＴＥでは1)2)3)4)5)の計算を３光源までを標準にして

	6)法線ベクトル(ローカル) -------------------------> 光源の影響
				ローカルライトマトリックス

		(L1,L2,L3)^ = [Lij]*(Nx,Ny,Nz)^

	7)光源の影響 -------------------------------------> 影響色
		   ローカルカラーマトリックス,バックカラー

		(RLT,GLT,BLT)^ = (RBK,GBK,BBK)^ + [LRi]*(L1,L2,L3)^  

	8)影響色、頂点の色 -------------------------------> 頂点スクリーン色

		RR = R*RLT
		GG = G*GLT
		BB = B*BLT

のようにまとめられます。libgte には6)7)8)を一度に行なう関数に

	NormalColorCol

があります。影響色のことをＧＴＥではローカルカラー（LC)と呼びます。

----------------------------------------------------------------------------
**法線ベクトル、光源ベクトルの方向
----------------------------------------------------------------------------
ポリゴンの各頂点に与えられる法線ベクトルは「おもて面」側から
「うら面」側へ向かう方向にしてください。

光源ベクトルは光源の位置ではなく、光線の進む方向にしてください。

----------------------------------------------------------------------------
**GPUコードについて
----------------------------------------------------------------------------
GTEは内部にGPUパケットコードを保持するレジスターを持っており
光源計算を行なってRGB値を出力する関数はRGB値の頭にそのGPUパケットコード
をくっつけて出力します。GPUのパケットはRGBとコードが１ワードに
なっていますから、こうすることにより１回のメモリライトでパケットの
RGBcd部分を作ることができます。
GTE内部のGPUパケットコードレジスターが正しく設定されていないと
GPUパケットが正しく生成できません。
GPUパケットコードレジスターを設定するには各光源計算関数の入力の
原色ベクトルの最上位８ビットにGPUパケットコードを設定すれば
自動的にコピーされます。ただし、入力に原色ベクトルを持たない関数
の場合は SetRGBcd() という関数をお使いください。
GPUパケットコードをコピーする関数は下記の通りです。(*は原色ベクトルの
入力がありません）

DpqColorLight
DpqColor
DpqColor3
Intpl		*
NormalColor	*
NormalColor3	*
NormalColorDpq	
NormalColorDpq3	
NormalColorCol	
NormalColorCol3	
ColorDpq
ColorCol
RotColorDpq
RotColorDpq3
RotAverageNclipColorDpq3
RotAverageNclipColorCol3
RotColorMatDpq
ColorMatDpq
ColorMatCol



----------------------------------------------------------------------------
*法線クリップ
	
============================================================================
法線クリップとは、視点からみて裏面の見えるポリゴンを描画しないで
描画速度をあげる方法です。おもて面が見えるか裏面が見えるかは、ポリゴン
の法線のスクリーン座標系でのＺ成分の符号で決まります。
球面のような閉曲面で有効です。また「Ｚソート問題」を低減するのにも有効です。

----------------------------------------------------------------------------
**libgteの法線クリップ関数
----------------------------------------------------------------------------
ポリゴンの法線のスクリーン座標系でのＺ成分は法線の座標変換によって
もとまりますが、ポリゴンの２辺の外積によっても求められます。
libgteには法線クリップのための２次元外積を計算する関数があります。

	NormalClip

これは３つの頂点のスクリーン座標から三角形の表裏を判別するための
値を計算します。表裏はその返り値の正負で判断できますが、
座標軸の向きや頂点の順番で符号が変わります。
ここでは下図のような座標軸の向きを想定します。

		   Z+
		  /
		 /
		+------X+
	       /|
	      /	|
	     /	Y+
	   eye

視点はＺ軸の負の方向にあります。視点から見たとき、３頂点が右回りに
並んでいるとNormalClipは正の値を返します。

		0-----1
		|    /
		|   /
		|  /
		| /
		|/
		2

NormalClipと同じ計算を行なう関数

	RotNclip
	RotNclip3
	RotNclip4
	RotAverageNclip3
	RotAverageNclip4
	RotAverageNclipColorDpq3
	RotAverageNclipColorCol3

では外積値が負または０のとき法線クリップすることとし、
	    ^^^^^^^^^^
座標計算を中止し、正しくないsx,syの値を返します。
		  ^^^^^^^^^^
従って、これらの関数を使うときは上の座標系で

ポリゴンの頂点順は、おもて面側から見て右回りになるよう
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
モデリングする必要があります。


４頂点関数

	RotNclip4
	RotAverageNclip4

は最初の３つの点を使って外積値を計算するので、下図のように
頂点の順番を決める必要があります。

	(1)			(2)
	   0-----1	または     0-----1
	   |     |                 |     |
	   |     |                 |     |
	   2-----3                 3-----2

ただし、ＧＰＵは(2)の順では四角形を描画しないので(1)のように決めておく
方が便利です。


----------------------------------------------------------------------------
*デプスキューイング
	
============================================================================
デプスキューイングとは遠方にある物体ほどかすんで見える効果で
光源計算によって求められたスクリーン上の頂点色と遠方色を頂点の
スクリーン座標系におけるＺ値に応じて混ぜ合わせることによって実現できます。

ＧＴＥには非線形な混ぜ合わせにより効果的なデプスキューイングを
行なう機能があります。この機能を使うには、まず次の関数で定数を設定
する必要があります。

	SetFarColor
	SetFogNear

SetFarColor は遠方色を決める関数です。たとえば白色を設定すればフォグのように
黒色を設定すれば夜の闇のようになります。
SetFogNear はデプスキューイングを開始する地点を設定する関数です。

これらの定数を設定しておき RotTransPers を実行すると p という変数に
混ぜ合わせの係数が返ってきます。この係数を使って

	NormalColorDpq

を行なえば頂点スクリーン色は遠方色と混ぜ合わせられた値が返ってきます。


----------------------------------------------------------------------------
*バックカラー、ファーカラー、ＢＧカラー
	
============================================================================
ＰＳＸでは、

SetBackColorで設定されるアンビエント色をバックカラー、	...BK
SetFarColorで設定される遠方色をファーカラー、		...FC
ＢＧ面に貼られる色をＢＧカラー				...BG

と呼びます。

デプスキューイングでＢＧ面にとけこませたいときは、
ファーカラーとＢＧカラーを一致させます。
バックカラーとＢＧカラーは異なることに注意してください。

----------------------------------------------------------------------------
*材質つき光源計算
	
============================================================================
ＰＳＸにおける光源計算（デプスキューなし）をまとめると以下のようになります。

	1)	(L1,L2,L3)^ = [Lij]*(Nx,Ny,Nz)^

	2)	(RLT,GLT,BLT)^ = (RBK,GBK,BBK)^ + [LRi]*(L1,L2,L3)^  

	3)	RR = R*RLT
		GG = G*GLT
		BB = B*BLT

ここで
	(Nx,Ny,Nz):	法線ベクトル
	[Lij]:		ローカルライトマトリックス(LLM)
	(L1,L2,L3):	ローカルライトベクトル(LLV)
	[LRi]:		ローカルカラーマトリックス(LCM)
	(RBK,GBK,BBK):	バックカラー(BK)
	(RLT,GLT,BLT):	ローカルカラー(LC)
	(R,G,B):	原色ベクトル
	(RR,GG,BB):	出力色ベクトル
です。
「libgteリファレンスマニュアル」では上のような計算を次のように省略して
書いてあります。

	1)	LLV = LLM*v0
	2)	LC = BK + LCM*LLV
	3)	v2 = v1*LC

ところで 1) の計算のあとに LLV の各項を２乗したものをあらためて LLV
とすることができます。

	1)	LLV = LLM*v0
	2)	LLV = LLV^2 = (L1^2,L2^2,L3^2)
	3)	LC = BK + LCM*LLV
	4)	v2 = v1*LC

このようにすると光源によって光る部分が狭くなりオブジェクトの材質感が
変わります。libgte では

	RotColorMatDpq
	ColorMatDpq
	ColorMatCol

という材質つき関数を用意してあります。

----------------------------------------------------------------------------
*３頂点、４頂点関数
	
============================================================================
libgte には３頂点、４頂点分の座標変換や光源計算を一度に行なう関数があります。
たとえば RotTransPers3 や RotTransPers4 はそれぞれ３頂点、４頂点の座標変換
を一度に行ないます。またNormalColorCol3 や NormalColorDpq3 は
３頂点の光源計算を一度に行ないます。

独立頂点三角形や独立頂点四角形でできたデータから描画するときはこれらを
使えば高速に処理できます。

----------------------------------------------------------------------------
*libgte 引数フォーマット
	
============================================================================
ＧＴＥではすべての数が固定小数点であらわされます。
たとえば、回転マトリックスは各成分が (1,3,12) のフォーマットの
固定小数点数です。

	＊ここで (1,3,12) とは

		符号：1 ビット
		整数部：3 ビット
		小数部：12 ビット

	を表します。

そのため RotTrans(&v0,&v1,&flag) は次のように計算されます。

	v1.vx = TRX + (R00*v0.vx+R01*v0.vy+R02*v0.vz)>>12
	v1.vy = TRY + (R10*v0.vx+R11*v0.vy+R12*v0.vz)>>12
	v1.vz = TRZ + (R20*v0.vx+R21*v0.vy+R22*v0.vz)>>12

ここで、v0,v1は下のような構造体SVECTORです。

	typedef struct { 
        	short   vx, vy;
        	short   vz, pad;
	} SVECTOR;

[Rij]は回転マトリックス、(TRX,TRY,TRZ)は平行移動ベクトルです。
従って v0 と v1 の小数点以下のフォーマットは (TRX,TRY,TRZ) と同じです。
(TRX,TRY,TRZ) のフォーマットは (1,31,0) なので、
v0 は (1,15,0)、v1は (1,31,0) になります。

以下に GTE の主な定数の推奨フォーマットを示します。

	回転マトリックス [Rij]:(1,3,12)
	平行移動ベクトル (TRX,TRY,TRZ):(1,31,0)
	ローカルライトマトリックス [Lij]:(1,3,12)
	ローカルカラーマトリックス [L(R,G,B)i]:(1,3,12)
	バックカラー (RBK,GBK,BBK):(0,32,0) (0...255）
	ファーカラー (RFC,GFC,BFC):(0,32,0) (0...255）

これ以外のフォーマットでも計算可能ですが12ビットシフトがＧＴＥに
内蔵されていることを考慮しなければならず複雑になります。

各関数の引数フォーマットはlibgteリファレンスマニュアルを参照してください。

----------------------------------------------------------------------------
*libgteで使用される構造体	
	
============================================================================
libgteで使用される構造体には次のようなものがあります。

----------------------------------------------------------------------------
**座標計算、光源計算
----------------------------------------------------------------------------
・ベクトル	
typedef struct {		/* long word type 3D vector */
	long	vx, vy;
	long	vz, pad;
} VECTOR;
	
typedef struct {		/* short word type 3D vector */	
	short	vx, vy;
	short	vz, pad;
} SVECTOR;
	       
typedef struct {		/* RGB vector */	
	u_char	r, g, b, cd;
} CVECTOR;
	       
・マトリクス	
typedef struct  {
	short	m[3][3];	/* 3x3 マトリクス係数値 */
        long    t[3];		/* 平行移動量 */
} MATRIX;

----------------------------------------------------------------------------
**ポリゴン分割	
----------------------------------------------------------------------------
・頂点情報
typedef struct {
        short   xy[3];
        short   uv[2];
        short   rgb[3];
} SPOL;

・四角形ポリゴン
typedef struct {
        short   sxy[4][2];
        short   sz[4][2];       /*sz[][1] is dummy*/
        short   uv[4][2];
        short   rgb[4][3];
        short   code;           /*f3,tf3,g3,tg3,f4,tf4,g4,tg4*/        
} POL4;

・三角形ポリゴン
typedef struct {
        short   sxy[3][2];
        short   sz[3][2];       /*sz[][1] is dummy*/
        short   uv[3][2];
        short   rgb[3][3];
        short   code;           /*f3,tf3,g3,tg3,f4,tf4,g4,tg4*/        
} POL3;


----------------------------------------------------------------------------
*libgteのおもな関数	
	
============================================================================
libgteに含まれるおもな関数にはつぎのようなものがあります。

----------------------------------------------------------------------------
**初期設定
----------------------------------------------------------------------------
	InitGeom		:GTEの初期化

----------------------------------------------------------------------------
**定数マトリックス設定
----------------------------------------------------------------------------
	SetRotMatrix		:回転マトリックスの設定
	SetLightMatrix		:ローカルライトマトリックスの設定
	SetColorMatrix		:ローカルカラーマトリックスの設定

----------------------------------------------------------------------------
**定数ベクトル設定
----------------------------------------------------------------------------
	SetBackColor		:アンビエント色の設定
	SetFarColor		:遠方色の設定
	SetTransMatrix		:平行移動ベクトルの設定

----------------------------------------------------------------------------
**その他の定数設定
----------------------------------------------------------------------------
	SetGeomOffset		:スクリーンオフセットの設定
	SetGeomScreen		:スクリーン位置の設定

----------------------------------------------------------------------------
**座標計算
----------------------------------------------------------------------------
	RotTransPers		:回転->平行移動->透視変換
	RotTransPers3		:回転->平行移動->透視変換x3
	RotTransPers4		:回転->平行移動->透視変換x4
	RotTrans		:回転->平行移動
	RotAverage3		:回転->平行移動->透視変換x3,Z平均
	RotAverage4		:回転->平行移動->透視変換x4,Z平均
	RotNclip3		:回転->平行移動->透視変換x3,法線クリップ
	RotNclip4		:回転->平行移動->透視変換x4,法線クリップ
	RotAverageNclip3	:回転->平行移動->透視変換x3,Z平均,法線クリップ
	RotAverageNclip4	:回転->平行移動->透視変換x4,Z平均,法線クリップ
	
----------------------------------------------------------------------------
**法線クリップ
----------------------------------------------------------------------------
	NormalClip
	NormalClipP
	NormalClipPG
	NormalClipS

----------------------------------------------------------------------------
**光源計算
----------------------------------------------------------------------------
	NormalColor		:法線->影響色
	NormalColor3		:法線->影響色x3
	NormalColorDpq		:法線->影響色->デスキュー
	NormalColorDpq3		:法線->影響色->デプスキューx3
	NormalColorCol		:法線->影響色->カラー
	NormalColorCol3		:法線->影響色->カラーx3

----------------------------------------------------------------------------
**初等関数
----------------------------------------------------------------------------
	SquareRoot0		:平方根（整数->整数）
	SquareRoot12		:平方根（固定小数点->固定小数点）
	InvSquareRoot		:平方根分の１（整数->固定小数点仮数＆整数指数）
	RotMatrix		:回転マトリックス(rcos,rsin使用）
	RotMatrixC		:回転マトリックス(ccos,csin使用）
	rcos			:cos関数（高速、テーブル大）
	rsin			:sin関数（高速、テーブル大）
	ccos			:cos関数（中速、テーブル小）
	csin			:sin関数（中速、テーブル小）
	cln			:自然対数（固定小数点->固定小数点）
	csqrt			:平方根（固定小数点->固定小数点）
	catan			:arctan関数（固定小数点->固定小数点）
	ratan2			:arctan関数（２引数，高速，テーブル使用）
	OuterProduct0		:外積
	OuterProduct12		:外積
	VectorNormal		:ベクトル正規化
	VectorNormalS		:ベクトル正規化

----------------------------------------------------------------------------
**メッシュ関数
----------------------------------------------------------------------------
	RotMeshS		:strip mesh COLOR
	RotMeshS_G3		:strip mesh GOURAUD
	RotMeshS_F3		:strip mesh FLAT
	RotMeshS_T3		:strip mesh TEXTURE
	RotMeshR		:round mesh COLOR
	RotMeshR_G3		:round mesh GOURAUD
	RotMeshR_F3		:round mesh FLAT
	RotMeshR_T3		:round mesh TEXTURE

----------------------------------------------------------------------------
*libgteの関数のフラグ変数について
	
============================================================================

libgte の座標計算関数 Rot... はクリッピングを行なうためのフラグ変数が
ついています。座標計算関数は以下のとおりです。

	RotTransPers
	RotTransPers3
	RotTrans
	RotTransPers4
	RotAverage3
	RotAverage4
	RotNclip
	RotNclip3
	RotNclip4
	RotAverageNclip3
	RotAverageNclip4
	RotColorDpq
	RotColorDpq3
	RotAverageNclipColorDpq3
	RotAverageNclipColorCol3
	RotColorMatDpq
	
これらの関数では座標変換をした直後のフラグの状態を返します。

RotTransPers3、RotTransPers4 など３頂点、４頂点の座標変換をする関数では
各頂点の座標変換結果のフラグのORを返します。
ただし、RotNclip4、RotAverageNclip4 は返り値が -1 のとき、すなわち
法線クリップされたとき最後の１頂点は計算されませんから、
最初の３頂点の座標変換結果のフラグの OR になります。
フラグのビットの意味は次の通りです。

MSB
31-(30)|(29)|(28)|(27)|(26)|(25)|(24)|(23)|(18)|(17)|(16)|(15)|(14)|(13)|(11)
30-計算途中でのオーバーフロー(>=2^43)
29-計算途中でのオーバーフロー(>=2^43)
28-計算途中でのオーバーフロー(>=2^43)
27-計算途中でのオーバーフロー(<-2^43)
26-計算途中でのオーバーフロー(<-2^43)
25-計算途中でのオーバーフロー(<-2^43)
24-出力値が[-2^15,2^15)を超えた
23-出力値が[-2^15,2^15)を超えた
22-出力値が[-2^15,2^15)を超えた
21-出力値が[0,2^8)を超えた
20-出力値が[0,2^8)を超えた
19-出力値が[0,2^8)を超えた
18-スクリーン座標系でのZ値が[0,2^16)を超えた
17-透視変換後のZ座標がh/2より小さくなった
16-計算途中でのオーバーフロー(>=2^32)
15-計算途中でのオーバーフロー(<-2^32)
14-透視変換後のX座標が[-2^10,2^10)を超えた
13-透視変換後のY座標が[-2^10,2^10)を超えた
12-pの値が[0,2^12)を超えた
11-0使われていません
LSB

ここでhは視点からスクリーンまでの距離です。


つぎの関数は１６ビットのフラグを返します。

	RotTransPersN
	RotTransPers3N
	RotMeshH

１６ビットのフラグの意味は次の通りです。

MSB
15-計算途中でのオーバーフロー(<-2^43)
14-計算途中でのオーバーフロー(<-2^43)
13-計算途中でのオーバーフロー(<-2^43)
12-出力値が[-2^15,2^15)を超えた
11-出力値が[-2^15,2^15)を超えた
10-出力値が[-2^15,2^15)を超えた
9-出力値が[0,2^8)を超えた
8-出力値が[0,2^8)を超えた
7-出力値が[0,2^8)を超えた
6-スクリーン座標系でのZ値が[0,2^16)を超えた
5-透視変換後のZ座標がh/2より小さくなった
4-計算途中でのオーバーフロー(>=2^32)
3-計算途中でのオーバーフロー(<-2^32)
2-透視変換後のX座標が[-2^10,2^10)を超えた
1-透視変換後のY座標が[-2^10,2^10)を超えた
0-pの値が[0,2^12)を超えた
LSB

----------------------------------------------------------------------------
*libgteのメッシュ関数について
	
============================================================================
libgteは２種類の三角メッシュ型のデータをサポートしています。
メッシュ型データを使うと頂点計算の回数とデータの容量を減らすことができます。

一つは strip mesh と呼ばれるもので下図のようにジグザグに頂点が並んでいます。 

            1---------3
           / \       / \
          /   \     /   \
         /     \   /     \
        /       \ /       \
       0---------2---------4


もう一つは round mesh と呼ばれるもので下図のように０番目の頂点の
まわりを他の頂点が取り囲んでいます。

            2---------3
           / \       / \
          /   \     /   \
         /     \   /     \
        /       \ /       \
       1---------0---------4

どちらの場合も最初の三角形 012 がこの順に右回りであるとき 012 は表示され、
ほかの三角形は 012 の向きを規準に表裏が決められます。

注意]
光源計算（シェーディングやデプスキューイング）を行なう場合は
法線クリップをできなくなりますので計算速度が必ず増すとは限りません。
メッシュデータが計算速度上有効なのは
	シェーディング＆デプスキューイングなし
	フラットシェーディング
の場合です。
	
----------------------------------------------------------------------------
*画面オフセットの変更
	
============================================================================
ＰＳＸの画面オフセットの変更の方法は２通りあります。
libgpu の SetDefDrawEnv を使う方法と、
libgte の SetGeomOffset を使う方法です。


----------------------------------------------------------------------------
*ＰＭＤ関数

============================================================================
libgteには下記のようなフォーマットのデータを読み込み
座標変換を行なったあとGPUパケットを生成しOTへリンクするPMD関数
が用意されています。これらのデータはあらかじめパケットの定数と
色変数、テクスチャ変数などがプリセットされているため
座標変数だけを設定すればよく高速に描画ができます。

PRIMITIVE Group
---------------
 PRIMITIVE Gp部は同一の属性を持つの描画パケットが並んだもので、
１つのパケットで１個のプリミティブを表します。


		１つのPrimitive Groupは次のような構造になっています。

　　　　　　　　31(MSB)　　　　　　　　　　0(LSB)
　　　　　　　　┌───────┬───────┐
　　　　　　　　│     TYPE     │   NPACKET    │
　　　　　　　　├───────┴───────┤
　　　　　　　　│　　　　　　　　　　　　　　　│
　　　　　　　　│　　   Packet Data #0     　　│
　　　　　　　　│　　　　　　　　　　　　　　　│
　　　　　　　　├───────────────┤
　　　　　　　　│　　　　　　　　　　　　　　　│
　　　　　　　　│　　   Packet Data #1     　　│
　　　　　　　　│　　　　　　　　　　　　　　　│
　　　　　　　　├───────────────┤
　　　　　　　　│　　　　　　　　　　　　　　　│
　　　　　　　　│　　   Packet Data #2     　　│
　　　　　　　　│　　　　　　　　　　　　　　　│
　　　　　　　　├───────────────┤
　　　　　　　　│　　　　　　　：　　　　　　　│
　　　　　　　　│　　　　　　　　　　　　　　　│
　　　　　　　　└───────────────┘
                     Fig.5  PACKET Gp 部の構造

				NPACKET :	パケット数
				TYPE :		パケットタイプ

		TYPEのbit構成

		bit No.		0のとき		1のとき
		----------------------------------------------
		16		3角形		4角形
		17		Flat		Gouraud
		18		Texture-On	Texture-Off
		19		独立Vertex	共有Vertex
		20		光源計算OFF	光源計算ON
		21		Back clipあり	Back clipなし
		22〜31		       ( Reserved )


		Packet Dataの構成はTYPEの値によって変化します。
		TYPE別 Packet Data構成は次の通り

		（注１）構造体中のプリミティブ部(POLY_***)はダブルバッ
			ファ対応のために２セット用意されます。
			双方の内容はあらかじめ初期化されている必要があ
			ります。
		（注２）bit20,21 はPacket Dataの構成には影響しません。

		TYPE=00 (3角形/Flat/Texture-ON/独立頂点)
			struct _poly_f3 {			
				POLY_F3	pkt[2];
				SVECTOR v1, v2, v3;
			}

		TYPE=01 (4角形/Flat/Texture-ON/独立頂点)
			struct _poly_f4 {
				POLY_F4	pkt[2];
				SVECTOR v1, v2, v3, v4;
			}

		TYPE=02 (3角形/Gouraud/Texture-ON/独立頂点)
			struct _poly_g3 {			
				POLY_G3 pkt[2];
				SVECTOR v1, v2, v3;
			}

		TYPE=03 (4角形/Gouraud/Texture-ON/独立頂点)
			struct _poly_g4 {			
				POLY_G4 pkt[2];
				SVECTOR v1, v2, v3, v4;
			}

		TYPE=04 (3角形/Flat/Texture-OFF/独立頂点)
			struct _poly_ft3 {			
				POLY_FT3 pkt[2];
				SVECTOR v1, v2, v3;
			}

		TYPE=05 (4角形/Flat/Texture-OFF/独立頂点)
			struct _poly_ft4 {			
				POLY_FT4 pkt[2];
				SVECTOR v1, v2, v3, v4;
			}

		TYPE=06 (3角形/Gouraud/Texture-OFF/独立頂点)
			struct _poly_gt3 {			
				POLY_GT3 pkt[2];
				SVECTOR v1, v2, v3;
			}

		TYPE=07 (4角形/GouraudFlat/Texture-OFF/独立頂点)
			struct _poly_gt4 {			
				POLY_GT4 pkt[2];
				SVECTOR v1, v2, v3, v4;
			}

		TYPE=08 (3角形/Flat/Texture-ON/共有頂点)
			struct _poly_f3c {			
				POLY_F3	pkt[2];
				long vp1, vp2, vp3;
			}

		TYPE=09 (4角形/Flat/Texture-ON/共有頂点)
			struct _poly_f4c {
				POLY_F4	pkt[2];
				long vp1, vp2, vp3, vp4;
			}

		TYPE=0a (3角形/Gouraud/Texture-ON/共有頂点)
			struct _poly_g3c {			
				POLY_G3 pkt[2];
				long vp1, vp2, vp3;
			}

		TYPE=0b (4角形/Gouraud/Texture-ON/共有頂点)
			struct _poly_g4c {			
				POLY_G4 pkt[2];
				long vp1, vp2, vp3, vp4;
			}

		TYPE=0c (3角形/Flat/Texture-OFF/共有頂点)
			struct _poly_ft3c {			
				POLY_FT3 pkt[2];
				long vp1, vp2, vp3;
			}

		TYPE=0d (4角形/Flat/Texture-OFF/共有頂点)
			struct _poly_ft4c {			
				POLY_FT4 pkt[2];
				long vp1, vp2, vp3, vp4;
			}

		TYPE=0e (3角形/Gouraud/Texture-OFF/共有頂点)
			struct _poly_gt3c {			
				POLY_GT3 pkt[2];
				long vp1, vp2, vp3;
			}

		TYPE=0f (4角形/GouraudFlat/Texture-OFF/共有頂点)
			struct _poly_gt4c {			
				POLY_GT4 pkt[2];
				long vp1, vp2, vp3, vp4;
			}

			pkt[]は対応する描画プリミティブパケット
			v1〜v4の値は頂点座標値
			vp1〜vp4の値は共有頂点列の先頭からのオフセットです。


VERTEX
------

VERTEX部は共有頂点を表すSVECTOR構造体の配列です。１つの構造体のフォーマッ
トは次に示す通りです。


　　　　 MSB   　　　　　　　　　　　LSB
	┌───────┬───────┐
	│　　　VY　　　│　　　VX　　　│
	├───────┼───────┤
	│　　　--　　　│　　　VZ　　　│
	└───────┴───────┘
	        Fig.6  VERTEX構造体
                                 VX, VY, XZ : 	頂点座標のx,y,z値（16bit整数）

----------------------------------------------------------------------------
**ＳＭＤ，ＲＭＤ関数
----------------------------------------------------------------------------
ＰＭＤ関数の高速版としてＳＭＤ関数、ＲＭＤ関数があります。
両方ともＰＭＤと同じフォーマットのデータを処理できます。
ＳＭＤは常に法線クリップを行ない、ＲＭＤは常に行ないません。

----------------------------------------------------------------------------
*ポリゴン分割
	
============================================================================
PlayStationは、多くの小さなポリゴンを効率良く生成するように設計されています。
大きなポリゴンは分割処理を用いて小さなポリゴンに分割すると、クリッピング処理
も効率良く行なわれ、テクスチャの歪みも小さくなります。

ポリゴン分割処理はlibgsで自動分割アトリビュートを用いてオブジェクト単位に行なうか
以下の関数を直接呼ぶことにより利用できます。

DivideF3		/*フラット３角形*/
DivideF4		/*フラット４角形*/
DivideFT3		/*フラットテクスチャ３角形*/
DivideFT4		/*フラットテクスチャ４角形*/
DivideG3		/*グーロー３角形*/
DivideG4		/*グーロー４角形*/
DivideGT3		/*グーローテクスチャ３角形*/
DivideGT4		/*グーローテクスチャ４角形*/

