$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
=============================================================================
<PlayStation OS> 概要 
*<PlayStation OS>とは
略
*<PlayStation OS>の特徴
略
*OSの起動／操作
<PlayStation OS>は「ゲームプログラム開発者のための環境」を提供するOSです。従っ
てユーザはこれを直接操作するためのにインターフェースは、基本的に装備されていま
せんん（デバッグ環境下でのデバッグモニタを除く）。ユーザインターフェイスは、ア
プリケーションの責任において提供する必要があります。
**OSの起動
まず、ROMの特定番地にジャンプし、接続されているハードウェア（CD-ROMドライブな
ど）のチェックを行ないます。
次にCD-ROMドライブ中のディスク種別判定を行ないます。ディスクが適したものであれ
ば、システム設定ファイル（system.cnf）を検索し、これに従って起動します。
また、ディスクが入っていない場合は、CDプレーヤーとメモリカード管理のふたつの機
能を備えたROM常駐プログラム「OSD」（On Screen Display）が起動されます。
ブートシーケンスについては「ハードウェアガイド」をご参照ください。
**システム設定ファイル-system.cnf
ここに<PlayStation>システムの設定、起動するアプリケーション等を記述します。
パラメータは、行頭から「＜キーワード＞ = ＜内容＞」の形式で記述します。記述は
すべて1バイト英数字、大文字で行ない、等号の両端には半角空白が必要です。小文字
は使用できません。また、数値は16進表記です。ファイル内に同一パラメータが複数存
在する場合は、最初に見つかった内容が優先されます。
記述可能なパラメータは次のとおりです。

	表：システム設定ファイルのキーワード一覧
       ========================================================================
	キーワード	内容
       ------------------------------------------------------------------------
	BOOT		起動するファイル名を指定。デフォルトはcdrom:PSX.EXE;1
			例：BOOT = cdrom:PSXAPP.EXE;1
	TCB		タスク管理ブロック要素数を指定。デフォルトは4。
			例：TCB = 5
	EVENT		イベント管理ブロック要素数を指定。デフォルトは16。
			例：EVENT = 5
	STACK		BOOTで指定したファイルが起動される時のスタックポインタ
			の値。デフォルトは0x801ff00。
			例：STACK = 800ffff0
       ------------------------------------------------------------------------


=============================================================================
<PlayStation>ライブラリの構成

*<PlayStation>ライブラリの構成

<PlayStation>のライブラリには、<PlayStation OS>との関係を基準にして、低レベル
ライブラリ、高レベルライブラリの２種類があり、これが２層構造を形成しています。
プログラマはどちらのレベルのライブラリでも目的に応じて使いわけることができ、ま
た同時に２つのレベルのライブラリを使うこともできます。

          -----              ------         -------          -------
         |libgs|            |libsnd|       |libcd  |        |libcard|
         |     |            |      |       |       |        |libcomb|
     ------------------------------------------     ------- |libmath|
    |libgpu |libgte |libapi |libspu| libpress |    | libetc |libc   |
     ---------------------------------------------------------------

以下、各ライブラリについて、その概要をご紹介いたします。

**libapi （カーネルライブラリ）
アプリケーションと <PlayStation OS> とのインタフェース (API)を提供するライブラ
リです。

**libetc （ETCライブラリ）
コントローラなどの周辺機器や低レベルの割り込み処理のためのコールバックの制御を
行なうためのライブラリです。

**libcd （CD-ROMライブラリ）
CD-ROMドライブから画像や音声データ、およびプログラムを読み出したり、DA（デジタ
ルオーディオ）やXAサウンド再生などを行なうためのライブラリです。
ファイル名をキーとした高速なディスクアクセスや、データの読みだしと処理を同時に
行なう「ストリーミング」技法を支援する関数も含まれています。

**libgpu （基本グラフィックスライブラリ）
描画エンジンへのコマンドを作成し、コマンドリストに登録するためのライブラリで
す。ここで扱われるデータはスプライト、ポリゴン、ラインなどの基本的なものです。

**libgte （基本ジオメトリライブラリ）
GTE（ジオメトリ計算エンジン）の制御を行なうためのライブラリです。ここで扱われ
るデータはマトリックス、ヴァーテックスなどの基本的なものです。

**libgs （拡張グラフィックスライブラリ）
libgpu、libgte を使って３次元グラフィックスシステムを構築したものが libgs で
す。ここで扱われるデータはオブジェクト、バックグラウンド面などのより大きな単
位となります。

**libspu (基本サウンドライブラリ）
SPU（サウンド再生処理プロセッサ）を制御するためのライブラリです。

**libsnd (拡張サウンドライブラリ）
あらかじめ譜面データとして記録しておいた発音シーケンスをバックグラウンド演奏
するライブラリです。

**libpress （データ処理ライブラリ）
画像及び音声データを圧縮（エンコード）、伸長（デコード）するためのライブラリで
す。

**libcard （メモリカードライブラリ）
リセットやパワーオフ後もデータを保存するためのメモリカードを制御するライブラリ
です。メモリカード ファイルシステム ドライバも含んでいます。

**libcomb （対戦ケーブルライブラリ）
対戦ケーブルによる<PlayStation>間の通信を行なうためのライブラリです。ブロック
サイズ8バイトの通信ドライバを含んでいます。

**libc/libc2 （C標準ライブラリ）
C標準ライブラリのサブセットです。文字関数、メモリ操作関数、文字クラステスト、
非局所ジャンプ、そしてユーティリティ関数の一部を含んでいます。
libcはROM中に本体プログラムを持つコンパクトなライブラリ、libc2はライブラリ内に
本体プログラムを持つ高速ライブラリです。

**libmath （数学ライブラリ）
ソフトウェアによる浮動小数点数演算パッケージを含むANSI/IEEE754準拠の数学関数ラ
イブラリです。

データフォーマット
ライブラリは、<PlayStation> 専用グラフィックスアーティストツールならびにサウン
ドアーティストツールが供給する各種データフォーマットを解釈することができます。
データフォーマットの詳細については別紙をご参照ください。


=============================================================================
カーネルライブラリ

*概要
カーネルライブラリでは、CPU を含む <PlayStation>ハードウェアを制御する各種の
サービスを、カーネル本体へのジャンプ命令を中心とするＣ言語関数として提供して
います。
カーネルライブラリが提供するサービスには以下のものがあります。
	(a)ルートカウンタ管理サービス
	(b)イベント管理サービス
	(c)スレッド管理サービス
	(d)IO 管理サービス
	(e)モジュール管理サービス
	(f)コントローラサービス
	(g)その他サービス

**ライブラリファイル
カーネルライブラリのファイル名は「libapi.lib」です。各サービスを呼び出すプログラムは、必ずこれをリンクする必要があります。

**インクルードヘッダ
カーネルライブラリのインクルードヘッダは「kernel.h」です。
各種のデータ構造、マクロ（IO 管理サービス関連、レジスタ指定マクロを除く）はす
べてこのファイルで定義されています。
各サービス（IO 管理サービスと標準Ｃ関数を除く）を呼び出すプログラムは、必ずこ
れをインクルードする必要があります。

       ==================================
	内容		ファイル名
       ----------------------------------
	ライブラリ	libapi.lib
	ヘッダ		kernel.h
       ----------------------------------

**カーネルの設定
ブート時に、システム設定ファイル「system.cnf」を読み込み、これに記述されたパラ
メータに従ってメモリ確保などが行なわれます。ブートデバイスはハードウェアにより
異なります。
パラメータは、行頭から「<キーワード> = <内容>」の形式で記述します。記述はすべ
て1バイト英数字・大文字で行ない、等号の両側には半角空白を必ず挿入します。小文
字は使用できません。また、ファイル内に同一パラメータが複数存在する場合は、最初
に見つかった内容が優先されます。記述可能なパラメータは次の通りです。

       ======================================================================
	キーワード	設定内容			デフォルト（／最小）
       ----------------------------------------------------------------------
	BOOT		ブートファイル名		cdrom:PSX.EXE;1
	STACK		ブート時スタックポインタ値	0x801fff00
	TCB		タスク管理ブロック要素数	4/1
	EVENT		イベント管理ブロック要素数	16/0
       ----------------------------------------------------------------------

**システムテーブル情報 ToT
サービス実現のためにカーネル内部で使用する各種システムテーブルへのアクセスを統一的に扱うため、システムテーブル情報が構造体 ToT(Table of Tables) として公開されています。ToT はアドレス 0x00000100 に配置されます。
ToT のエントリと内容は次のようになっています。

       ==========================================
	エントリ	内容
       ------------------------------------------
	0		システム予約
	1		タスク状態キューヘッダ
	2		タスク管理ブロック
	3		システム予約
	4		イベント管理ブロック
	5〜31		システム予約
       ------------------------------------------

ToT のデータ構造は次のようになっています。構造体はライブラリに添付されているヘッダファイル「kernel.h」中で定義されています。

	struct ToT {			/* システムテーブルのテーブル	*/
		unsigned long *head;	/* システムテーブル先頭アドレス	*/
		long size;		/* システムテーブルサイズ（バイト）*/
	};

具体的には次のように利用します。

例１ 実行TCB（タスク管理ブロック）へのポインタの取得
	struct ToT *t = (struct ToT *)0x100;
	struct TCBH *h = (struct TCBH *)((t+1)->head);
	struct TCB *tcb_exec = (struct TCB *)(h->entry);

例２ 先頭TCBへのポインタの取得
	struct TCB *tcb_0 = (struct TCB *)((t+2)->head);

例３ 先頭イベント管理ブロックへのポインタの取得
	struct EvCB *evcb_0 = (struct EVCB *)((t+4)->head);

**ディスクリプタ
カーネルライブラリでは、ファイルやスレッドなど、システム資源を指定するために、
符号なし 32 ビット整数値である「ディスクリプタ」を使用します。ディスクリプタは
次にようなビット構成を持ちます。

	表：ディスクリプタのビットパタン
       ====================================
	ビット	内容
       ------------------------------------
	31-24	ディスクリプタ種別
	23-16	システム予約
	15-0	システムテーブル要素番号
       ------------------------------------

ディスクリプタには次の種別があります。各マクロはkernel.hに定義されています。

	表：ディスクリプタ種別
       ========================================================
	マクロ	種別内容		備考
       --------------------------------------------------------
	DescTH	スレッド
	DescHW	ハードウェア		システム内部使用
	DescEV	イベント
	DescRC	ルートカウンタ
	DescUEV	ユーザ定義フラグ
	DescSW	システムコール		システムコール内部使用
       --------------------------------------------------------

ディスクリプタをキーとしてシステム資源を使用する際の一般的な手順は次のようにな
ります。

(１) ディスクリプタの取得
まず、資源毎に用意された Open() 関数を呼び出します。関数の返り値はその資源の
ディスクリプタです。
(２) 資源の操作
Open() 関数で返されたディスクリプタで資源を指定し、操作を行います。
(３) ディスクリプタのクローズ
使用が終了したら、資源に対応する Close() 関数でディスクリプタをクローズします。

**イベント
デバイスからの外部割り込みやCPU内部で発生する例外をアプリケーションに通知する
ためのメカニズムが「イベント」です。割り込みはポーリングまたはサブルーチンフッ
クのいずれかで検出、処理できます。
フックされたサブルーチンは「割り込みコンテキスト」（後出）にてカーネル内部に確
保された割り込みスタックを使って実行されます。このスタックはカーネル予約メモリ
領域（後出）内に確保され、サイズは4Kバイトに固定されています。
割り込みスタックの最上位アドレスはGetSysSp()で取得できます。
イベントは原因ディスクリプタとイベント種別としう2つの32ビット整数で特定されま
す。これらを指定して特定のイベントを発生する関数も公開されています。これによ
り、イベントをある種のタスク間通信として利用できます。

**コールバック
DMA転送の対象となるデバイスを扱うためのライブラリ（libcpu、libsndな等）には、
転送の終了をアプリケーションに通知するための「コールバック関数」をカーネルに
登録するための関数が用意されています。コールバック関数は前出のイベントがすべて
テスト、処理された後に実行されます。
コールバック関数は「割り込みコンテキスト」（後出）にて専用に確保されたコール
バックスタックを使って実行されます。このスタックはlibetc内で宣言されており、ア
プリケーションのデータ領域に含まれます。
コールバック関数はDMA転送終了時に自動的に呼び出されますので、ここで外部変数に
よるフラグを操作したりイベントを発生させることで、転送終了処理を実行することが
できます。

**割り込みの禁止
次に挙げる操作の実行、あるいは現象の発生により、すべての割り込みが禁止されま
す。割り込みが禁止された状態を「クリティカルセクション」と呼びます。

***システム起動
システム起動直後は、割り込みが禁止されています。

***EnterCriticalSection() 関数の呼び出し
EnterCriticalSection() 関数を呼び出すと割り込みが禁止されます。割り込みを許可
するには、ExitCriticalSection() 関数を呼び出してください。

***イベントハンドラ起動直後
イベントハンドラ起動直後は、割り込みが禁止されています。割り込みを許可するに
は、ExitCriticalSection() 関数で割り込みを許可し、発生元への復帰を放棄するか、
ReturnFromException() 関数を呼び出して発生元に復帰するようにしてください。

**サービス関数とクリティカルセクション
カーネル内おデータを変更するサービスは、割り込みを禁止した状態で実行する必要が
あります。該当するサービスについてはfunction.txtの解説部にその旨を記述していま
す。
クリティカルセクションに入るにはEnterCriticalSection()関数を呼びだします。

**割り込みコンテキスト
割り込みや例外が発生すると、それまで実行されていたプログラム（以下メインフ
ロー）は強制的に中断され、アドレス0x80以降のプログラムが実行開始されます。ここ
にはカーネルの割り込みディスパッチャへのジャンプコードが配置されており、イベン
ト発生などの処理を行ないます。
処理終了後にメインフローに復帰するため、割り込み発生直後にレジスタ内容が「メイ
ンフローコンテキスト」として「実行TCB」（スレッド管理サービス参照）に退避され
ます。この退避後の状態を「割り込みコンテキスト」と呼びます。
イベントハンドラやコールバック関数は、割り込みコンテキストで実行されます。（前
者は割り込みスタック、後者はコールバックスタックを使用します。） この場合、次
のような注意および禁止事項があります。

***注意事項
(1) 割り込みを長時間停止させると、システムの動作に悪影響を与える可能性がありま
す。割り込みコンテキストで実行される関数はできる限り短時間で処理が終了するよう
に設計してください。
(2) 内部で例外を発生する関数（例：ExitCriticalSection()）を実行すると、メイン
フローコンテキストが破壊されます。ただし、スレッド管理サービスで実行TCBを切替
えればこの破壊を防ぐことができます。
(3) イベントハンドラ中では、ReturnFromException()を実行してメインフローに復帰
することができます。しかし、これは割り込みディスパッチャの動作を中断することに
なり、割り込み処理が未完のままメインフローに復帰するため、デバイス関係の不具合
が発生することがあります。従って、ReturnFromExceprtion()はエラー処理などに限定
してご利用ください。

***禁止事項
(1) 内部で割り込みを利用擦る関数の実行。割り込みが発生しないため完了しません。
(2) メインフローで呼び出される可能性のあるリエントラントでない関数の実行。カー
ネルサービスを始めとするライブラリ関数のほとんどはリエントラントではありませ
ん。リエントラントな関数については各ライブラリのfunction.txtの解説部にその旨を
記述しています。
(3) コールバック関数中でのReturnFromException()関数実行。


**カーネル予約メモリ領域
標準的な設定 (TCB=4、EVENT=16) では、カーネルはメモリの先頭 64K バイトを使用し
ます。従って、ユーザーが使用できるアドレスは 0x00010000 からとなります。


*ルートカウンタ管理サービス
時間制限やタイミングの調整など、ゲームプログラムでは欠かせないカウンタ機能を提供するサービスです。
[ルートカウンタ」とは、自動的なカウントタイミングを発生させるもので、これには、
	(ａ) 表示ピクセル
	(ｂ) 水平同期
	(ｃ) システムクロック
	(ｄ) 垂直帰線

の４つが用意されています。
このうち、(ｄ) を除く各カウンタには、16 ビットのターゲット値を設定することがで
きます。カウンタはゼロからカウントアップし、ターゲット値に達すると、次の動作が
行なわれます。
	(１)	割り込みが発生します（カウンタ毎にマスク可能）。
	(２)	自動的にゼロクリアされます。
	(３) 	カウントアップを継続します。
(ｄ) のターゲット値は１に固定されていますので、垂直帰線毎に割り込みを発生させ
ることになります。また、カウンタが発生させる割り込みをトリガとして、イベント管
理サービスにより、任意の関数を実行したり（これを「イベントハンドラ」と呼びます
）、各カウンタの値をポーリングすることもできます。
カウンタはマクロで定義されており、これを用いてアクセスすることができます。

	表：ルートカウンタ一覧
       =======================================================================
	マクロ		ルートカウンタ			備考
       -----------------------------------------------------------------------
	RCntCNT0	表示ピクセル			ターゲット値は２以上
	RCntCNT1	水平帰線、システムクロック	同上
	RCntCNT2	システムクロック８分周		同上
	RCntCNT3	垂直帰線（＊）			ターゲット値は１固定
       -----------------------------------------------------------------------
	＊カウント停止は無効です。

**カウントタイミング
システムクロックをカウントする場合、約0.03マイクロ秒に１回のカウントとなりま
す。「８分周」ではこれが８場いの間隔となります。グラフィックス表示に関連するカ
ウントは次の間隔で行なわれます。

	表：カウントタイミング
       ========================================================================
	カウンタ	表示モード			単位
	  イベント	NTSC		PAL	
       ------------------------------------------------------------------------
	垂直同期	1/60		1/50		秒
	水平同期	63.56		64.00		マイクロ秒
	ピクセル表示	N×0.0186243	N×0.01879578	マイクロ秒
       ------------------------------------------------------------------------

	表：ピクセル表示タイミングと表示幅
       ====================
	表示幅		N
       --------------------
	256 pixel	10
	320		 8
	384		 7
	512		 5
	640		 4
       --------------------

**カウントアップ
ルートカウンタはハードウェアによるカウントアップを採用しています。従って、割り
込み禁止やStopRCnt()呼びだしなどのソフトウェア的操作とは関係なくカウントアップ
鵜を継続します。
StopRCnt()関数はカウントアップを停止させません。RCntMdINTRマクロにより、割り込
みを許可されたカウンタの割り込み発生を禁止するだけです。同様にStartRCnt()関数
は割り込みを許可するだけであり、カウントアップに影響を与えることはありません。

**モード
各カウンタに次の属性モードを設定することができます。モードはマクロで定義されて
います。下表の(A)(B)(C)のマクロは論理和をとって設定できます。

	表：ルートカウンタのモード（１）
       ==================================================================
	マクロ			内容
       ------------------------------------------------------------------
	RCntMdINTR（指定必須）	割り込み許可
	RCntMdNOINTR		割り込み禁止（ポーリング専用）
       ------------------------------------------------------------------

	表：ルートカウンタのモード（２）
       ==================================================================
	マクロ		対象ルートカウンタ	カウンタ種別
       ------------------------------------------------------------------
	RCntMdSP	RCntCNT0		表示ピクセル
			RCntCNT1		水平帰線
			RCntCNT2		システムクロック８分周
			RCntCNT3		垂直帰線
	RCntMdSC	RCntCNT0,1		システムクラック
			RCntCNT2,3		無効
       ------------------------------------------------------------------

	表：ルートカウンタのモード（３）
       ==================================================================
	マクロ			内容
       ------------------------------------------------------------------
	RCntMdFR（デフォルト）	常時カウント
	RCntMdGATE		ゲート条件が有効
       ------------------------------------------------------------------

**ゲート
各カウンタは「ゲート」と呼ばれる条件が成立した状態でのみ、カウントアップされま
す。
	表：ルートカウンタのゲート条件
       ===========================================
	マクロ		ゲート条件
       -------------------------------------------
	RCntCNT0	水平帰線区間でないこと
	RCntCNT1	垂直帰線区間でないこと
	RCntCNT2,3	なし（常時カウント）
       -------------------------------------------

**カーネル起動直後の状態
カーネル起動直後は、すべてのカウンタは停止もしくはフリーランしています。従って
、使用時には必ず本サービスの関数で初期化する必要があります。また、サービスやラ
イブラリによっては、使用前にユーザによるルートカウンタの初期化を要求するものも
あります。

**ルートカウンタとクリティカルセクション
ルートカウンタは、割り込みによらずカウントアップします。しかりクリティカルセク
ション中は割り込みは発生しません。

**カーネルによるルートカウンタの使用
以下に示すケースでは、カーネルがルートカウンタを使用します。該当するサービスを
利用する場合は、ルートカウンタをカーネルの定める状態に（再）設定してください。

***コントローラボタン状態の取得
コントローラボタンの状態の取得にルートカウンタ３（垂直帰線）を使用します。ルートカウンタ３が停止、または未初期化の場合には、ボタン状態を読み取ることができません。

*イベント管理サービス
プログラムの実行とは非同期に発生する事象をトリガとして、プログラムの実行を制御
するイベント管理サービスです。
イベントの使用に際しては、まず、
	(ａ) 原因となるディスクリプタ
	(ｂ) イベント種別
	(ｃ) イベントモード
	(ｄ) ハンドラ関数へのポインタ
の４つを指定してイベントをオープンし、イベントディスクリプタを取得します。イベント発生テストなどは、このイベントディスクリプタを指定して実行します。

*イベントの状態
イベントには次の４つの状態があります（マクロで定義されています）。
イベント発生禁止中のイベントは無視されます。また、オープン直後のイベントは 
EvStWAIT 状態になっています。この場合、EnableEvent() 関数により EvStACTIVE 状
態に移行して初めてイベント発生が反映されるようになります。
DisableEvent()関数はEvStACTIVEおよびEvStREADY状態のイベントをEvStWAIT状態に
移行します。一旦EvStWAIT状態になると、その前の状態は保存されず、次に
EnableEvent()関数を作用させるとそのイベントは必ずEvStACTIVE状態となります。

	表：イベント状態
       ============================================================
	マクロ		内容			発生許可／禁止
       ------------------------------------------------------------
	EvStUNUSED	オープンされtいない	禁止
	EvStWAIT	イベント発生禁止	禁止
	EvStACTIVE	イベント未発生		許可
	EvStALREADY	イベント発生済み	禁止
       ------------------------------------------------------------

**モード
イベントには次の２つのモードがあります。モードはマクロで定義されています。

	表：イベントモード
       =======================================================
	マクロ		発生後の状態		ハンドラ関数
       -------------------------------------------------------
	EvMdINTR	EvStALREADY		起動する
	EvMdNOINTR	SvStACTIVE		起動なし
       -------------------------------------------------------

**イベントハンドラ
イベントをトリガとして関数を実行することができます。この関数を「イベントハンド
ラ」と呼びます。
ハンドラ関数は、カーネル内に確保された割り込みスタック上で、割り込みが禁止され
た状態で実行されます。関数からリターンすると、割り込み発生元に復帰します。また
、ReturnFromException() 関数を呼び出し、カーネルの割り込み処理を中断して強制的
に復帰することもできます。
更に、ExitCriticalSection() 関数により割り込みを許可し、割り込み発生元への復帰を放棄して、そのルーチンをそのままメインフローとすることも可能です。この場合、割り込みを許可する前に、スタックをユーザーが確保したものに変更する必要があります。スタックの変更は SetSp() 関数（その他サービス）で実行できます。

**原因ディスクリプタとイベント種別
原因ディスクリプタとイベント種別の関係は次のようになっています。

	表：原因ディスクリプタ（カーネルライブラリ関連のみ）
       ====================================================================
	原因ディスクリプタ	内容		イベント種別
       --------------------------------------------------------------------
	RCntCNT0		ルートカウンタ割り込み	EvSpINT
	RCntCNT1		ルートカウンタ割り込み	EvSpINT
	RCntCNT2		ルートカウンタ割り込み	EvSpINT
	RCntCNT3		ルートカウンタ割り込み	EvSpINT
	ファイルディスクリプタ	ファイル入出力		EvSpEIO
	同上			ファイルクローズ	EvSpCLOSE
	HwCdRom			CD-ROMデコーダ割り込み	EvSpUNKNOWN
	HWSPU			SPU割り込み		EvSpTRAP
	HwGPU			GPU割り込み		EvSpTRAP
	HwPIO			拡張PIO割り込み		EvSpTRAP
	HwSIO			拡張SIO割り込み		EvSpTRAP
	HwCPU			例外			EvSpTRAP
	DescUEV|m		ユーザ定義イベント	任意
				（m=0〜0xffff）
       --------------------------------------------------------------------
	＊この他、一部ライブラリがイベントを定義しています。


**データ構造
イベント管理ブロックのデータ構造は次のようになっています。
       struct EvCB {			/* イベント管理ブロック */
                unsigned long desc;	/* 原因ディスクリプタ */
                long status; 		/* ステータス */
                long spec;		/* イベント種別 */
                long mode;		/* モード */
                (long *FHandler)();	/* 関数型ハンドラ */
                long system[2];		/* システム予約 */
        };

**イベントの発生
DeliverEvent()関数に原因ディスクリプタとイベント種別を指定して実行することによ
り、該当するすべてのイネーブルされたイベントの状態がEvStALREADY状態に移行しま
す。またEvMdINTRモードのイベントについては、DeliverEvent()関数の中でイベントハ
ンドラ関数が実行されます。

**イベントのクリア
オープンされたイベントの状態をEvStALREADYからEvStACTIVEに移行することを「クリ
ア」と呼びます。イベントのクリアはUnDeliverEvent()関数またはTestEvent()関数で
行ないます。
UnDeliverEvent()関数は原因ディスクリプタとイベント種別を引数として要求し、該当
するすべてのイベントをクリアします。
TestEvent()関数はイベントディスクリプタを引数とし、そのディスクリプタに対応す
るイベントがEvStALREADY状態であれば、それをEvStACTIVE状態に移行させます。
なお、イベントを再発行する前には必ずUnDeliverEvent()でクリアしてください。

**ユーザ定義イベント
ユーザはマクロDescUEVを使ってイベントを定義できます。

	DeliverEvent(DescUEV|my_event_num, my_event_spec);

この呼びだしによりユーザ定義イベントディスクリプタmy_event_num番について種別
my_event_specのイベントを発行できます。

	long ev;
	ev = OpenEvent(DescUEV|my_event_num, my_event_spec, EvMdNOINTR, NULL);

により、WaitEvent(ev)やtestEvent(ev)が使えます。OpenEvent()関数の第3引数のマク
ロがEvMdINTRであり、かつ第4引数がNULLでない場合は、イベントハンドラが起動され
ます。


*スレッド管理サービス
マルチタスクを実現するための、スレッド管理を行なうサービスです。
スレッド管理サービスでは、明示的な切り替え関数呼び出しをトリガとして、複数のコンテキストを切り替える、マルチスレッド機能を提供しています。この機能は割り込み時のコンテキスト待避にも使用されます。

**コンテキストとTCB
「コンテキスト」とは、レジスタの内容一式のことです。これを格納するデータ構造と
して、「タスク管理ブロック (TCB)」が用意されています。TCB にコンテキストを格納
し、別の TCB 内のコンテキストをレジスタに代入することにより、現行とは別の処理
フローに移ることができます。
また、割り込み発生、あるいは明示的な関数呼び出しをトリガとして、ある時点のコン
テキストが「実行 TCB」に格納されます。実行 TCB は「タスク状態キュー(TCBH)」に
リンクされています。
なお、レジスタについては「レジスタ指定マクロ」の項をご参照ください。

**カーネル起動直後の状態
カーネルが起動すると、TCB の配列が確保され、第０要素が実行 TCB としてタスク状
態キューにリンクされます。このデフォルトスレッドのスレッドディスクリプタの値は
次のようになります。

	DescEV|0x0000 = 0xf1000000

**スレッドのオープンと実行TCBの切り替え
OpenTh() 関数により２番目以降の TCB を確保し、ChangeTh() 関数で実行 TCB とする
ことができます。実行例を次に示します。

unsigned long new_th;
new_th = OpenTh(0x80020000, 0x1ffff0, 0x00);
ChangeTh(new_th);

ChangeTh()関数を呼び出すと、次の操作が行なわれます。


（１）カーネルへのジャンプ
        R3000の持つシステムコール命令によりソフトウェア割り込みを発生。こ
        れによりカーネル中の割り込みディスパッチルーチンにジャンプする。同
        時に割り込みが禁止される。
（２）ChnageTh()コンテキスト退避
        従来の実行TCBにChangeTh()関数を実行したコンテキストが退避されます。
（３）タスク状態キューへのリンク
        タスク状態キューに指定のTCBがリンクされます。
（４）新コンテキストの起動
        割り込みディスパッチルーチンを終了し、実行TCBからコンテキストを読み込
        み実行を再開します。

また、旧実行TCBに退避されたコンテキストのV0レジスタの値を変更することで、実行
再開時のChangeTh()の値を変更できます。これによりスレッド間での情報伝達が可能で
す。

**割り込みと TCB
割り込みハンドラ実行中の実行 TCB には、「割り込まれた時点の」コンテキストが格
納されています。この内容は、ハンドラからメインフローに戻っても失われることは
なく、次の割り込みまで保持されます。

**TCB ステータス
TCB には次の２つの状態があります（マクロで定義されています）。
OpenTh() 関数により TcbStACTIVE 状態となり、ChangeTh() で実行 TCB にすること
ができます。

	表：TCBステータス
       ============================
	マクロ		状態
       ----------------------------
	TcbStUNUSED	未使用
	TcbStACTIVE	実行可能
       ----------------------------

**データ構造
TCBH（タスク状態キュー）と TCB（タスク管理ブロック）のデータ構造は次のようになっています。

(a)TCBH 構造体

	struct	TCBH {			/* タスク状態キュー */
		struct TCB *entry; 	/* 実行 TCB へのポインタ */
		long flag;		/* システム予約 */
	};

(b)TCB 構造体
	struct	TCB {				/* タスク管理ブロック */
		long status;			/* ステータス */
		long mode;			/* モード */
		unsigned long reg[NREGS];	/* レジスタ待避エリア */
						/* レジスタ指定マクロで指定 */
		long system[6];			/* システム予約 */
	};


*レジスタ指定マクロ
TCB にどのレジスタを退避させるかは、レジスタ指定マクロで指定します。
レジスタ指定マクロは、「r3000.h」及び「asm.h」で定義されています。


*IO 管理サービス
ファイルや論理デバイスに対する低水準入出力をサポートするサービスです。
<PlayStation>でのファイルの制御はすべてこのサービスを用いて行ないます。また、
IO 管理サービスで用いるデータ構造、マクロは「sys/file.h」で定義されています。

**デバイス
IO 管理サービスでは、以下のデバイスをサポートしています。

	表：IOデバイス
       ===================================================================
	デバイス名	内容				ファイル指定例
       -------------------------------------------------------------------
	cdrom		CD-ROMファイルシステム		"cdrom:PSX.EXE;1"
	bu		メモリカードファイルシステム	"bu00:ABCE12345"
       -------------------------------------------------------------------

**ブロックサイズ
各デバイスは固有のアクセスデータ単位である「ブロックサイズ」を所有しています。
すべてのデータアクセスはこの倍数で行ないます。指定されたサイズに端数がある場合
は切捨てられます。

**CD-ROMファイルシステム
ゲームの供給場いたいであるCD-ROMドライブにセットされたCD-ROMディスク上のファイ
ルを管理します。<PlayStation>では、ISO-9660のレベル1フォーマットに対応していま
す。
ファイルシステムの詳細は次の通りです。

	表：CD-ROMファイルシステム（ISO-9660レベル1準拠）
       ========================================================================
	デバイス名		cdrom
       ------------------------------------------------------------------------
	ファイル形式		＜ベース名＞.＜拡張子＞.＜バージョン番号＞
				＜ベース名＞は8文字、＜拡張子＞は3文字まで。
				＜ベース名＞と＜拡張子＞の間は"."（ピリオド）。
				＜拡張子＞と＜バージョン番号＞の間は";"。
				使用可能な文字は英大文字、数字、"_"。
	ディレクトリ形式	＜ベース名＞
				＜ベース名＞は8文字まで。拡張子は不可。
				使用可能な文字は英大文字、数字、"_"。
	ディレクトリ階層	最大8。ルート名称なし。
	ファイル配置		ファイルの全セクタを物理的に連続して配置。
	ブロックサイズ		2Kバイト
       ------------------------------------------------------------------------

ただし、ファイルおよびディレクトリについては、そのリストが1セクタ（2048バイト）
に格納される範囲のみをサポートします。これによる<PlayStation>固有の制限の目安
は次のようになります。
注意：ISO-9660におけるファイルとディレクトリの管理データ構造は可変長です。短い
名称が多い場合は以下の数値より多数のディレクトリやファイルを使用できます。

	表：CD-ROMに関する<PlayStation>固有の制限
       ====================================================
	ディレクトリ総数			４５まで
	ディレクトリ当たりのファイル総数	３０まで
       ----------------------------------------------------

**メモリーカードファイルシステム
ゲームデータの保存などに使用する、取り外し可能なメモリーカード上のファイルを管
理します。装着と初期化のテストはlibcardとして供給するBIOSで行なってください。
ファイルシステムの詳細は次の通りです。

	表：メモリーカードファイルシステム
       ===================================================================
	デバイス名		buXY
				X:ポート（0:Aポート、1:Bポート）
				Y:拡張コネクタ番号（1〜）または0
	ファイル形式		＜ベース名＞
				＜ベース名＞は20バイトまでのASCIZ文字列
				拡張子は使用できない。
	ディレクトリ構造	なし
	ブロックサイズ		128バイト
       -------------------------------------------------------------------

**標準入出力ストリーム
ファイルディスクリプタ０番と１番は、それぞれ標準入出力ストリームとして扱われま
す。
ゲーム機では、標準入出力ストリームはNULLデバイスに割り当てられます。また、
DTL-H2000開発環境では、標準入力ストリームはNULLデバイスに、標準出力ストリーム
はデバッガのメッセージウインドウ＃０に割り当てられます。

*モジュール管理サービス
ユーザーアプリケーションの各モジュールをロード・実行する基本的なサービスです。

**実行ファイルのロード・実行
実行ファイル「PS-X EXE」形式に適合していなければなりません。このファイルは、
	(a) 固定アドレス向けにリンクされたコード及びデータ
	(b) 実行開始アドレス
	(c) gp レジスタ初期値
	(d) 初期値なしデータ領域の先頭アドレスとサイズ
を含んでいます。なお、「ロード」とは実行ファイル中のコード、データをリンク時に
確定してアドレスに読む込むことを表わしています。
ロードしたイメージを「実行」するためには、
	(a) スタック領域を明示的に指定する
	(b) 現行スレッドのものをそのまま使用する
かの、いずれかの操作が必要です。

**実行ファイルメモリマップ
実行ファイルは次の３つのセッションに分割されます。

		図：実行ファイルのメモリマップ

	low    -------------------------------------------
		 ヘッダ（XF_HDR構造体で始まる2048バイト）
	       -------------------------------------------   
		テキストセクション				↑2048バイト
	       -------------------------------------------        の倍数
		初期値ありデータセクション                      ↓
	high   -------------------------------------------

**実行ファイル情報のデータ構造

struct EXEC {			/* 実行ファイル情報 */
        unsigned long pc0;	/* 実行開始アドレス */
        unsigned long gp0;	/* gpレジスタ初期値 */
        unsigned long t_addr;	/* テキストセクション＋初期値ありデータセクションの先頭アドレス */
        unsigned long t_size;	/* テキストセクション＋初期値ありデータセクションのサイズ */
        unsigned long d_addr;	/* システム予約 */
        unsigned long d_size;	/* システム予約 */
        unsigned long b_addr;	/* 初期値なしデータセクション先頭アドレス */
        unsigned long b_size;	/* 初期値なしデータセクションサイズ */
        unsigned long s_addr;	/* スタック領域先頭アドレス（ユーザ指定用）*/
        unsigned long s_size;	/* スタック領域サイズ（ユーザ指定用）*/
        unsigned long sp,fp,gp,ret,base;	/* レジスタ退避領域 */
};

	struct XF_HDR {			/* 実行ファイルヘッダ */
		char key[8];		/* キーコード */
		unsigned long test;	/* テキストセクションサイズ */
		unsigned long data;	/* データセクションサイズ */
		struct EXEC exec;	/* 実行ファイル情報 */
		char title[60];		/* ライセンスコード */
	};


*コントローラサービス
<PlayStation>の主要入力デバイスであるコントローラを制御するサービスです。受信
データをアプリケーションが直接処理可能で、各種コトローラを動的に識別できます。
注意：標準コントローラのみを使用する場合は、libetcのサービス関数の使用を推奨し
ます。このサービスが低レベルインタフェースを提供します。

*初期化
buf0とbuf1がそれぞれlen0、len1バイト長のバッファとして確保されているとすると、
コントローラの初期化は次のふたつのステップとなります。

        InitPAD(buf0,len0,buf1,len1);
        StartPAD();

InitPAD()はふたつの受信バッファをカーネルに登録し、StartPAD()は垂直帰線割り込
みをトリガとするコントローラへの自動アクセスが始まり、buf0とbuf1に受信データが
格納されるようになります。
受信バッファの内容を直接テストすることにより、デバイスの有無およびその状態を知
ることができます。

*バッファデータ形式
        受信バッファの格納されるデータの形式は次のようになります。

        表：受信バッファデータ形式
       ============================================================
        バイト          内容
       ------------------------------------------------------------
        0               受信結果  0:成功 0xff:失敗
        1               上位4ビット：端末種別
                            0x1:マウス
                            0x2:16ボタンアナログ
                            0x4:16ボタン
                            0x8:マルチタップ
                        下位4ビット：受信データバイト数／２
        2               0x01:マルチタップ  0x00:以外
 
        ＜16ボタン＞
        3,4             ボタン状態  1:リリース  0:プッシュ

        ＜マウス＞
        3               ボタン状態  1:リリース  0:プッシュ
                                    第2ビット：右  第3ビット：左
        4               移動量  X方向  -128〜127
        5               同上    Y方向  同上
        6               同上    Z方向  同上
        7,8,-           同上    ?方向  同上

        ＜16ボタンアナログ＞
        3,4             ボタン状態  1:リリース  0:プッシュ
        5,6,-           アナログチャネル値
       ------------------------------------------------------------

	表：マルチタップの受信データ構造
       ==================================================================
        バイト  内容
       ------------------------------------------------------------------
        0       受信結果  0x00:成功  0xff：失敗
        1       0x80固定
        2       コネクタ＃１  受信結果  0:成功  0xff：失敗
        3       同上          （端末種別<<4）｜（受信データバイト数／２）
        4-9     同上          受信データ
        10      コネクタ＃２  受信結果  0:成功  0xff：失敗
        11      同上          受信データ
        12-17
        18      コネクタ＃３  受信結果  0:成功  0xff：失敗
        19      同上          （端末種別<<4）｜（受信データバイト数／２）
        20-25   同上          受信データ
        26      コネクタ＃４  受信結果  0:成功  0xff：失敗
        27      同上          （端末種別<<4）｜（受信データバイト数／２）
        28-33   同上          受信データ
       ------------------------------------------------------------------


バッファの第1バイトの上位4ビットは端末種別、下位4ビットは端末からの受信データ
（バッファの第3バイト以降に格納される。）のバイト数の半分の値、となります。
ボタンやチャネルなどの物理的な配置や対応は各端末のドキュメントを参照してくださ
い。

*既存端末の型
標準コントローラは16ボタン型端末です。
弊社から商品化されているマウスは、XとYの２方向だけをサポートするマウス型端末。
また株式会社ナムコ様の「ネジコン」は、4チャネル、つまりバッファ第1バイトの下位
4ビットが3（（ボタン分2バイト＋4チャネル分4バイト）÷２ ）、の16ボタンアナログ
型端末です。


*漢字フォントサービス
<PlayStation>のカーネルROMには16ドット×16ドットの２値ビットマップ漢字フォント
が記録されています。メモリ容量の都合からフォントデータは必ずしもメモリ上の連
続して格納されていません。このため文字毎にサービス関数によりデータ先頭アドレ
スを取得して使用します。

**フォント
(1) データ形式  16ドット×16ドット  ２値ビットマップ
                文字サイズは15ドット×15ドット
(2) 内容        JIS第一水準漢字および非漢字、ゴシック体
                非漢字にはトップスペース（0x2121）を含みます。
(3) コード体系  シフトJIS。
(4) アクセス    サービス関数にシフトJISコードを与えることにより、ROM
                上の特定の１文字のフォントパタンの先頭アドレスが取得
                できます。その後は直接フォントパタンにアクセスします。

**データ形式
下図のように、パタンの左上端のバイトが先頭。同じく右上端のバイトがそれに続きま
す。ビットはMSBが向かって左です。

                      --------------------------
                      |  ＃０     |     ＃１   |
                      |  ＃２     |     ＃３   |
                      |  ・・・   |    ・・・  |
                      |  ・・・   |    ・・・  |
                      |  ・・・   |    ・・・  |
                      |  ＃３０   |     ＃３１ |
                      --------------------------

**使用例
次のサンプルプログラムでは、関数_get_font()が指定されたシフトJISコードに対応
するフォントパタンをVRAMに転送して16ビットテクスチャとして使用できる形式に展
開したものを返しています。


unsigned long
_get( sjis )
unsigned char *sjis;
{
        unsigned short sjiscode;

        sjiscode = *sjis << 8 | *(sjis+1);
        return Krom2RawAdd(sjiscode);  /* 漢字フォントパタンアドレスの取得 */
}

#define COLOR 0x4210
#define BLACK 0x3000

_get_font( s, data )
char *s;
unsigned short *data;
{
        unsigned short *p, *d, w;
        long i,j;

        if((p=(unsigned short *)_get(s))!=-1) {
                d = data;
                for(i=0;i<15;i++) {
                       for(j=7;j>=0;j--)
                                *d++ = (((*p>>j)&0x01)==0x01)?COLOR:BLACK;
                       for(j=15;j>=8;j--)
                                *d++ = (((*p>>j)&0x01)==0x01)?COLOR:BLACK;
                        p++;

                               }
                else {
                        for(d=data,i=0;i<2*16*16;i++)
                                *d++ = BLACK;
                }
        }
}


*その他のサービス
キャッシュ、割り込みなど R3000 に関する設定、処理を行なうサービスです。

									以上


