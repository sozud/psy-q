$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
メモリカードライブラリ

*概要
メモリカードライブラリは、リアルタイム環境下でメモリカードへのスムーズなアクセ
スを可能とするサービスを提供します。

**ライブラリファイル
メモリカードライブラリのファイル名は「libcard.lib」です。
各サービスを呼び出すプログラムは、必ずこれをリンクする必要があります。

**インクルードヘッダ
メモリカードライブラリには独自のインクルードヘッダはありません。ただし、カーネ
ルライブラリのヘッダ「kernel.h」と標準インクルードヘッダのひとつsys\file.hが必
要です。

       =============================
	内容		ファイル名
       -----------------------------
	ライブラリ	libcard.lib
	ヘッダ		kernel.h
			sys\file.h
       -----------------------------

*メモリカード
メモリカードは、リセットや電源オフ後もデータを保持する通電中でも抜き差しが可能
な記憶デバイスです。

**ハードウェア
次にメモリカードのハードウェア諸元を示します。

       ======================================================================
        容量            フォーマット時120Kバイト
                        （128バイトのセクタ単位でアクセス）

	通信形態	コントローラポートを兼用した同期型シリアル通信。

        アクセス速度    (1) １セクタ書き込み後、20m秒間アクセス不可
                        (2) 最大連続読みとり速度は約10Kバイト／秒

        その他          電源を落さずに抜き差し可能
                        １０万回書き込み保障
       ----------------------------------------------------------------------

**イベント
メモリカードライブラリは次のふたつの原因ディスクリプタを使用します。
なお、メモリカードライブラリが内部でイベントディスクリプタを消費することはあり
ません。

       ===================================================================
	原因ディスクリプタ	イベント種別	意味
       -------------------------------------------------------------------
	HwCARD			EvSpIOE		処理完了
				EvSpERROR	カード不良
				EvSpTIMOUT	カード無し

	SwCARD			EvSpIOE		処理完了
				EvSpERROR	カード不良
				EvSpTIMOUT	カード無し
				EvSpNEW		新規カードまたは未初期化
       -------------------------------------------------------------------

注意：SwCARD/EvSpNEWは入出力要求を発行した関数により２通りの意味を持ちます。


***HwCARD関連イベントの自動的クリア
この原因ディスクリプタに関するイベントは垂直帰線割り込み毎に自動的にクリアされ
ます。よってlibgpuのVSync()など垂直帰線割り込みを待つ関数をはさんでイベント発
生のテストを行なうと、イベント発生を検出できない状態に陥ります。


**BIOS
メモリカード接続確認、論理フォーマットテスト、セクタ（128バイト）単位でのアク
セスなどのサービスがBIOSとして用意されています。
コントローラ読み込みおよびAB２つのコネクタへのアクセスを共存させるため、
BIOSは２垂直帰線毎にカードにアクセスします。１回のアクセスで行なえるデータの読
み書きは１セクタ、128バイトです。
BIOSを使ったアクセスは次のようなものとなります。

       ======================================================================
        起動タイミング  垂直帰線割り込み後、コントローラ読みとりに続いて
			カード接続確認とハンドシェークを行なう。
			データ本体送受信はバイト単位の受信割り込みにより駆動。

        実効速度  	３０セクタ／秒 ＝ 3.75Kバイト／秒

        CPU負荷         ２枚のカードから連続read時2.5％
                        ２枚のカードに連続write時3.2％
       ----------------------------------------------------------------------

**カードの存在と論理フォーマットのテスト
BIOSによるカードの存在と論理フォーマットテストの手順は次のようなります。
(1) _card_info()でカードの存在をテストする。
    ＜結果判定＞
    IOEイベントが発生した場合は、すでに接続を認識したカードが継続して接続され
    ている。(5)へ進む。
    NEWCARDイベントが発生した場合は、接続後、_card_clear()による認識操
    作を行なっていないカードが接続されてる。(2)へ進む。
    TIMOUTイベントが発生した場合、カードは接続されていない。これ以上の操作は不
    要。通信エラーに備えてリトライを行なうこと。

(2)_card_clear()による認識操作を行なう。
    ＜結果判定＞
   通常は失敗しない。失敗した場合はカードが抜きとられたか通信エラーが発生した。
   通信エラーに備えて(1)に戻ってリトライを行なうこと。

(3)_card_load()による論理フォーマットテストを行なう。
    ＜結果判定＞
   IOEイベントが発生した場合は、フォーマット済み。(5)へ進む。
   NEWCARD   イベントが発生した場合は、未フォーマット。(4)へ進む。
   以外はカードが抜きとられたか通信エラーが発生した。通信エラーに備えて(1)に
   戻ってリトライを行なうこと。

(4)format()で論理フォーマットを行なう。
    ＜結果判定＞
   正常終了なら(5)へ進む。以外はカードが抜きとられたか通信エラーが発生した。通
   信エラーに備えて(1)に戻ってリトライを行なうこと。

(5)ファイルシステムによる入出力を行なう。

**未確認フラグ
カード内部には「未確認フラグ」とよばれるビットスイッチが用意されています。この
ビットはカードが差込口に差し込まれるとセットされ、_card_clear()またはデータ書
き込みによりクリアされます。このフラグはカードの指し代わり検出の手がかりとなり
ます。誤ったアクセスを防ぐため、デフォルトではこのフラグがセットされたカードに
に対するデータの読み書きは出来ません。エラーとなります。_card_clear()による明
示的なクリアの後、アクセスしてください。
テストのためエラー状態を作り出したい場合など、未確認フラグを無視してアクセスす
るためには、_new_card()関数でデフォルトのテスト条件をマスクします。これはファ
イル単位での正常なアクセスでは不要な関数ですので、敢えて関数名を他のものと買え
てあります。



**カードのテスト
以下にカードのテストを行なうサンプルコードを掲載します。
使用しているイベントについては後続の「ファイルシステム」を参照してください。

unsigned long ev0,ev1,ev2,ev3;
unsigned long ev10,ev11,ev12,ev13;

main()
{

        ev0 = OpenEvent(SwCARD, EvSpIOE, EvMdNOINTR, NULL);
        ev1 = OpenEvent(SwCARD, EvSpERROR, EvMdNOINTR, NULL);
        ev2 = OpenEvent(SwCARD, EvSpTIMOUT, EvMdNOINTR, NULL);
        ev3 = OpenEvent(SwCARD, EvSpNEW, EvMdNOINTR, NULL);
        ev10 = OpenEvent(HwCARD, EvSpIOE, EvMdNOINTR, NULL);
        ev11 = OpenEvent(HwCARD, EvSpERROR, EvMdNOINTR, NULL);
        ev12 = OpenEvent(HwCARD, EvSpTIMOUT, EvMdNOINTR, NULL);
        ev13 = OpenEvent(HwCARD, EvSpNEW, EvMdNOINTR, NULL);

        PadInit(0);
        InitCARD(1);
        StartCARD();
        _bu_init();

	test_card();
}


test_card()
{
	long ret;

	_card_info(0x00);		/* deliver a TEST CARD request */
	ret = _card_event();    	/* get the result */
	if(ret==1 || ret==2))		/* NO CARD or Communication error */
		goto skip;
	if(ret==3) {			/* if NEWCARD, call _card_clear() */
               	_clear_event_x();
               	_card_clear(0x00);	/* clear NEW CARD FLAG */
               	ret = _card_event_x();	/* wait events */
        }
        _clear_event();
        _card_load(0x00);		/* deliver a TEST FORMAT request */

        if(ret==3) {		/* if NEWCARD, call format() */
		/* put a message to the operator */
	       ret = format("bu00:");	/* syncronous function */
               if(ret==1)
        	       FntPrint("\nDONE\n");
               else {			/* error happened in format() */
                       FntPrint("\nERROR IN FOORMATTING\n");
                       goto skip;
               }
	}
	/* put i/o requests */
	return 1;
skip:
	return 0;
}

_card_event()
{
        while(1) {
                if(TestEvent(ev0)==1) {         /* IOE */
                        return 0;
                }
                if(TestEvent(ev1)==1) {         /* ERROR */
                        return 1;
                }
                if(TestEvent(ev2)==1) {         /* TIMEOUT */
                        return 2;
                }
                if(TestEvent(ev3)==1) {         /* NEW CARD */
                        return 3;
                }
        }
}


_clear_event()
{
        TestEvent(ev0);
        TestEvent(ev1);
        TestEvent(ev2);
        TestEvent(ev3);
}


_card_event_x()
{
        while(1) {
                if(TestEvent(ev10)==1) {         /* IOE */
                        return 0;
                }
                if(TestEvent(ev11)==1) {         /* ERROR */
                        return 1;
                }
                if(TestEvent(ev12)==1) {         /* TIMEOUT */
                        return 2;

                if(TestEvent(ev13)==1) {         /* NEW CARD */
                        return 3;
                }
        }
}


_clear_event_x()
{
        TestEvent(ev10);
        TestEvent(ev11);
        TestEvent(ev12);
        TestEvent(ev13);
}



*ファイルシステム

       ======================================================================
        デバイス名              buX0    X:コネクタ番号（０または１）
        ファイル名              21文字までのASCIZ文字
        ディレクトリ構造        なし
        管理単位：スロット      8Kバイト（64セクタ）→ファイルサイズの単位
        スロット数              15個／カード（最大ファイル数は15）
        自動代替セクタ機能	20代替セクタ／カード
       ----------------------------------------------------------------------

ファイル名を引数として要求するカーネルライブラリサービスはすべてbuデバイスに適
用することができます。
ファイルサイズはcreate時にパラメータとして指定します。それ以後の変更はできませ
ん。またサイズは「スロット」単位です。create時ファイルシステムは、ファイル削除
に伴い分散化したメモリ領域があれば、それらをつなぎ合わせて必要容量を確保しま
す。

        [例]ファイルの削除と生成

	  /* ドライバの初期化*/
        InitCARD(0);    /* コントローラとの共存なし */
        StartCARD();
        _bu_init();


        /* ポートA上のカードのファイルL01を削除 */
        pritf("delete\n");
        delete("bu00:L01");


        /* 2スロット長のファイルL01をポートA上のカードに新規作成 */
        printf("create\n");
        if((fd=open("bu00:L01",O_CREAT|(2<<16)))==-1)
                printf("error\n");
        close(fd);
        /* 生成後は必ず１度クローズしてください */


*リアルタイムアクセス
リアルタイム環境下での運用を想定し、デバイスbuはノンブロッキングモードをサポー
トします。オープン時にマクロsys\file.h中のO_NOWAITを使用すると、read()と
write()は入出力要求をドライバに登録すると直ちに終了します。入出力の完了はイベ
ントにより通知されます。
ただし、アクセス速度確保のため、各差込口はひとつの入出力要求だけを受け付けま
す。

[例]非同期アクセス
    _clear-event()と_card_event()は前出の例と同内容。

    sample()
    {
	long fd,i,ret;

        fd = open("bu00:L01",O_WRONLY|O_NOWAIT);
        printf("open=%d\n",fd);
        for(i=0;i<50;i++) {
                _clear_event();
                while((ret = write(fd,data,384))!=0)  
                        ;
                printf("write=%d\n",ret);
                ret = _card_event();
                printf("event=%d\n",ret);
                if(ret==1)
                break;
        }
        close(fd);
    }


*メモリーカード運用ルール
メモリカードは複数のアプリケーションにより共有される資源です。よって共通のルー
ルに従った運用をお願いします。

**異常処理
アプリケーション実行中に容量不足や未フォーマットカードの検出などが発生した場合
の処理については、標準の画面やメッセージ（例えばOSDと同じ表示が必須、というよ
うな）は定めません。個々のアプリケーションに応じた設計をお願いします。
ただし、次の点に留意ください。

(1) 論理初期化を行なう場合は必ずオペレータに問い合わせて下さい。
    よって自動初期化機能は使わないでください。
(2) カードが検出できず、かつ将来何んらかの操作制限が生ずることが判明した場合は
    必ずオペレータに通知してください。できれば問い合わせをお願いします。

**用語体系
商品カタログでの必要メモリ容量の単位は「ブロック」となります。これは前出の「ス
ロット」（８Ｋバイト）に相当します。

**ファイル名
ファイル名は次のような構成としてください。

               =========================================================
                バイト          内容            備考         
               ---------------------------------------------------------
                 0              マジック	常に'B'      
                 1              地域            国内は'I' 北米は'A' 
						欧州は'E'（＊１）    
                 2-11           タイトル        SCE品番(＊２)
                 12-20          ユーザ公開      0x00以外のASCIIのみ使用
						0x00で終了
               ---------------------------------------------------------
		＊１：いずれもシステムによるチェックなし
		＊２：複数discタイトルは先頭discのもの

	SCE品番は弊社発売決定予備会議（マスタ出稿の約３週間前）にて決定
	し、各社営業ご担当へ通知します。それを元に次のように決定してください。

		例：商品コードが「SLPS-00001」の場合、
		    ファイル名の先頭１２文字は「BISLPS-00001」となる

		＊数字部は必ず０詰めで５桁に拡張してください。

**ファイルヘッダ
各ファイルの先頭には次のヘッダを必ず配置してください。

              ==============================================================
		項目			サイズ（バイト）
              --------------------------------------------------------------
		ヘッダー                128 
                	Magic           	2（常に'SC'）
                	Type              	1
                	スロット数            	1
        	      	文書名            	64（シフトJIS、＊１）
	              	pad             	28
                	CLUT             	32
              ..............................................................
        	アイコンイメージ (1)    128 (16 x 16 x 4 bits)
        	アイコンイメージ (2)    128（Type==0x12,0x13のみ）
        	アイコンイメージ (3)	128（Type==0x13のみ）
              ..............................................................
        	データ                  任意 (128B x N)
              --------------------------------------------------------------
		＊１：非漢字および第一水準漢字のみ、全角３２文字。

              ===============================
		Type    アイコンイメージ数
			（自動差し替えアニメ）
	      -------------------------------
        	0x11    1
        	0x12    2
        	0x13    3
	      -------------------------------


**書き込みデータの内容保障

        データ書き込み中のリセットやカード抜きとり・電源オフによるデータ破壊
        への対策はアプリケーション側で実施してください。

        例：    書き込みデータを２重化。書き込みは交互に行なう。
                また、各セクタの最終バイトは自身のチェックサムを付加する。
                読みとり時にチェックサムテストを行ない、エラー検出時はもうひと
                つのデータセットを使用する。

        注意：ファイルシステムの代替セクタ機能はカード内メモリの書き込みエラー
	      にのみ有効です。書き込み内容保証機能はハードウェア、ライブラリと
	      もにサポートしません。


[例]セクタチェックサム

/*
 * test check sum for 128byte block
 * return       1:OK
 *              0:NG
*/
_test_csum(buf)
unsigned char *buf;
{
        long i;
        unsigned char c;

        c = 0x00;
        for(i=0;i<127;i++)

                c ^= *buf++;
        if(*buf==c)
                return 1;
        return 0;
}


/* set check sum to the last byte of 128byte block */
_set_csum(buf)
unsigned char *buf;
{
        long i;
        unsigned char c;

        c = 0x00;
        for(i=0;i<127;i++)
                c ^= *buf++;
        *buf = c;
}


/* sample data strucure */
struct SDB {
        char name[8];
        long size,attr,sector,mode;
}


/* common load buffer */
unsigned char load_buf[1024];


/* get data from memory card with check-sum test */
get(num,data)
long num;
struct SDB *data;
{
        long i,fd;

        if((fd=open("bu00:L01",O_WRONLY))<0)
                return 0;
        memcpy(&load_buf[0],data,sizeof(struct SDB));
        _set_csum(&load_buf[0]);
        i = write(fd,&load_buf[0],128);
        close(fd);

        close(fd);
        return (i==128)?1:0;
}


/* get data from memory card with check-sum test */
get()
{
        long i,fd;

        if((fd=open("bu00:L01",O_RDONLY))<0)
                return 0;
        if(read(fd,&load_buf[0],1024)!=1024) {
                close(fd);
                return 0;
        }

        for(i=0;i<8;i++)
                if(_test_csum(&load_buf[128*i])==1)
                        memcpy(&data[i],&load_buf[128*i],sizeof(struct SDB));
                else
                        memset(&data[i],0xff,sizeof(struct SDB));
        close(fd);
        return 1;
}


**通信エラー対応

	静電放電や電源ノイズによりカード接続やアクセスプログラムが正常であるに
	もかかわらずアクセスが失敗する場合があります。カードの有無のテストや書
	き込み、読みとりについてはリトライ（１〜２秒間）実施をお願いします。




*その他

**コーディング上の注意点

	・_card_info()の前に_new_card()をコールしてEvSpNEWイベントを抑制しない
	  でください。

**既知のバグ

	・open()によりファイルを生成した場合は直ちにclose()をコールしてファイ
	  ルをクローズしてください。そのままread()やwrite()を発行するとエラー
	  となります。

	・read()とwrite()による非同期アクセスではファイルポインタが128バイト少
	  なく更新されます。lseek()による修正が必要です。

	・メモリカードＡ（向かって左）についてタイムアウトイベントが発生した
	  フレーム中ではコントローラＡ（向かって左）へのアクセスが失敗し、
	  全ボタンが「リリース」状態となる。


	  ＜差し込み口Ａにカードがセットされていない場合に問題が発生＞

		垂直同期 --------------------------------------------------
				_card_info(0x00)など非同期アクセス要求
				pad = PadRead();    /* 正常 */

		垂直同期 --------------------------------------------------
				カードＡへ通信開始
				pad = PadRead();    /* 正常 */

		垂直同期 --------------------------------------------------
				カードＡタイムアウトイベント発生
				pad = PadRead();    /* コンローラＡ */
						    /* 全ボタンリリース */

		垂直同期 --------------------------------------------------
				pad = PadRead();    /* 正常 */

		垂直同期 --------------------------------------------------


	★対策
	  カードＡへの非同期アクセスを行なう場合は、コントローラがオペレータ
	  の意図に反して全ボタンリリースとなっても問題が発生しないよう設計変更
	  していただく、もしくはカードＢ（向かって右）を使用するようお願いしま
	  す。

								以上





























