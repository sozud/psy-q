$PSDocId: Document Version 1.0 for Runtime Library Version 3.3$
*グラフィクス基本ライブラリ (libgs)


概要

	LIBGSは 拡張グラフィックライブラリと呼ばれ LIBGPU LIBGTE上に構築
	された 3Dグラフィックス(ポリゴン等)と2Dグラフィックス
	(スプライト/BG等)を統合的に扱うことのできるグラフィックライブ
	ラリです。

	LIBGSで扱うモデルフォーマットは TMDフォーマットと呼ばれるもので
	複数オブジェクト、スケール情報、テクスチャアドレス情報などが
	LIBGSでデコードするための最適な状態で格納されています。

	LIBGSで扱う画像データフォーマットは TIMフォーマットと呼ばれるもので
	画像の解像度、色数、カラールックアップテーブル情報などがピクセル
	データと共に格納されています。

	TMDフォーマット 及び TIMフォーマットは プレイステーション・オーサ
	リングツールの標準フォーマットであるため オーサリングツールで
	作られた データは そのまま LIBGSで利用することができます。


	LIBGPU/LIBGTEがポリゴンレベルのデータを処理するライブラリであるのに
	対し LIBGSは オブジェクトという複数のポリゴンをまとめた単位でデータ
	を処理するため 非常に簡単に ３次元のプログラムをプロトタイピング
	できます。そして オブジェクトに付加された豊富なアトリビュートを
	用いて いろいろな特殊効果を簡単に作り出すことができます。

	ただしLIBGSは 扱う入力フォーマットを限定しているため LIBGPU／LIBGTE
	で最適化されたプログラムに比べるとオーバヘッドはあります。そのため
	実際のゲーム製作では、一部分、あるいは全てを LIBGPU／LIBGTEのレベルで
	コーディングする必要があるかも知れません。LIBGSはオープンな
	アーキテクチャを採用し モジュールで 拡張できるため これからも
	常に バージョンアップし より 高機能で高速化を追求し進化するライブラリ
	です。


LIBGSの機能
	○ 階層座標系のサポート
	○ 光源計算（３光源 デプスキューイング アンビエント）
	○ オブジェクトの自動分割 半透明処理
	○ 視点制御
	○ Zソート処理 	OTの初期化 階層化 圧縮
	○ フレームダブルバッファ
	○ アスペクト比の自動調整
	○ ２Dクリッピング オフセット処理
	○ スプライト ／ BG ／ ライン
	○ libgpu,libgteとの共存


★座標系

	LIBGSの 座標は GsCOORDINATE２ と呼ばれています。

	座標系は ワールド座標系を最上位とする 階層があり 下の階層から
	上の階層へと ワールド座標系に到達するまで 積算されます。

	GsCOORDINATE2は 座標系を記述するためのパラメータと 座標計算を
	高速化するためのワークエリアからなります。
	座標系は MATRIX型のパラメータにより記述されます。MATRIXパラメータは
	その座標系の親の座標系からその座標系への変換パラメータとなります。

	座標系の空間の大きさは XYZともに 符合つき３２ビットです。

座標系の初期化
	座標系の初期化には GsInitCoordinate2()を使います。
	GsInitCoordinate2()は GsCOORDINATE2の各パラメータを初期化する
	だけなので プログラマが GsInitCoordinate2()を使わずに初期化しても
	構いません。パラメータは書き換えられた瞬間から 有効になり計算に
	使われます。

回転／平行移動の順番
	座標系に設定されるパラメータの回転と平行移動の順番は
		回転 → 平行移動 になります。
	また RotMatrix()を使って回転マトリックスを生成しそれを GsCOORDINATE2
	に設定した時は 回転順は Z→Y→X の順になります。


フラグのクリア
	階層座標系から ローカルワールドマトリックスを求めるに際して
	高速化を行なっています。計算済みの座標系には 構造体GsCOORDINATE2
	のメンバのflagに１を設定し結果をworkmに格納しています。そのため
	GsCOORDINATE2のパラメータを書き換えた時はflagを０にクリアしないと
	再計算が行なわれず workmの内容が使われてしまうので 必ずクリアする
	必要があります。

	ただし 親座標の変更は その親座標にリンクしている子座標には 自動的
	に伝搬されるため 子座標のフラグまでクリアする必要は ありません。


座標系設定のサンプル

	<平行移動>
	GsCOORDINATE2  sample_coord;	/* 平行移動を設定する座標系 */
	int x,y,z;			/* 平行移動量 */

	sample_coord.coord.t[0] = x;
	sample_coord.coord.t[1] = y;
	sample_coord.coord.t[2] = z;


	<回転>
	GsCOORDINATE2  sample_coord;	/* 回転を設定する座標系 */
	SVECTOR	       rot;	        /* 設定する回転角 (x,y,z) */
	MATRIX	       tmp1;		/* 求める回転マトリックス */

	RotMatrix(&rot,&tmp1);		/* 回転ベクトルから回転マトリックスに
					   変換する RotMatrix()を使うと
					   回転順は zyxとなる */
	sample_coord.coord = tmp1;



★オブジェクト

	LIBGSでは ３Dオブジェクトハンドラとして GsDOBJ2 GsDOBJ3 GsDOBJ5の
	３種類のタイプを用意しています。それぞれのオブジェクトハンドラの
	差異は 後ほど説明するとして ここでは 基本的なオブジェクトタイプである
	GsDOBJ2を取り上げて説明します。

	プログラマはこのハンドラを利用して オブジェクトを操ることができます。

	オブジェクトを操作するためには GsDOBJ2のメンバの coord2および
	attributeを使います。coord2は 座標系（GsCOORDINATE2へのポインタであり
	オブジェクトの位置を制御する時に ポイントされる座標系のパラメータを
	設定します。attributeは オブジェクトの属性をあたえます。属性には
	表示／非表示などの一般的なものから光源計算の方法の切替えなどの
	特殊効果に至るものまで 様々です。


オブジェクトの初期化

	GsDOBJ２でオブジェクトをハンドルするためには 読み込まれたTMDデータ
	とハンドラとをリンクする必要があります。
	TMDデータとのリンクは GsLinkObject4()を用います。GsLinkObject4()は
	TMDデータの何番目のオブジェクトとGsDOBJ２とをリンクするのかを設定し
	ます。


オブジェクトの位置の制御

	オブジェクトの位置を制御するには 構造体GsDOBJ２のメンバのなかの
	coord2でポイントされる座標系GsCOORDINATE2のパラメータを設定します。
	GsCOORDINATE2のsupterがWORLDの時はその座標系はワールド座標系と
	等価なため 設定された位置パラメータはワールド座標系の位置になり
	回転パラメータはワールド座標系の原点を中心とする回転となります。


オブジェクトの動きの階層構造

	オブジェクトの動きに階層構造を定義したい場合は、GsDOBJ２のメンバの
	coord2がポイントする座標系の階層を定義することで可能です。例えば
	object1がcoordinate1をポイントし object2がcoordinate2をポイントし
	ている時、object1をobject2の親にするためには coordinate2のsuperに
	coordinate1を設定します。


			GsDOBJ2	   COORDINATE2

			object1 → coordinate1
					↑
					｜
			object2 → coordinate2


	このように定義すれば、object2の動きはobject1に連動します。
	object1の動きはobject2に連動しません。objcet1,object2を動
	かす時はcoordinate1に位置を設定します。object2だけを動かす
	時はcoordinate2に設定します。



オブジェクトのアトリビュートの制御

	GsDOBJ2には attributeのフィールドがあり そのビットを操作することで
	様々な効果をオブジェクトに与えることができます。

	material減衰
		光源計算を行なう際に、方線の傾きと輝度の減衰の関係を
		設定します。０〜３迄の値をとり ３がもっとも減衰がきつく
		なります。このパラメータによってオブジェクトの材質感
		を変えることができます。

		減衰の値を大きくすると計算時間はそれだけかかります。

		光源計算で material lightingを有効にしないとこのパラメータは
		無視されます。

		ただし 現在のバージョンではまだ サポートされていません。

	lighting mode
		光源計算の方式を決定します。デフォルトの方式はGsSetLightMode()
		によって設定されます。このアトリビュートはオブジェクト毎に
		光源計算の方式を制御したい時に設定します。

	光源計算OFF
		光源計算を強制的にキャンセルするためのビットです。光源計算の
		有りのTMDもこのビットをたてると 光源計算をキャンセルでき
		高速になります。

	NearZ CLIP
		ポリゴンの端点が非常に接近した場合、（Z<h/2 ただし hは
		プロジェクション）透視変換時に オーバフローを起こした
		ポリゴンを単純にクリップせず、形をゆがめてでも強引に
		表示したい場合に設定します。

		ただし 現在のバージョンではまだ サポートされていません。

	back clip
		ポリゴンは頂点の順番によって表裏があります。凸物体の場合は
		裏を表示する必要がないため、デフォルトでは裏向きポリゴンは
		クリップされますが、このアトリビュートによって裏向きポリゴン
		も表示させることができます。

		ただし 現在のバージョンではまだ サポートされていません。

	半透明レート
		半透明には通常の半透明に加えてあと３種類のモードがあります。
		１００％ 加算、減算 ２５％加算 です。それらのモードを
		制御します。

		   ┌────┬────────────┐
		   │   値   │ 	内容	       │
	       	   ├────┼────────────┤
		   │   ０   │ 通常の半透明	       │
		   │   １   │ B+F    １００％加算    │
		   │   ２   │ B+F/2  ５０％加算      │
		   │   ３   │ B-F    １００％減算    │
		   └────┴────────────┘

		テクスチャマッピングされたポリゴンを半透明にするには
		テクスチャの色のフィールド（ダイレクトの時はテクスチャ
		パターン、indexedの時はCLUTのフィールド）の最上位ビット
		（STPビット）をたてる必要があります。

		STPビットを利用して ピクセル単位の半透明の処理が可能です。

	表示制御
		その物体を表示するか、表示しないかを制御します。表示しない
		場合は、計算対象からも外され負荷は軽くなります。

	自動分割
		実行時にオブジェクト単位で そのオブジェクトに含まれる
		全てのポリゴンを分割する機能です。
		分割数は2x2 4x4 8x8 16x16 32x32 64x64のうちから選べます。

		この機能を使うことで １次変換にともなうテクスチャの歪みの問題
		および nearZ clippingの問題を解消することができます。
		ただし 分割数を多くしすぎると 速度 および メモリ使用量が
		増大しますので 注意が必要です。

		自動分割機能を備えた パケット作成関数は GsSortObject4()及び
		GsSortObject5()です。自動分割機能を 使う場合は パケット作成
		関数の最後の引数に ワークとして使用するスクラッチパッド
		（データキャッシュ）のアドレスを渡す必要があります。


★視点

	３D グラフィックスでは 画面に映し出される 画像は 視点の前に設定
	されたスクリーンへの投影となります。そのため 画面に画像を映し出
	すには視点 及び スクリーンを設定する必要があります。



視点の設定

	視点の設定は GsRVIEW2 もしくは GsVIEW2の構造体に 値を代入して
	GsSetRefView2(),GsSetView2()で設定します。

	GsRVIEW2とGsVIEW2の違いは、視点の設定方法にあります。GsRVIEW2は
	視点と参照点の座標を設定することで、視点を設定します。

	GsVIEW2は視点座標系への変換マトリックスを直接設定することで視点を
	設定します。

	GsVIEW2,GsRVIEW2ともに構造体のsuperに設定する座標系を書くことができ
	ます。ワールド座標に設定すれば通常の客観視カメラになり それぞれの物体の
	ローカル座標系に設定すれば その物体の主観視カメラになります。


スクリーンの設定

	視点の前方には スクリーンが 設定されます。視点とスクリーンとの距離を
	プロジェクション（h）と言い、GsSetProjection()で設定します。

			    /|
			   / |
			  /  |
			 /   |       ＼
		        / <--/-------◯>視点
			|   /	h    ／
			|  /プロジェクション
			| /
			|/
		    スクリーン


	スクリーンの縦、横は画面の解像度になります。例えば６４０x４８０の
	解像度であれば、スクリーンの横は６４０、縦は４８０になります。

	画面の解像度が、正方ドットでない場合（つまり画面の解像度の横縦の
	比が４対３でない場合）縦が調整されます。例えば ６４０x２４０ドット
	の場合は、物体の縦が１／２に縮小されて表示され見かけ上は正方ドット
	のアスペクト比と同じになります。

	GsInit3D()をコールすると、スクリーンの中央がスクリーン座標の原点
	となります。LIBGSの３D部分を使う場合 必ずGsInit3D()を一度呼ぶ
	必要があります。

	プロジェクションは、画角を調整します。プロジェクションが大きければ
	画角が狭まり 平行投影に近くなります。プロジェクションが小さければ
	画角が広がり より遠近感の強調された絵になります。


			h               ＜		h

		｜			｜
		｜  			｜
		｜    ＼		｜		＼
		｜    ◯>視点		｜		◯>視点
		｜    ／		｜		／
		｜ 			｜
		｜			｜
	     スクリーン	     	    スクリーン

		画角広い		画角狭い



★光源

	LIBGSでは平行光源を３つまで同時にあてることができます。平行光源
	とは、光源とポリゴンの角度のみで明るさが決まる光源のことです。
	光源は光源の向きと 色とで設定します。


光源の設定

	光源は、GsF_LIGHT構造体のパラメータを設定してGsSetFlatLight()で
	LIBGSに設定します。平行光源は３つまで設定可能なため GsSetFlatLight()
	の引数のIDは 0〜２までを指定します。


アンビエント

	アンビエントとは周囲光のことです。光があたっていなくても周囲光により
	ものの形は見ることができます。アンビエントはこのような現象を実現
	するために用意されています。

	アンビエントの設定は 以下のように設定します。
	光のあたっているところを１とした時に 光のあたっていない部分を
	0.5とすると アンビエントはGsSetAmbient（ONE/2,ONE/2,ONE/2)に
	設定します。ここで ONE とは固定小数点で１のことです。
	パラメータが３つあるのは RGB独立にアンビエントを指定できるからです。
	一般にアンビエントを上げると暖かいイメージになり、下げるとつめたい
	イメージになります。


デプスキューイング

	視点からの距離（Z）に応じて 物体の明るさを変化させると 遠くのものを
	霞ませることができます。これを実現するのがデプスキューイングです。
	LIBGSでは テクスチャつきでないすべてのポリゴンに対して
	デプスキューイングを行なうことができます。

	デプスキューイングを行なうには、GsSetLightMode(1)もしくは
	GsSetLightMode(3)をコールしてデプスキューイングの光源計算を
	指示します。

	そして、GsFOGPARMのrfc,gfc,bfcに バックカラーを設定しGsSetFogParam()で
	LIBGSに設定します。バックカラーが 白っぽくするとFOG効果となります。

	テクスチャマップされたポリゴンに対してはバックカラーが黒の時のみ
	この方法でデプスキューイングが可能です。これはダンジョンなど遠くを
	暗くして見えなくする時などに有効です。
	テクスチャマップされたポリゴンを どんな場合でもデプスキューイング
	させるには CLUTを奥行きによって切り替えることで実現できます。
	この方法は LIBGSではサポートしていないので プログラマが１から
	コーディングする必要があります。


マテリアルライティング

	ポリゴンと光源の角度で光の強さが決定されると 説明しましたが、
	その光の減衰カーブを より急峻にすることで物質の質感を金属質に
	変えることができます。これをマテリアルライティングと呼びます。

	マテリアルライティングを行なうには GsSetLightMode(2) or
	GsSetLightMode(3)をコールしてマテリアルライティングを指示します。

	減衰の制御はオブジェクト毎にアトリビュートで行ないます。
	attributeのmaterial減衰のところで ０から３の値を設定します。
	設定した値が大きい程減衰がきつくなり 金属的な質感が増します。

	ただし 現在のバージョンでは まだ対応しておりません。


★描画の優先順位（オーダリングテーブル）

	プレイステーションでは、陰面消去を ポリゴン描き順（Zソート）によって
	実現しています。そして高速なZソートを実現するためにオーダリングテーブル
	（以下OTと略す）という概念を導入しています。

	オーダリングテーブルとは メモリ上にとられたZの「物差し」の様なもので
	「物差しの」それぞれの目盛が いくつでもポリゴンを持つことができます。

	ソーティングは ポリゴンのZ値に応じて そのZ値と等しい”目盛”へ
	ポリゴンを”置いて”いくことで行ないます。ポリゴンを最後まで”置いて”
	いくと 物差しは すべてのポリゴンがZ値に応じてぶら下がっていることに
	なります。これを ”目盛”の順にレンダリングチップに転送し描画していく
	ことで陰面消去を実現できます。


GsOT(オーダリングテーブルハンドラ）

	LIBGSでは OTをGsOTという構造体でハンドルします。この構造体には
	OTの実体へのポインタと そのOTの属性を示すパラメータが格納されています
	メンバ org が OTの実体へのポインタです。

	OTにはZの目盛の解像度を２の１乗から１４乗までの１４段階の設定をする
	ことができます。この情報を メンバ length に保持します。


GsOT_TAG(オーダリングテーブル実体を構成する最小単位）

	GsOT_TAGは 先ほどの物差しのたとえでいうと 物差し一目盛のことです。
	GsOT_TAGの配列としてOTの実体が定義されます。例えば lengthが４であった
	場合、２の４乗 すなわち １６のOT_TAGの配列がOTの実体になるという
	ことです。


OTの初期化

	OTの初期化はGsClearOt()によって行ないます。GsClearOt()はoffset,point,
	otpの3つの引き数をとります。otpはOTハンドラへのポインタです。offset,
	pointについては後述します。

	OTは初期化されると ポリゴンを全くかかえていない状態となり、ソート
	可能となります。ソーティングをする前に必ず初期化を行なう必要が
	あります。


複数OT

	LIBGSではOTを複数持つことが許されています。複数のOTはGsSortOt()に
	よってOT同士をソートすることができます。この時にOTの代表値Zとして
	参照される値が構造体GsOTのメンバにあるpointです。

	複数のOTを用いることにより ソーティングの順番を コントロール
	することが可能となります。例えば、オブジェクト毎にローカルOTを
	用意し、最後にローカルOTをソートしてまとめれば オブジェクト単位
	のソーティングが可能です。これは 道路の上を自動車が走っている
	ところをヘリコプターで上から見下ろしている時などの 前後関係が
	既にわかっている場合などに有効です。


OTの圧縮

	OTを用いることで、ソーティングのスピードは高速化されますが、
	そのかわり OTはメモリーを消費します。OTでメモリーをあまり消費しない
	ようにするには、OTのlengthを少なくして OTの解像度を下げる方法が
	あります。ところが、OTの解像度を下げると ソーティングの解像度も
	下がってしまい 前後関係の間違いにるポリゴンがチラチラする現象
	（”Zソート問題”とよばれている）が起こりやすくなってしまいます。

	解像度を落さずにOTのメモリー使用量を減らす方法として オフセットを
	使うという方法があります。これは、ソートされるポリゴンのZ値が
	ある値よりも大きいことがわかっている場合に使用できます。その値を
	offsetとしてGsClearOt()に渡せばOTはoffsetまでの部分をメモリーに
	とりません。これによりメモリー使用量を減らすことができます。


Zソート問題

	Zソートにより陰面消去をする際に必ず問題になるのが 優先順位を
	取り違えて ポリゴンがチラチラするZソート問題です。これは
	優先順位を決定する際に参照されるZがポリゴン１つにつき１つである
	ことが原因です。とくに奥に長いポリゴンは Zの値が、一つのポリゴンで
	大きく広がっているにもかかわらず、ただ一つの代表値Zでしかソーティング
	されません。

	LIBGSでは ポリゴンの重心のZをソーティングの際に参照しています。

	Zソート問題を解消するには、ポリゴンを細かく分けるという方法が１つ
	あります。しかし ポリゴン数の増大は避けられません。

	もう一つの回避策として オブジェクト単位のソーティングがあります。
	オブジェクト毎の前後関係が明らかな場合は この条件を反映させて
	ソーティングすることでオブジェクト同士で干渉することのない
	ソーティングが可能です。


OTのダブルバッファ

	ポリゴンを割り付けられたOTはそのOTが描画されている間にはアクセス
	できません。そのため バックグラウンドで描画をする場合は OTを
	二つ用意し 描画に使われていないOTをソーティングに使わなくては
	いけません。



★表示のダブルバッファ

	プレイステーションでは、フレームバッファという概念をゲーム機に
	持ち込みました。これまでのスプライトを中心としたゲーム機は、
	１次元のラインバッファをもちそのラインにスプライトを重ねて
	表示していましたが プレイステーションでは ２次元のフレームバッファを
	もち 画面に表示されるイメージをそのまま ビデオメモリに再現します。

	表示は垂直基線同期（Vブランク）の間に切替えると画面が乱れずに
	切替ができます。切替えられた画面は、その画面がテレビの画面に
	表示されている間にアクセスされると 画面が乱れてしまいます。そのために
	表示されている面と、書き換えられている面の二つの面が必要です。

	これを 表示のダブルバッファと呼び LIBGSでは GsDefDispBuffer()に
	よってダブルバッファを定義しています。この定義されたダブルバッファ
	は、GsSwapDispBuff()によって切替が起こります。現在ダブルバッファの
	どちらに描画しているのかはGsGetActiveBuff()によって得ることができます。


ダブルバッファの実現

	ダブルバッファは 内部ではVRAMの表示位置を変えることで実現しています。
	そのため VRAMへオフセットつきで描画する必要があります。このオフセット
	をつける段階を libgsでは 二通りから 選ぶことができます。

	ひとつは libgteレベルでオフセットをつける方法です。この方法を選択すると
	パケットを計算して作る段階で ダブルバッファのオフセットが付けられます。
	もうひとつは libgpuレベルでオフセットをつける方法です。この方法を
	選択すると ダブルバッファのオフセットはパケットには つかず フレーム
	バッファに描画する段階で オフセットが付けられます。
	GsInitGraphの第３引数で どちらの方法をとるか選択できます。

	ただし libgpu関数との併用を 予定している場合は 後者の方法を選択
	することをお勧めします。

	現在 前者の方法を 用いるメリットは以前のバージョンとの互換性を保つ
	以外 特にありません。


インターレース時のダブルバッファ

	インターレースの時は縦解像度として ４８０の倍解像度を指定することが
	できます。この時のダブルバッファはフィールドの偶数・奇数で自動的に
	行なわれるため、GsDefDispBuff()でのダブルバッファの設定は同じバッファ
	を指定する必要があります。

	インターレース時に縦解像度を２４０とする場合はノンインターと同じ
	ように違うバッファを設定する必要があります。



★クリッピング

	LIBGSでは クリッピングは２Dのクリッピングと３Dのクリッピングの二つに
	わけられます。２Dのクリッピングはスクリーン座標系に変換した後に
	クリッピングすることです。３Dのクリッピングは 視点からの距離に応じて
	クリッピングするものです。


２Dクリッピング

	レンダリングチップにはVRAM上の任意の矩形をクリッピング領域として
	指定できる機能があります。GsSetClip2D()によりLIBGSの内部変数に
	クリッピング領域を登録します。GsSetDrawBuffClip()はその変数の
	内容をレンダリングチップに設定し有効にします。

	表示のダブルバッファの切替えは、クリッピング領域も切替えて はみ出した
	ポリゴンが、別のバッファを壊さないようにしています。


３Dクリッピング

	Gsライブラリでは ３Dのクリッピングは プログラマがアプリケーション
	レベルで行なうべきだとの 考えに立っています。よってライブラリレベル
	での３Dクリッピングはデフォルト値以外 サポートされていません。

	デフォルトの３Dクリップ値
	FAR CLIP
	スクリーン座標系のZ値は 符合なし１６ビットなので Zが６５５３６以上
	の時に クリップされます。
	NEAR CLIP
	プロジェクションをhとして スクリーン座標系のZ値が h/2 以下の時に
	クリップされます。


Nearクリップ問題

	3Dコンピュータグラフィックスにとって悩ましい問題として
	”Nearクリップ問題”があります。これはレーシングゲームの路面など
	ポリゴンが視点に限りなく接近してかつポリゴン自体が視点に近付いて
	いるため巨大になる場合に起こります。ポリゴン単位でクリップした場合
	視点近くの 路面に大きな穴があいてしまい、非常に見にくくなってしま
	います。

	LIBGSではこの問題の解決策として ポリゴンの自動分割をサポートしてます。
	オブジェクトが 接近した場合 アトリビュートに自動分割を設定することに
	より NearClipを円滑に行なえます。
	ただし 自動分割は 負荷が重いので 本当に必要な時の使用に限定してくだ
	さい。


★パケット作成関数群

	LIBGSは GsSortObject3() GsSortObject4() GsSortObject5() の３つの
	パケット作成関数を状況に応じて選択可能です。

パケットバッファ

	パケットバッファには 以下の二つの種類があります。
	１ プリセットパケットバッファ
	２ RUN TIME パケットバッファ

	１のプリセットパケットバッファは プリセットパケットのオブジェクトを
	使う時に 必要です。プリセットパケットを使うオブジェクトタイプは
	GsDOBJ5を使うGsSortObject5()関数です。

	プリセットパケットのサイズは モデルにより固定です。GsPresetObject()
	の返り値によってどこまでバッファがプリセットされたか知ることができます。
	プリセットは 最初に１回必要です。プリセットパケットは プリセットバッファ
	の領域にパケットを作るので RUN TIME パケットバッファを消費しません。
	ただし GsDOBJ5のアトリビュートで自動分割をONにした時は RUN TIME パケット
	バッファにパケットを作るので RUN TIME パケットバッファを消費します。


	２のRUN TIMEパケットバッファは 実行時にパケットを作るためのバッファです。
	これを使うのは GsSortObject4(),GsSortSpriteなどです。
	バッファの先頭は GsSetWorkBase()により指定され GsSortObjet4()が呼ばれる
	度に その領域にパケットを作っていき カレントのパケット領域のポインタは
	GsGetWorkBase()により取り出せます。
	バッファのサイズは １フレームに同時に表示されるために計算される ポリゴン
	の数により増減します。


プリセットパケット
	プリセットパケットとは パケットをあらかじめ作っておくということです。
	そうすれば 毎フレーム書き換えなくてもいい項目 例えば テクスチャの
	u,vなどは メモリにライトしなくてもいいため高速化されます。

	PMDフォーマットは プリセットパケット専用のモデリングフォーマットです。

	GsSortObject5()は プリセットパケットのパケット作成関数です。

	プリセットパケットを作るには GsPrsetObject()を用います。


プリセットパケットのフォーマット

	_________________
  |-----|header 0	|		header0: 32bitで上位８ビットは
  |	|header 1	|			 プリセットパケットの
  |	|---------------|			 タイプを示す
  |	|preset		|			 下位２４ビットは次の
  |	|packets	|			 パケット群へのポインタ
  |	|		|		header1: そのパケット群のプリセット
  |	|		|			 パケットの数
  |	|		|		         同一のタイプのパケットが
  |	|_______________|			 パケット群を構成する
  |---->|header 0	|		preset packets:
  |	|header 1	|			  パケットダブルバッファ
  |	|---------------|			  のためパケット数の２倍
  |	|preset		|			  用意されている。
  |	|packets	|
  |	|		|
  |	|		|
  |	|		|
  |	|_______________|
  :		:
  :		:
  :		:
  :	________________
  :---->| terminator	|		terminator: アドレス部が全て０
	|_______________|


	packetは、libgpu.hのPOLY_FT4などの構造体である。FT4などの種類は
	タイプを見ればわかる。tpageをセットしたければ、POLY_FT4などの
	構造体のtpageをセットすれば良い。



TMDのソート
	TMDフォーマットのモデリングデータは さまざまなポリゴンの種類が
	ランダムに並べてある状態も許容しています。しかし 実際にリアルタイムで
	TMDデータからパケットを作成するにあたって ランダムなポリゴンタイプの
	出現は その切替の度に デコードルーチンが切り替えられ インストラクション
	キャッシュの威力を十分発揮できません。

	そのために TMDデータ中のポリゴンタイプをまとめておくという高速化の
	手法があります。これがTMDソートです。

	TMDをソートはオーサリングレベルで行ないます。
	変換のためのコマンドは、TMDSORT.EXEです。このコマンドの解説は
	オーサリングツールの方の解説を参考にして下さい。

	GsSortObject4(),GsSortObject5()どちらのパケット作成関数も ソートされた
	TMDデータを使用すれば 高速化の効果があります。

GsSortObject3()

	GsSortObject3()は、PMDフォーマットのパケット作成を行ないます。
	オブジェクトハンドラは GsDOBJ3を使います。PMDデータを
	GsDOBJ3でハンドルするには GsLinkObject3()を一度呼んで TMD
	データとハンドラとを関連付ける必要があります。

	PMDフォーマットというのはモデリングデータとプリセットパケットが
	一体となったフォーマットです。

	TMDからPMDへのコンバートは オーサリングレベルで行ないます。
	変換のためのツールは TMD2PMD.EXEです。詳細はオーサリング
	ツールの解説を参考にして下さい。


GsSortObject4()

	GsSortObject4は 最も汎用的なオブジェクト計算ルーチンです。
	高速化のためにソートされたTMDフォーマットのデータを使用します。
	TMDデータのソートはtmdsort.exeコマンドで 行ないます。

	オブジェクトハンドラとしては GsDOBJ2をもちいます。TMDデータを
	GsDOBJ4でハンドルするには GsLinkObject4()を一度呼んで TMD
	データとハンドラとを関連付ける必要があります。

	あらかじめセットされたローカル／スクリーンマトリックスと
	ローカル／スクリーンライトマトリックスを参照してオブジェクトを
	ローカルスクリーン変換しソーティングしてOTに割り付けます。

	ローカル／スクリーンマトリックスのセットはGsSetLsMatrix()により行ない
	ます。ローカル／スクリーンライトマトリックスのセットは
	GsSetLightMatrix()により行ないます。

	OTに割り付けられたポリゴンはGsDrawOt()によって描画されます。この描画
	関数はすぐリターンし 描画はバックグラウンドで行なわれます。


GsSortObejct5()

	GsSortObject5は プリセットパケットを用いたパケット作成関数です。
	高速化のために ソートされたTMDフォーマットのデータを使用します。
	TMDデータのソートはtmdsort.exeコマンドで行ないます。

	オブジェクトハンドラとしては GsDOBJ5を使用します。TMDデータを
	GsDOBJ5でハンドルするには GsLinkObject5()を一度呼んで TMD
	データとハンドラを関連づける必要があります。

	プリセットパケットを作成するには GsPresetObject()を用います。
	GsSortObject5()でパケットを作成するためには GsPresetObject()を
	イニシャライズで一度呼び プリセットパケットを作成しておく必要
	が あります。



パケット作成関数群 機能比較表

 ┌───────┬────┬──┬──┬─┬──┬─┬──┬─┬───┐
 │     	 │    A   │  B │ C  │D │ E  │F │ G  │H │ I    │
 ├───────┼────┼──┼──┼─┼──┼─┼──┼─┼───┤
 │GsSortObject3 │GsDOBJ3 │ × │ × │×│ × │×│ × │×│250K  │
 ├───────┼────┼──┼──┼─┼──┼─┼──┼─┼───┤
 │GsSortObject4 │GsDOBJ2 │ × │ ○ │○│ × │×│ ○ │○│  ?   │
 ├───────┼────┼──┼──┼─┼──┼─┼──┼─┼───┤
 │GsSortObject5 │GsDOBJ5 │ × │ ○ │○│ × │×│ × │○│220K  │
 └───────┴────┴──┴──┴─┴──┴─┴──┴─┴───┘

	A) OBJTYPE	使用するオブジェクトハンドラ
	B) material減衰	attributeを参照のこと
	C）FOG			同上
	D）光源計算OFF		同上
	E）NearZ CLIP		同上
	F) back clip		同上
	G) 半透明レート		同上
	H) 自動分割		同上
	I) 性能		10x10 フラット三角形 実測値
			GsSortObject4の性能は SortObject2以上 SortObject5以下


┌───────┬────┬───┬─────┬──────┬────┐
│      	│Presort │Preset│ Preshad  │WorkBase    │tools   │
├───────┼────┼───┼────┴┼──────┼────┤
│GsSortOBject3	│ OK	  │ OK   │   OK     │  NG	    │Tmd2pdm │
│      	│        │      │          │	    │TMDSORT │
├───────┼────┼───┼─────┼──────┼────┤
│GsSortObject4 │ OK     │ NG	  │ OK／NG   │  OK        │rsdlink │
│      	│        │      │          │	    │TMDSORT │
├───────┼────┼───┼─────┼──────┼────┤
│GsSortOBject5 │ OK	  │ OK   │ OK／NG   │NG(normal)  │rsdlink │
│              │        │      │          │OK(自動分割)│TMDSORT │
└───────┴────┴───┴─────┴──────┴────┘



★パケット領域

	GsSortObject4()は、パケットを作成しオーダリングテーブルに割り付けます。
	パケットが作られる領域は、GsSetWorkBase()によってLIBGSに設定します。
	パケットは ポリゴンの種類（フラット／グーロー、テクスチャあり／なし）
	や数によって増減するためパケット領域をどれくらいとればいいかは
	大体にしか見積もれません。 ただし パケット領域が実際に作成される
	パケットより小さい場合は パケット領域の後ろにある 領域は壊される
	ので注意が必要です。

	現在 パケット領域がどのくらいまで使われているかを返す関数が
	GsGetWorkBase()です。この関数によって プログラマはオーバフロー
	の危険性を予知できます。

	GsSortObject5()を使った場合は プリセットパケットのエリアに パケット
	領域が 予めとられているため GsSetWorkBase()を使用して 新たにパケット
	領域を確保する必要はありません。

	ただし 自動分割の機能を使う場合は 分割して増えた分のパケットは
	GsSetWorkBase()で設定した パケット領域に作られるのでGsSetWorkBase()
	によるパケット領域の設定が必要です。



パケットのダブルバッファ

	描画をバックグラウンドで行なうため、描画中のパケットは壊すことが
	できません。そのためパケット領域を二つとり ダブルバッファにする必要
	があります。


★描画について

	描画は GsDrawOt()によりスタートします。描画面はGsSwapDispBuff()が
	コールされるたびに切り替わります。描画はバックグラウンドで行なわれる
	ため、描画に十分時間をかけることができます。

	描画のプロセスはまず、描画面に残っている２フレーム前のイメージを
	消してから GsSortObject...()で作成されたパケットを描画していくことで
	行なわれます。画面をクリアするためのパケットを OTに登録する関数が
	GsSortClear()です。引数により 任意の色にクリアできます。



**処理の流れの概要

	各フレーム毎に必要な3D処理の典型的な手順を以下に示します。


		  使用バッファ選定
			↓
		    OTのクリア
			↓
		透視変換／Ｚソート（OTへコマンド登録）
			↓
		  V-Blanking同期
			↓
		    OT描画開始


	詳細はサンプルプログラムを参考にして下さい。


★LIBGSの拡張方針

	LIBGSは、GsSortObject4()などのSort系関数を増やすことでいろいろな
	フォーマットに対応できます。また 速度を向上させるために、
	GsFast系関数なども用意する予定です。

	基本的にLIBGSでは関数が	増大しても リンクは関数毎に行なえるように
	するため実行オブジェクトが大きくなる心配はありません。

